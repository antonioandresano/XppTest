Exportfile for AOT version 1.0 or later
Formatversion: 1

***Element: CLS

; Microsoft Dynamics AX Class: scaricamento di ATC_SubledgerJournalizer
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #ATC_SubledgerJournalizer
    PROPERTIES
      Name                #ATC_SubledgerJournalizer
      RunOn               #Server
      Origin              #{F49555F1-4129-41A9-85BC-F8173731BCFA}
    ENDPROPERTIES
    
    METHODS
      SOURCE #parmDocumentLine
        #public SourceDocumentLIneRecId parmDocumentLine(SourceDocumentLIneRecId _sourceDocumentLineRecId = sourceDocumentLineRecId)
        #{
        #    sourceDocumentLineRecId = _sourceDocumentLineRecId;
        #    return sourceDocumentLineRecId;
        #}
      ENDSOURCE
      SOURCE #addedStandardAccountingDistributionTmp
        #/// <summary>
        #/// An <c>AccountingDistributionTmp</c> record added event handler delegate. It will be raised for the standard accoounting
        #/// distribution tmp record which is created from accounting distribution.
        #/// </summary>
        #/// <param name="_sourceDocumentLineItem">
        #/// An instance of <c>SourceDocumentLineItem</c> class.
        #/// </param>
        #/// <param name="_accountingDistributionTmp">
        #/// An <c>AccountingDistributionTmp</c> record being inserted.
        #/// </param>
        #/// <param name="_allocationFactor">
        #/// An allocation factor.
        #/// </param>
        #delegate void addedStandardAccountingDistributionTmp(
        #    SourceDocumentLineItem      _sourceDocumentLineItem,
        #    AccountingDistributionTmp   _accountingDistributionTmp,
        #    AllocationFactor            _allocationFactor)
        #{
        #}
      ENDSOURCE
      SOURCE #addToSubledgerJournalErrorLog
        #private boolean addToSubledgerJournalErrorLog(RecId _accountingEvent, Exception _exception, LabelId _labelId, container _parameters = conNull())
        #{
        #    SubledgerJournalErrorLog                subledgerJournalErrorLog;
        #    SourceDocumentLineSubledgerJourErrorLog sourceDocumentLineErrorLink;
        #    SourceDocumentLine                      sourceDocumentLine;
        #    AccountingDistribution                  accountingDistribution;
        #    RefRecId                                subledgerJournalErrorLogRecId;
        #
        #
        #    Debug::assert(SysLabel::isLabelId(_labelId));
        #
        #    if (!connection)
        #    {
        #        connection = new UserConnection();
        #    }
        #
        #    connection.ttsbegin();
        #    subledgerJournalErrorLog.setConnection(connection);
        #    sourceDocumentLineErrorLink.setConnection(connection);
        #
        #    subledgerJournalErrorLog.clear();
        #    subledgerJournalErrorLog.Exception = _exception;
        #    subledgerJournalErrorLog.LabelId = _labelId;
        #    subledgerJournalErrorLog.Parameters = _parameters;
        #    subledgerJournalErrorLog.insert();
        #
        #    subledgerJournalErrorLogRecId = subledgerJournalErrorLog.RecId;
        #
        #
        #    // Note: can't use set based insert because accounting event and distributions are on a different connection
        #    // and not visable on this connnection.
        #    while select SourceDocumentLine from accountingDistribution
        #        group by SourceDocumentLine
        #        where accountingDistribution.AccountingEvent == _accountingEvent
        #        exists join sourceDocumentLine
        #            where sourceDocumentLine.RecId == accountingDistribution.SourceDocumentLine &&
        #                sourceDocumentLine.ParentSourceDocumentLine == 0
        #
        #    {
        #        sourceDocumentLineErrorLink.SubledgerJournalErrorLog = subledgerJournalErrorLogRecId;
        #        sourceDocumentLineErrorLink.SourceDocumentLine = accountingDistribution.SourceDocumentLine;
        #        sourceDocumentLineErrorLink.insert();
        #    }
        #
        #    connection.ttscommit();
        #
        #    return (_exception == Exception::Info) ? true : false;
        #}
      ENDSOURCE
      SOURCE #addValidAccountingDateToCache
        #private void addValidAccountingDateToCache(LedgerRecId _ledgerRecId, AccountingDate _accoutingDate, FiscalPeriodType _periodType)
        #{
        #    validAccountingDateSet.add([_ledgerRecId, _accoutingDate, _periodType]);
        #}
      ENDSOURCE
      SOURCE #applyRoundingToSubledgerJournalTmpDetail
        #/// <summary>
        #///     Applies the rounding differnce to <c>SubledgerJournalAccountEntryTmpDetail</c> transactions.
        #/// </summary>
        #/// <param name="_accountingCurrencyAmountToRound">
        #///     The amount of rounding in accounting currency.
        #/// </param>
        #/// <param name="_reportingCurrencyAmountToRound">
        #///     The amount of rounding in reporting currency.
        #/// </param>
        #/// <param name="_applyRoundingToNonTaxLineOnly">
        #///     Rounding is not applied to tax lines if this is true, always true for the first time.
        #/// </param>
        #/// <param name="_debitRoundingApplied">
        #///     True, if the rounding was already applied to debit line.
        #/// </param>
        #/// <param name="_creditRoundingApplied">
        #///     True, if the rounding was already applied to credit line.
        #/// </param>
        #/// <remarks>
        #///     Method logic attempts to first apply debit or credit rounding entries to the maximum RecID of any non-tax lines
        #///     that meet the specified conditions. If this is not possible, then rounding is applied to the maximum RecID of any lines,
        #///     which might include tax lines.
        #/// </remarks>
        #private void applyRoundingToSubledgerJournalTmpDetail(
        #    AmountMST   _accountingCurrencyAmountToRound,
        #    AmountMST   _reportingCurrencyAmountToRound,
        #    boolean     _applyRoundingToNonTaxLineOnly = true,
        #    boolean     _debitRoundingApplied          = false,
        #    boolean     _creditRoundingApplied         = false)
        #{
        #    SubledgerJournalAccountEntryTmpDetail   roundingEntrySubledgerJournalAccountEntryTmpDetail;
        #    SubledgerJournalAccountEntryTmpDetail   updateEntrySubledgerJournalAccountEntryTmpDetail;
        #
        #    roundingEntrySubledgerJournalAccountEntryTmpDetail.linkPhysicalTableInstance(subledgerJournalAccountEntryTmpDetail);
        #    updateEntrySubledgerJournalAccountEntryTmpDetail.linkPhysicalTableInstance(subledgerJournalAccountEntryTmpDetail);
        #
        #    while select maxof(RecId) from roundingEntrySubledgerJournalAccountEntryTmpDetail
        #            group by TransactionCurrencyCode,
        #                    ExchangeRate1,
        #                    ExchangeRate2,
        #                    ReportingExchangeRate1,
        #                    ReportingExchangeRate2,
        #                    ExchangeRateDate,
        #                    DebitCredit
        #        where roundingEntrySubledgerJournalAccountEntryTmpDetail.Ledger == subledgerJournalAccountEntryTmpDetail.Ledger
        #            && roundingEntrySubledgerJournalAccountEntryTmpDetail.FiscalCalendarPeriod == subledgerJournalAccountEntryTmpDetail.FiscalCalendarPeriod
        #            && roundingEntrySubledgerJournalAccountEntryTmpDetail.PostingLayer == subledgerJournalAccountEntryTmpDetail.PostingLayer
        #            && roundingEntrySubledgerJournalAccountEntryTmpDetail.SubledgerJournalEntryType == subledgerJournalAccountEntryTmpDetail.SubledgerJournalEntryType
        #            && roundingEntrySubledgerJournalAccountEntryTmpDetail.IsReversal == NoYes::No   //reversal/relieving entries should not be modified, don't pick them to apply difference to
        #            && roundingEntrySubledgerJournalAccountEntryTmpDetail.TransactionCurrencyCode == subledgerJournalAccountEntryTmpDetail.TransactionCurrencyCode // only apply rounding if currencies match
        #            // only apply rounding if the exchange rates match
        #            && roundingEntrySubledgerJournalAccountEntryTmpDetail.ExchangeRate1 == subledgerJournalAccountEntryTmpDetail.ExchangeRate1
        #            && roundingEntrySubledgerJournalAccountEntryTmpDetail.ExchangeRate2 == subledgerJournalAccountEntryTmpDetail.ExchangeRate2
        #            && roundingEntrySubledgerJournalAccountEntryTmpDetail.ExchangeRateDate == subledgerJournalAccountEntryTmpDetail.ExchangeRateDate
        #            && roundingEntrySubledgerJournalAccountEntryTmpDetail.ReportingExchangeRate1 == subledgerJournalAccountEntryTmpDetail.ReportingExchangeRate1
        #            && roundingEntrySubledgerJournalAccountEntryTmpDetail.ReportingExchangeRate2 == subledgerJournalAccountEntryTmpDetail.ReportingExchangeRate2
        #            // <GEEU>
        #            && roundingEntrySubledgerJournalAccountEntryTmpDetail.TransactionCurrencyAmount != 0
        #            && roundingEntrySubledgerJournalAccountEntryTmpDetail.ExchangeRate1 != 0
        #            // </GEEU>
        #            && (!_applyRoundingToNonTaxLineOnly ||
        #                // Do not apply the rounding adjustment to tax line
        #                (roundingEntrySubledgerJournalAccountEntryTmpDetail.PostingType != LedgerPostingType::Tax
        #                && roundingEntrySubledgerJournalAccountEntryTmpDetail.PostingType != LedgerPostingType::TaxReport
        #                && roundingEntrySubledgerJournalAccountEntryTmpDetail.PostingType != LedgerPostingType::TaxWithhold))
        #    {
        #        select firstonly forupdate updateEntrySubledgerJournalAccountEntryTmpDetail
        #            where updateEntrySubledgerJournalAccountEntryTmpDetail.RecId == roundingEntrySubledgerJournalAccountEntryTmpDetail.RecId;
        #
        #        if (updateEntrySubledgerJournalAccountEntryTmpDetail)
        #        {
        #            if (!_debitRoundingApplied && updateEntrySubledgerJournalAccountEntryTmpDetail.DebitCredit == DebitCredit::Debit)
        #            {
        #                updateEntrySubledgerJournalAccountEntryTmpDetail.AccountingCurrencyAmount += _accountingCurrencyAmountToRound;
        #                updateEntrySubledgerJournalAccountEntryTmpDetail.ReportingCurrencyAmount += _reportingCurrencyAmountToRound;
        #                _debitRoundingApplied = true;
        #                updateEntrySubledgerJournalAccountEntryTmpDetail.update();
        #            }
        #            else if (!_creditRoundingApplied && updateEntrySubledgerJournalAccountEntryTmpDetail.DebitCredit == DebitCredit::Credit)
        #            {
        #                updateEntrySubledgerJournalAccountEntryTmpDetail.AccountingCurrencyAmount -= _accountingCurrencyAmountToRound;
        #                updateEntrySubledgerJournalAccountEntryTmpDetail.ReportingCurrencyAmount -= _reportingCurrencyAmountToRound;
        #                _creditRoundingApplied = true;
        #                updateEntrySubledgerJournalAccountEntryTmpDetail.update();
        #            }
        #        }
        #    }
        #
        #    // Check if rounding was applied to both debit and credit transactions. If not then do a recursive call to this method again,
        #    // but this time remove the restriction for non tax lines by setting _applyRoundingToNonTaxLineOnly to false
        #    if (_applyRoundingToNonTaxLineOnly &&
        #       (!_debitRoundingApplied || !_creditRoundingApplied))
        #    {
        #        this.applyRoundingToSubledgerJournalTmpDetail(_accountingCurrencyAmountToRound, _reportingCurrencyAmountToRound, false, _debitRoundingApplied, _creditRoundingApplied);
        #    }
        #}
      ENDSOURCE
      SOURCE #applyRoundingToSubledgerJourTmpDetail
        #/// <summary>
        #///   Event is called before applying rounding to <c>SubledgerJournalAccountEntryTmpDetail</c> table and allow to override standard rounding algorithm.
        #/// </summary>
        #/// <param name="_sysEventOverride">
        #///   Insertion override status.
        #/// </param>
        #/// <param name="_subledgerJournalAccountEntryTmpDetail">
        #///   <c>SubledgerJournalAccountEntryTmpDetail</c> buffer being rounded.
        #/// </param>
        #/// <param name="_accountingCurrencyAmountToRound">
        #///   Rounding amount in accounting currency.
        #/// </param>
        #/// <param name="_reportingCurrencyAmountToRound">
        #///   Rounding amount in reporting currency.
        #/// </param>
        #delegate void applyRoundingToSubledgerJourTmpDetail(
        #    SysEventOverride _sysEventOverride,
        #    SubledgerJournalAccountEntryTmpDetail _subledgerJournalAccountEntryTmpDetail,
        #    AmountMST _accountingCurrencyAmountToRound,
        #    AmountMSTSecondary _reportingCurrencyAmountToRound)
        #{
        #}
      ENDSOURCE
      SOURCE #applyRoundingToTmpDetailInExtensions
        #/// <summary>
        #///   Raises event to allow extensions to override rounding of <c>SubledgerJournalAccountEntryTmpDetail</c> records.
        #/// </summary>
        #/// <param name="_accountingCurrencyAmountToRound">
        #///   Rounding amount in accounting currency.
        #/// </param>
        #/// <param name="_reportingCurrencyAmountToRound">
        #///   Rounding amount in reporting currency.
        #/// </param>
        #/// <returns>
        #///   true if rounding is already done; otherwise, false.
        #/// </returns>
        #protected boolean applyRoundingToTmpDetailInExtensions(AmountMST _accountingCurrencyAmountToRound, AmountMSTSecondary _reportingCurrencyAmountToRound)
        #{
        #    SysEventOverride override = SysEventOverride::construct();
        #
        #    this.applyRoundingToSubledgerJourTmpDetail(override, subledgerJournalAccountEntryTmpDetail, _accountingCurrencyAmountToRound, _reportingCurrencyAmountToRound);
        #
        #    return override.isOverridden();
        #}
        #
      ENDSOURCE
      SOURCE #balanceSubledgerJournalEntryTmpInterunit
        #private void balanceSubledgerJournalEntryTmpInterunit()
        #{
        #    LedgerTmpInterunitBalancerAccountEntry      interUnitBalancingEntriesReversal;
        #    LedgerTmpInterunitBalancerAccountEntry      interUnitBalancingEntriesNonReversal;
        #
        #    if(LedgerInterunitBalancer::isBalancingEnabled())
        #    {
        #        //ATTENTION, the order of operations is important here.
        #        //Flipping the order will cause the output of the first call to be picked up as valid input for the
        #        //second call, which will generate extra balancing entries that should not have been generated.
        #
        #        //balance the non-reversal entries first, because the next call will automatically filter out
        #        //the balancing entries generated here(the balancing entries will not be marked as reversal).
        #        interUnitBalancingEntriesNonReversal = this.generateInterunitBalancingEntries(NoYes::No);
        #        this.insertInterunitBalancingEntries(interUnitBalancingEntriesNonReversal);
        #
        #        //balance the reversal entries last, because this may generate extra non-reversal entries,
        #        //which we don't want to feed to the balancer.
        #        interUnitBalancingEntriesReversal = this.generateInterunitBalancingEntries(NoYes::Yes);
        #        this.insertInterunitBalancingEntries(interUnitBalancingEntriesReversal);
        #    }
        #}
      ENDSOURCE
      SOURCE #calculateForeignCurAmounts
        #// <GEEU> overriden for use in bond extension
        #public
        #// </GEEU>
        #void calculateForeignCurAmounts(AccountingDistributionTmp   _accountingDistributionTmp,
        #                                        SourceDocumentLineItemTmp   _sourceDocumentLineItemTmp = null)
        #{
        #
        #    CurrencyExchangeHelper              currencyExchangeHelper;
        #    CurrencyCalculationResults          accountingCurrencyAmounts, reportingCurrencyAmounts;
        #    boolean                             roundResult;
        #
        #    roundResult = true;
        #
        #    currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(_accountingDistributionTmp.Ledger, _accountingDistributionTmp.ExchangeRateDate);
        #    currencyExchangeHelper.parmExchangeRate1(_accountingDistributionTmp.ExchangeRate1);
        #    currencyExchangeHelper.parmExchangeRate2(_accountingDistributionTmp.ExchangeRate2);
        #    currencyExchangeHelper.parmReportingExchangeRate1(_accountingDistributionTmp.ReportingExchangeRate1);
        #    currencyExchangeHelper.parmReportingExchangeRate2(_accountingDistributionTmp.ReportingExchangeRate2);
        #
        #    accountingCurrencyAmounts = currencyExchangeHelper.calculateTransactionToAccountingAmounts(_accountingDistributionTmp.TransactionCurrency,
        #                                                                                               _accountingDistributionTmp.TransactionCurrencyAmount);
        #
        #    reportingCurrencyAmounts = currencyExchangeHelper.calculateTransactionToReportingAmounts(_accountingDistributionTmp.TransactionCurrency,
        #                                                                                             _accountingDistributionTmp.TransactionCurrencyAmount);
        #
        #    _accountingDistributionTmp.AccountingCurrencyAmount = accountingCurrencyAmounts.getRoundedAmount();
        #    _accountingDistributionTmp.ReportingCurrencyAmount = reportingCurrencyAmounts.getRoundedAmount();
        #
        #    _accountingDistributionTmp.AccountingCurrencyAmountUnrounded = accountingCurrencyAmounts.getUnroundedAmount();
        #    _accountingDistributionTmp.ReportingCurrencyAmountUnrounded = reportingCurrencyAmounts.getUnroundedAmount();
        #
        #    if (_sourceDocumentLineItemTmp)
        #    {
        #        if (_accountingDistributionTmp.Ledger == _sourceDocumentLineItemTmp.Ledger)
        #        {
        #            _accountingDistributionTmp.SourceDocLineAccountingCurrencyAmount = _accountingDistributionTmp.AccountingCurrencyAmount;
        #            _accountingDistributionTmp.SourceDocLineReportingCurrencyAmount = _accountingDistributionTmp.ReportingCurrencyAmount;
        #        }
        #        else
        #        {
        #            currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(_sourceDocumentLineItemTmp.Ledger, _sourceDocumentLineItemTmp.ExchangeRateDate);
        #            currencyExchangeHelper.parmExchangeRate1(_sourceDocumentLineItemTmp.ExchangeRate1);
        #            currencyExchangeHelper.parmExchangeRate2(_sourceDocumentLineItemTmp.ExchangeRate2);
        #            currencyExchangeHelper.parmReportingExchangeRate1(_sourceDocumentLineItemTmp.ReportingExchangeRate1);
        #            currencyExchangeHelper.parmReportingExchangeRate2(_sourceDocumentLineItemTmp.ReportingExchangeRate2);
        #
        #            _accountingDistributionTmp.SourceDocLineAccountingCurrencyAmount =
        #                                currencyExchangeHelper.calculateTransactionToAccounting(_accountingDistributionTmp.TransactionCurrency,
        #                                                                                        _accountingDistributionTmp.TransactionCurrencyAmount,
        #                                                                                        roundResult);
        #            _accountingDistributionTmp.SourceDocLineReportingCurrencyAmount =
        #                                currencyExchangeHelper.calculateTransactionToReporting(_accountingDistributionTmp.TransactionCurrency,
        #                                                                                        _accountingDistributionTmp.TransactionCurrencyAmount);
        #        }
        #    }
        #
        #    if (_accountingDistributionTmp.ervExchangeRate1 || _accountingDistributionTmp.ervReportingExchangeRate1)
        #    {
        #        currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(_accountingDistributionTmp.Ledger, _accountingDistributionTmp.ExchangeRateDate);
        #        currencyExchangeHelper.parmExchangeRate1(_accountingDistributionTmp.ervExchangeRate1);
        #        currencyExchangeHelper.parmExchangeRate2(_accountingDistributionTmp.ervExchangeRate2);
        #        currencyExchangeHelper.parmReportingExchangeRate1(_accountingDistributionTmp.ervReportingExchangeRate1);
        #        currencyExchangeHelper.parmReportingExchangeRate2(_accountingDistributionTmp.ervReportingExchangeRate2);
        #
        #        _accountingDistributionTmp.ervAccountingCurrencyAmount =
        #                            currencyExchangeHelper.calculateTransactionToAccounting(_accountingDistributionTmp.TransactionCurrency,
        #                                                                                    _accountingDistributionTmp.TransactionCurrencyAmount,
        #                                                                                    roundResult);
        #        _accountingDistributionTmp.ervReportingCurrencyAmount =
        #                            currencyExchangeHelper.calculateTransactionToReporting(_accountingDistributionTmp.TransactionCurrency,
        #                                                                                    _accountingDistributionTmp.TransactionCurrencyAmount);
        #    }
        #}
      ENDSOURCE
      SOURCE #canPerformDetailRoundingAdjustment
        #private boolean canPerformDetailRoundingAdjustment(SourceDocument _sourceDocument)
        #{
        #    SubledgerJourDetailRoundingAdjuster detailRoundingAdjuster;
        #    boolean canPerformDetailRoundingAdjustment;
        #
        #    if (this.isExcludedFromDetailOrSummaryRounding())
        #    {
        #        canPerformDetailRoundingAdjustment = false;
        #    }
        #    else
        #    {
        #        detailRoundingAdjuster = SubledgerJourDetailRoundingAdjuster::newFromDocument(_sourceDocument);
        #        canPerformDetailRoundingAdjustment = detailRoundingAdjuster.canPerformAdjustment();
        #    }
        #
        #    return canPerformDetailRoundingAdjustment;
        #}
      ENDSOURCE
      SOURCE #canPerformSummaryRoundingAdjustment
        #private boolean canPerformSummaryRoundingAdjustment(SourceDocument _sourceDocument)
        #{
        #    SubledgerJourSummaryRoundingAdjuster summaryRoundingAdjuster;
        #    boolean canPerformSummaryRoundingAdjustment;
        #
        #    if (this.isExcludedFromDetailOrSummaryRounding())
        #    {
        #        canPerformSummaryRoundingAdjustment = false;
        #    }
        #    else
        #    {
        #        summaryRoundingAdjuster = SubledgerJourSummaryRoundingAdjuster::newFromDocument(_sourceDocument);
        #        canPerformSummaryRoundingAdjustment = summaryRoundingAdjuster.canPerformAdjustment();
        #    }
        #
        #    return canPerformSummaryRoundingAdjustment;
        #}
      ENDSOURCE
      SOURCE #checkDebitCredit
        #private boolean checkDebitCredit(SubledgerJournalAccountEntry _subledgerJournalAccountEntry, MainAccount _mainAccount)
        #{
        #    boolean                         isValid;
        #    DimensionDisplayValue           dimensionDisplayValue;
        #
        #
        #    switch (_mainAccount.DebitCreditCheck)
        #    {
        #        case DebCredProposal::Debit:
        #            dimensionDisplayValue = DimensionAttributeValueCombination::getDisplayValue(_subledgerJournalAccountEntry.LedgerDimension);
        #            if ((_subledgerJournalAccountEntry.TransactionCurrencyAmount < 0 && !_subledgerJournalAccountEntry.IsCorrection) ||
        #                (_subledgerJournalAccountEntry.TransactionCurrencyAmount > 0 && _subledgerJournalAccountEntry.IsCorrection))
        #            {
        #                isValid = this.addToSubledgerJournalErrorLog(SubledgerJournalEntry::find(_subledgerJournalAccountEntry.SubledgerJournalEntry).AccountingEvent, Exception::Warning, literalStr("@SYS18433"), [dimensionDisplayValue]);
        #                return checkFailed(strFmt("@SYS18433", dimensionDisplayValue));
        #            }
        #            break;
        #
        #        case DebCredProposal::Credit:
        #            dimensionDisplayValue = DimensionAttributeValueCombination::getDisplayValue(_subledgerJournalAccountEntry.LedgerDimension);
        #            if ((_subledgerJournalAccountEntry.TransactionCurrencyAmount > 0 && !_subledgerJournalAccountEntry.IsCorrection) ||
        #                (_subledgerJournalAccountEntry.TransactionCurrencyAmount < 0 && _subledgerJournalAccountEntry.IsCorrection))
        #            {
        #                isValid = this.addToSubledgerJournalErrorLog(SubledgerJournalEntry::find(_subledgerJournalAccountEntry.SubledgerJournalEntry).AccountingEvent, Exception::Warning, literalStr("@SYS18434"), [dimensionDisplayValue]);
        #                return checkFailed(strFmt("@SYS18434", dimensionDisplayValue));
        #            }
        #            break;
        #
        #        default:
        #            return true;
        #    }
        #
        #    return true;
        #}
        #
      ENDSOURCE
      SOURCE #checkDebitCreditForTmpSummary
        #private boolean checkDebitCreditForTmpSummary(SubledgerJournalAccountEntryTmpSummary _tmpSummary, MainAccount _mainAccount)
        #{
        #    boolean                         isValid;
        #    DimensionDisplayValue           dimensionDisplayValue;
        #
        #
        #    switch (_mainAccount.DebitCreditCheck)
        #    {
        #        case DebCredProposal::Debit:
        #            dimensionDisplayValue = DimensionAttributeValueCombination::getDisplayValue(_tmpSummary.LedgerDimension);
        #            if ((_tmpSummary.TransactionCurrencyAmount < 0 && !_tmpSummary.IsCorrection) ||
        #                (_tmpSummary.TransactionCurrencyAmount > 0 && _tmpSummary.IsCorrection))
        #            {
        #                isValid = this.addToSubledgerJournalErrorLog(SubledgerJournalEntry::find(_tmpSummary.SubledgerJournalEntry).AccountingEvent, Exception::Warning, literalStr("@SYS18433"), [dimensionDisplayValue]);
        #                return checkFailed(strFmt("@SYS18433", dimensionDisplayValue));
        #            }
        #            break;
        #
        #        case DebCredProposal::Credit:
        #            dimensionDisplayValue = DimensionAttributeValueCombination::getDisplayValue(_tmpSummary.LedgerDimension);
        #            if ((_tmpSummary.TransactionCurrencyAmount > 0 && !_tmpSummary.IsCorrection) ||
        #                (_tmpSummary.TransactionCurrencyAmount < 0 && _tmpSummary.IsCorrection))
        #            {
        #                isValid = this.addToSubledgerJournalErrorLog(SubledgerJournalEntry::find(_tmpSummary.SubledgerJournalEntry).AccountingEvent, Exception::Warning, literalStr("@SYS18434"), [dimensionDisplayValue]);
        #                return checkFailed(strFmt("@SYS18434", dimensionDisplayValue));
        #            }
        #            break;
        #
        #        default:
        #            return true;
        #    }
        #
        #    return true;
        #}
        #
      ENDSOURCE
      SOURCE #classDeclaration
        #public final class ATC_SubledgerJournalizer
        #{
        #    SubledgerJournalAccountEntryTmpDetail           subledgerJournalAccountEntryTmpDetail;
        #
        #    AccountingDistributionTmp                       accountingDistributionTmp;
        #    SourceDocumentLineItemTmp                       sourceDocumentLineItemTmp;
        #    AccountingDistributionTmpJournalize             accountingDistributionTmpJournalize;
        #    SourceDocumentType                              sourceDocumentType;
        #    SourceDocument                                  sourceDocument;
        #    Set                                             validAccountingDateSet;
        #    Map                                             fiscalCalendarPeriods;
        #    Map                                             exchangeRates;
        #    Map                                             referenceDistributionExchangeRates;
        #    Map                                             gainLossLedgerDimensions;
        #    Set                                             relieveingRequiredSet;
        #    Map                                             accountingPolicyMap;
        #    Map                                             sourceDocumentLineItemMap;
        #    Map                                             subledgerJournalEntries; // [[Voucher, AccountingDate], SubledgerJournalEntry]
        #    Map                                             sourceDocumentLineItemImplMap;
        #    SourceDocumentProcessorCaller                   caller;
        #    boolean                                         hasInterCompany;
        #    DimensionValuesUsedForSummaryAccount            dimensionValuesUsedForSummaryAccount;
        #    boolean                                         hasFinalizing;
        #    boolean                                         hasRelieving;
        #    boolean                                         hasYearEnd;
        #    boolean                                         hasExchangeRateVariance;
        #    SubledgerJournalizerExtensionList               subledgerJournalizerExtensionList;
        #    SourceDocumentLineRelieving                     sourceDocumentLineRelieving;
        #    SourceDocumentLineRelievingAmount               sourceDocumentLineRelievingAmount;
        #    boolean                                         isPreviewMode;
        #    boolean                                         mustDoFinalize;
        #    SourceDocumentHeaderRecId                       sourceDocumentHeaderRecId;
        #
        #    sourceDocumentLineRecId                         sourceDocumentLineRecId;
        #
        #    UserConnection                                  connection;
        #    FiscalCalendarPeriodRecId                       periodClosingFiscalCalendarPeriodRecId;
        #    SubledgerJournalAccountEntryRelievingTmp        subledgerJournalAccountEntryRelievingTmp;
        #    SubledgerJournalReliever                        subledgerJournalReliever;
        #    // <GIN>
        #    // <GEEU>
        #    #ISOCountryRegionCodes
        #    // </GEEU>
        #    // </GIN>
        #}
      ENDSOURCE
      SOURCE #clearSubledgerJournalErrorLog
        #private void clearSubledgerJournalErrorLog(RecId _accountingEvent)
        #{
        #    SubledgerJournalErrorLog                subledgerJournalErrorLog;
        #    AccountingDistribution                  accountingDistribution;
        #    SourceDocumentLine                      sourceDocumentLine;
        #    SourceDocumentLineSubledgerJourErrorLog sourceDocumentLineErrorLink;
        #    Set                                     recordsToDelete;
        #    SetEnumerator                           recordsToDeleteEnum;
        #
        #    recordsToDelete = new Set(Types::Int64);
        #
        #    // Note: can't use set based delete because accounting event is on a different connection
        #    // and not visable on this connnection.
        #    while select forupdate RecId from subledgerJournalErrorLog
        #        join sourceDocumentLineErrorLink
        #            where sourceDocumentLineErrorLink.SubledgerJournalErrorLog == subledgerJournalErrorLog.RecId
        #        join sourceDocumentLine
        #            where sourceDocumentLine.RecId == sourceDocumentLineErrorLink.SourceDocumentLine
        #        join accountingDistribution
        #            where accountingDistribution.SourceDocumentLine == sourceDocumentLine.RecId &&
        #                accountingDistribution.AccountingEvent == _accountingEvent
        #    {
        #        recordsToDelete.add(subledgerJournalErrorLog.RecId);
        #    }
        #
        #    if (!recordsToDelete.empty())
        #    {
        #        if (!connection)
        #        {
        #            connection = new UserConnection();
        #        }
        #
        #        subledgerJournalErrorLog.setConnection(connection);
        #        connection.ttsbegin();
        #
        #        recordsToDeleteEnum = recordsToDelete.getEnumerator();
        #
        #        while (recordsToDeleteEnum.moveNext())
        #        {
        #            delete_from subledgerJournalErrorLog
        #                where subledgerJournalErrorLog.RecId == recordsToDeleteEnum.current();
        #        }
        #        connection.ttscommit();
        #    }
        #}
      ENDSOURCE
      SOURCE #createDetailFromJournalAccountEntry
        #private void createDetailFromJournalAccountEntry(
        #    RefRecId                        _accountingEventId,
        #    SourceDocumentLineTmpJournalize _filteringSourceDocumentLineTmp)
        #{
        #    SubledgerJournalAccountEntry                subledgerJournalAccountEntry;
        #    AccountingEvent                             accountingEvent;
        #    AccountingDistribution                      accountingDistribution;
        #    SubledgerJournalAccountEntryDistribution    subledgerJournalAccountEntryDistribution;
        #    SubledgerJournalEntry                       subledgerJournalEntry;
        #    Ledger                                      ledger;
        #
        #    while select subledgerJournalAccountEntry
        #        join subledgerJournalEntry
        #            where subledgerJournalEntry.AccountingEvent == _accountingEventId &&
        #                    subledgerJournalEntry.RecId == subledgerJournalAccountEntry.SubledgerJournalEntry
        #        join firstonly accountingEvent
        #            where accountingEvent.RecId == subledgerJournalEntry.AccountingEvent
        #    {
        #        while select accountingDistribution
        #                where accountingDistribution.AccountingEvent == accountingEvent.RecId
        #                    || (accountingEvent.Type == AccountingEventType::Finalize && accountingDistribution.FinalizeAccountingEvent == accountingEvent.RecId)
        #            exists join subledgerJournalAccountEntryDistribution
        #                where subledgerJournalAccountEntryDistribution.AccountingDistribution == accountingDistribution.RecId &&
        #                        subledgerJournalAccountEntryDistribution.SubledgerJournalAccountEntry  == subledgerJournalAccountEntry.RecId
        #            exists join _filteringSourceDocumentLineTmp
        #                where _filteringSourceDocumentLineTmp.SourceDocumentLine == accountingDistribution.SourceDocumentLine
        #        {
        #            if (accountingDistribution)
        #            {
        #                ledger = Ledger::find(subledgerJournalEntry.Ledger);
        #                subledgerJournalAccountEntryTmpDetail.initFromLedger(ledger);
        #                subledgerJournalAccountEntryTmpDetail.initFromAccountingDistribution(accountingDistribution);
        #                subledgerJournalAccountEntryTmpDetail.initFromSubledgerJournalEntry(subledgerJournalEntry);
        #                subledgerJournalAccountEntryTmpDetail.initFromAccountingEvent(accountingEvent);
        #                subledgerJournalAccountEntryTmpDetail.initFromSubledgerJournalAccEntry(subledgerJournalAccountEntry);
        #                // <GEEU>
        #                this.insertingImportedSubledgerAccEntryToDet(subledgerJournalEntry, subledgerJournalAccountEntry, subledgerJournalAccountEntryTmpDetail);
        #                // </GEEU>
        #                subledgerJournalAccountEntryTmpDetail.insert();
        #            }
        #        }
        #    }
        #}
      ENDSOURCE
      SOURCE #createLineFilteringTmpTable
        #private SourceDocumentLineTmpJournalize createLineFilteringTmpTable(SourceDocumentLineList _inputSourceDocumentLineList)
        #{
        #    SourceDocumentLineTmpJournalize     filteringSourceDocumentLineTmp;
        #    SourceDocumentLine                  filteringSourceDocumentLine;
        #    SourceDocumentLine                  validSourceDocumentLine;
        #    SourceDocumentLineList              filteringSourceDocumentLineList;
        #    SourceDocumentLineListEnumerator    sourceDocumentLineEnumerator;
        #
        #    filteringSourceDocumentLineList = SourceDocumentLineList::construct();
        #    sourceDocumentLineEnumerator = _inputSourceDocumentLineList.getEnumerator();
        #
        #    while (sourceDocumentLineEnumerator.moveNext())
        #    {
        #        filteringSourceDocumentLine = sourceDocumentLineEnumerator.current();
        #
        #        select validSourceDocumentLine where validSourceDocumentLine.RecId == filteringSourceDocumentLine.RecId;
        #
        #        if (validSourceDocumentLine)
        #        {
        #            filteringSourceDocumentLineList.addEnd(validSourceDocumentLine);
        #            filteringSourceDocumentLineList.appendList(this.findChildrenList(validSourceDocumentLine));
        #        }
        #    }
        #
        #    if (!filteringSourceDocumentLineList.empty())
        #    {
        #        filteringSourceDocumentLineTmp.skipDataMethods(true);
        #        sourceDocumentLineEnumerator = filteringSourceDocumentLineList.getEnumerator();
        #
        #        while (sourceDocumentLineEnumerator.moveNext())
        #        {
        #            filteringSourceDocumentLine = sourceDocumentLineEnumerator.current();
        #
        #            filteringSourceDocumentLineTmp.SourceRelationType = filteringSourceDocumentLine.SourceRelationType;
        #            filteringSourceDocumentLineTmp.SourceDocumentLine = filteringSourceDocumentLine.RecId;
        #            filteringSourceDocumentLineTmp.insert();
        #        }
        #    }
        #
        #    return filteringSourceDocumentLineTmp;
        #}
      ENDSOURCE
      SOURCE #createSourceDocLineItemTmp
        #private void createSourceDocLineItemTmp(
        #    SourceDocument                  _sourceDocument,
        #    SourceDocumentLineItem          _sourceDocumentLineItem,
        #    SourceDocumentLineTmpJournalize _sourceDocumentLineTmpJournalize,
        #    AccountingPolicy                _accountingPolicy)
        #{
        #    CompanyInfoRecId                            lineLegalEntityRecId;
        #    Ledger                                      ledger;
        #    CurrentOperationsTax                        postingLayer;
        #    container                                   exchangeRatesContainer;
        #    container                                   reportingExchangeRatesContainer;
        #    SubledgerJournalRelievingMethod             typeSubledgerJournalRelievingMethod;
        #    SubledgerJournalRelievingMethod             policySubledgerJournalRelievingMethod;
        #    SubledgerJournalRelievingMethod             lineTmpSubledgerJournalRelievingMethod;
        #
        #    #define.ExchangeRate1(1)
        #    #define.ExchangeRate2(2)
        #
        #    //
        #    sourceDocumentType = _sourceDocument.parmSourceDocumentType();
        #    postingLayer = sourceDocumentType.parmPostingLayer();
        #    lineLegalEntityRecId = _sourceDocumentLineItem.parmLegalEntityRecId();
        #    ledger = Ledger::findByLegalEntity(lineLegalEntityRecId);
        #
        #    policySubledgerJournalRelievingMethod = _accountingPolicy.parmSubledgerJournalRelievingMethod();
        #    typeSubledgerJournalRelievingMethod = sourceDocumentType.parmSubledgerJournalRelievingMethod();
        #
        #    if (policySubledgerJournalRelievingMethod == SubledgerJournalRelievingMethod::NotApplicable)
        #    {
        #        lineTmpSubledgerJournalRelievingMethod = typeSubledgerJournalRelievingMethod;
        #    }
        #    else
        #    {
        #        lineTmpSubledgerJournalRelievingMethod = policySubledgerJournalRelievingMethod;
        #    }
        #
        #    sourceDocumentLineItemTmp.clear();
        #
        #    sourceDocumentLineItemTmp.LedgerName = ledger.Name;
        #    sourceDocumentLineItemTmp.PostingLayer = postingLayer;
        #    sourceDocumentLineItemTmp.LegalEntity = lineLegalEntityRecId;
        #    sourceDocumentLineItemTmp.Ledger = ledger.RecId;
        #    sourceDocumentLineItemTmp.AccountingCurrency = ledger.AccountingCurrency;
        #    sourceDocumentLineItemTmp.ReportingCurrency = ledger.ReportingCurrency;
        #    sourceDocumentLineItemTmp.SourceDocumentLine = _sourceDocumentLineTmpJournalize.SourceDocumentLine;
        #    sourceDocumentLineItemTmp.ReclassifyDistributionAmounts = sourceDocumentType.parmReclassifyDistributionAmounts();
        #    sourceDocumentLineItemTmp.DocumentsInterCompanyBusinessEvent = _sourceDocumentLineItem.documentsInterCompanyBusinessEvent();
        #    sourceDocumentLineItemTmp.CurrencyCode = _sourceDocumentLineItem.parmTransactionCurrencyCode();
        #    sourceDocumentLineItemTmp.ExchangeRateDate = _sourceDocumentLineTmpJournalize.ExchangeRateDate;
        #    sourceDocumentLineItemTmp.FiscalCalendarPeriod = this.getFiscalCalendarPeriod(_sourceDocumentLineTmpJournalize.AccountingDate,lineLegalEntityRecId);
        #    sourceDocumentLineItemTmp.SubledgerJournalRelievingMethod = lineTmpSubledgerJournalRelievingMethod;
        #    sourceDocumentLineItemTmp.SourceDocumentHeader = sourceDocumentHeaderRecId;
        #    sourceDocumentLineItemTmp.TypeEnumName = _sourceDocumentLineTmpJournalize.TypeEnumName;
        #
        #    sourceDocumentLineItemTmp.ExchangeRate1 = _sourceDocumentLineItem.parmExchangeRate1();
        #    sourceDocumentLineItemTmp.ExchangeRate2 = _sourceDocumentLineItem.parmExchangeRate2();
        #    if (!sourceDocumentLineItemTmp.ExchangeRate1)
        #    {
        #        exchangeRatesContainer = this.getExchangeRates(ledger.RecId, sourceDocumentLineItemTmp.CurrencyCode, sourceDocumentLineItemTmp.ExchangeRateDate);
        #        sourceDocumentLineItemTmp.ExchangeRate1 = conPeek(exchangeRatesContainer,#ExchangeRate1);
        #
        #        if (!sourceDocumentLineItemTmp.ExchangeRate2)
        #        {
        #            sourceDocumentLineItemTmp.ExchangeRate2 = conPeek(exchangeRatesContainer,#ExchangeRate2);
        #        }
        #    }
        #
        #    if (ledger.ReportingCurrency)
        #    {
        #        reportingExchangeRatesContainer = this.getExchangeRates(ledger.RecId,ledger.ReportingCurrency, sourceDocumentLineItemTmp.ExchangeRateDate);
        #        sourceDocumentLineItemTmp.ReportingExchangeRate1 = conPeek(reportingExchangeRatesContainer,#ExchangeRate1);
        #        sourceDocumentLineItemTmp.ReportingExchangeRate2 = conPeek(reportingExchangeRatesContainer,#ExchangeRate2);
        #    }
        #    sourceDocumentLineItemTmp.SubledgerJournalEntryType = sourceDocumentType.parmSubledgerJournalEntryType();
        #    sourceDocumentLineItemTmp.insert();
        #}
      ENDSOURCE
      SOURCE #createSourceDocumentLineRelieving
        #private void createSourceDocumentLineRelieving(SourceDocumentLineMatchingList _sourceDocumentLineMatchingList, SourceDocumentLineTmpRelation _sourceDocumentLineTmpRelation)
        #{
        #    SourceDocumentLineMatchingListEnumerator sourceDocumentLineMatchingListEnumerator;
        #    SourceDocumentLineMatching               sourceDocumentLineMatching;
        #
        #    if (_sourceDocumentLineMatchingList && _sourceDocumentLineMatchingList.elements() > 0)
        #    {
        #            sourceDocumentLineMatchingListEnumerator = _sourceDocumentLineMatchingList.getEnumerator();
        #
        #            while(sourceDocumentLineMatchingListEnumerator.moveNext())
        #            {
        #                sourceDocumentLineMatching = sourceDocumentLineMatchingListEnumerator.current();
        #
        #                if (sourceDocumentLineMatching)
        #                {
        #                    _sourceDocumentLineTmpRelation.clear();
        #                    _sourceDocumentLineTmpRelation.initFromSourceDocumentLineMatching(sourceDocumentLineMatching);
        #                    _sourceDocumentLineTmpRelation.insert();
        #                }
        #
        #            }
        #        }
        #    }
      ENDSOURCE
      SOURCE #createSummaryFromJournalAccountEntry
        #private void createSummaryFromJournalAccountEntry(
        #    RefRecId                                _accountingEventId,
        #    SubledgerJournalAccountEntryTmpSummary  _tmpSummary)
        #{
        #    SubledgerJournalAccountEntry                subledgerJournalAccountEntry;
        #    AccountingEvent                             accountingEvent;
        #    SubledgerJournalEntry                       subledgerJournalEntry;
        #    SubledgerJournalizerExtensionArgs           subledgerJournalizerExtensionArgs;
        #    Ledger                                      ledger;
        #    AccountingDate                              accountingDate;
        #
        #    subledgerJournalizerExtensionArgs = SubledgerJournalizerExtensionArgs::construct();
        #    accountingEvent = AccountingEvent::find(_accountingEventId);
        #    subledgerJournalizerExtensionArgs.parmAccountingEvent(accountingEvent);
        #    subledgerJournalizerExtensionArgs.parmSubledgerJournalAccEntryTmpSummary(_tmpSummary);
        #
        #    // <GEEU>
        #    this.insertingImportedSubledgerAccEntryToSum(subledgerJournalizerExtensionArgs);
        #    // </GEEU>
        #
        #    select firstonly RecId from _tmpSummary;
        #
        #    if (_tmpSummary.RecId == 0)
        #    {
        #        accountingDate = accountingEvent.AccountingDate;
        #
        #        insert_recordset _tmpSummary (LedgerDimension, PostingType, DebitCredit, TransactionCurrencyCode,
        #            TransactionCurrencyAmount, AccountingCurrencyAmount, ReportingCurrencyAmount, IsCorrection, HistoricalExchangeRateDate,
        #            SubledgerJournalEntryType, JournalNumber, AccountingEvent, LegalEntity, LedgerName,
        #            AccountingCurrency, ReportingCurrency, AccountingDate)
        #            select LedgerDimension, PostingType, Side, TransactionCurrency, TransactionCurrencyAmount, AccountingCurrencyAmount, ReportingCurrencyAmount, IsCorrection, HistoricalExchangeRateDate from subledgerJournalAccountEntry
        #                join Type, JournalNumber, AccountingEvent from subledgerJournalEntry
        #                    where subledgerJournalEntry.RecId == subledgerJournalAccountEntry.SubledgerJournalEntry
        #                        && subledgerJournalEntry.AccountingEvent == _accountingEventId
        #                join PrimaryForLegalEntity, Name, AccountingCurrency, ReportingCurrency, accountingDate from ledger
        #                    where ledger.RecId == subledgerJournalEntry.Ledger;
        #    }
        #}
      ENDSOURCE
      SOURCE #deleteRelievingInformation
        #private void deleteRelievingInformation(SourceDocumentHeaderRecId _sourceDocumentHeaderRecId)
        #{
        #    SourceDocumentLine  sourceDocumentLine;
        #
        #    delete_from sourceDocumentLineRelieving
        #        exists join sourceDocumentLine
        #            where sourceDocumentLine.SourceDocumentHeader == _sourceDocumentHeaderRecId
        #                && sourceDocumentLine.RecId == sourceDocumentLineRelieving.DependentSourceDocumentLine
        #                && sourceDocumentLine.AccountingStatus != SourceDocumentLineAccountingStatus::Completed
        #                && sourceDocumentLine.AccountingStatus != SourceDocumentLineAccountingStatus::Finalized
        #                && sourceDocumentLine.AccountingStatus != SourceDocumentLineAccountingStatus::Canceled;
        #}
      ENDSOURCE
      SOURCE #determineCorrectionAccountingApplicable
        #/// <summary>
        #/// Determines whether or not the accounting distribution journalize record should be marked as correction.
        #/// </summary>
        #/// <param name="_applyCorrectionAccountingRequired">
        #/// A boolean value indicating whether the source document is marked as a correction document.
        #/// </param>
        #/// <param name="_reversingAccountingDistributionExists">
        #/// A boolean value for whether accounting distributions with a role of reversing and a status of started exist.
        #/// </param>
        #/// <param name="_referenceAccountingDistribution">
        #/// The record ID of the reference accounting distribution.
        #/// </param>
        #/// <param name="_accountingReferenceRole">
        #/// The reference role of the accounting distribution.
        #/// </param>
        #/// <returns>
        #/// true if the accounting distribution journalize record should be marked as a correction; otherwise false.
        #/// </returns>
        #/// <remarks>
        #/// If no accounting distributions with a reversing role exist then the correction accounting will be applied to all subledger journal
        #/// account entries for the current processing accounting events.  Otherwise, correction accounting will only be applied to the reversal
        #/// entries for the current processing accounting events.
        #/// This is to support document scenarios where the correction is made on the same source document versus the correction is created on a different source document.
        #/// </remarks>
        #private boolean determineCorrectionAccountingApplicable(boolean _applyCorrectionAccountingRequired,
        #                                            boolean _reversingAccountingDistributionExists,
        #                                            RefRecId _referenceAccountingDistribution,
        #                                            AccountingDistributionReferenceRole _accountingReferenceRole)
        #{
        #    boolean isCorrectionAccountingApplicable;
        #
        #    if (_applyCorrectionAccountingRequired)
        #    {
        #        if (_reversingAccountingDistributionExists)
        #        {
        #            if ((_referenceAccountingDistribution != 0) && _accountingReferenceRole == AccountingDistributionReferenceRole::Reversing)
        #            {
        #                isCorrectionAccountingApplicable = true;
        #            }
        #        }
        #        else
        #        {
        #            isCorrectionAccountingApplicable = true;
        #        }
        #    }
        #
        #    return isCorrectionAccountingApplicable;
        #}
      ENDSOURCE
      SOURCE #fillPreviewTmpSummaryWithRounding
        #private void fillPreviewTmpSummaryWithRounding(
        #    SubledgerJournalAccountEntryTmpDetail  _tmpDetail,
        #    SubledgerJournalAccountEntryTmpSummary _tmpSummary)
        #{
        #    insert_recordset _tmpSummary (
        #        LedgerDimension, PostingType, DebitCredit, TransferPolicy, IsCorrection, LegalEntity, AccountingDate, TransactionCurrencyCode, AccountingEvent, SubledgerJournalEntry,
        #        ExchangeRate1, ReportingExchangeRate1, TransactionCurrencyAmount, AccountingCurrencyAmount, ReportingCurrencyAmount,
        #        AccountingCurrencyAmountUnrounded,
        #        ReportingCurrencyAmountUnrounded,
        #        PostingLayer, LedgerName, AccountingCurrency, ReportingCurrency, JournalNumber, SubledgerJournalEntryType,
        #        ExchangeRateDate, HistoricalExchangeRateDate, ExchangeRate2, ReportingExchangeRate2,
        #        Ledger, FiscalCalendarPeriod, RoundingLevel)
        #    select
        #        LedgerDimension, PostingType, DebitCredit, TransferPolicy, IsCorrection, LegalEntity, AccountingDate, TransactionCurrencyCode, AccountingEvent, SubledgerJournalEntry,
        #        ExchangeRate1, ReportingExchangeRate1, sum(TransactionCurrencyAmount), sum(AccountingCurrencyAmount), sum(ReportingCurrencyAmount),
        #        sum(AccountingCurrencyAmountUnrounded),
        #        sum(ReportingCurrencyAmountUnrounded),
        #        PostingLayer, LedgerName, AccountingCurrency, ReportingCurrency, JournalNumber, SubledgerJournalEntryType,
        #        ExchangeRateDate, HistoricalExchangeRateDate, ExchangeRate2, ReportingExchangeRate2,
        #        Ledger, FiscalCalendarPeriod, RoundingLevel
        #        from _tmpDetail
        #        group by
        #            LedgerDimension, PostingType, DebitCredit, TransferPolicy, IsCorrection, LegalEntity, AccountingDate, TransactionCurrencyCode,
        #            SubledgerJournalEntry, AccountingEvent, ExchangeRate1, ReportingExchangeRate1, FiscalCalendarPeriod, PostingLayer,
        #            LedgerName, AccountingCurrency, ReportingCurrency, JournalNumber, SubledgerJournalEntryType,
        #            ExchangeRateDate, HistoricalExchangeRateDate, ExchangeRate2, ReportingExchangeRate2,
        #            Ledger, RoundingLevel
        #        where _tmpDetail.AccountingEvent == 0;
        #}
      ENDSOURCE
      SOURCE #filterSourceDocumentLineItem
        #private void filterSourceDocumentLineItem(
        #    SourceDocumentLineTmpJournalize _filteringSourceDocumentLineTmp)
        #{
        #    if (_filteringSourceDocumentLineTmp)
        #    {
        #        delete_from sourceDocumentLineItemTmp
        #        notexists join _filteringSourceDocumentLineTmp
        #            where _filteringSourceDocumentLineTmp.SourceDocumentLine == sourceDocumentLineItemTmp.SourceDocumentLine;
        #    }
        #}
      ENDSOURCE
      SOURCE #finalizedEventHandler
        #/// <summary>
        #/// Serves as a finalized event handler delegate.
        #/// </summary>
        #/// <param name="_sourceDocumentHeader">
        #/// The source document header that is to be finalized.
        #/// </param>
        #delegate void finalizedEventHandler(SourceDocumentHeader _sourceDocumentHeader)
        #{
        #}
      ENDSOURCE
      SOURCE #finalizingEventHandler
        #/// <summary>
        #/// Serves as a finalizing event handler delegate.
        #/// </summary>
        #/// <param name="_sourceDocumentHeader">
        #/// The source document header that is to be finalized.
        #/// </param>
        #delegate void finalizingEventHandler(SourceDocumentHeader _sourceDocumentHeader)
        #{
        #}
      ENDSOURCE
      SOURCE #findCachedAccountingDate
        #private boolean findCachedAccountingDate(LedgerRecId _ledgerRecId, TransDate _transDate, FiscalPeriodType _periodType)
        #{
        #    boolean found;
        #    found = validAccountingDateSet.in([_ledgerRecId, _transDate, _periodType]);
        #    return found;
        #}
      ENDSOURCE
      SOURCE #findChildrenList
        #private SourceDocumentLineList findChildrenList(SourceDocumentLine _validSourceDocumentLine)
        #{
        #    SourceDocumentLine      childSourceDocumentLine;
        #    SourceDocumentLineList  filteringSourceDocumentLineList;
        #
        #    filteringSourceDocumentLineList = SourceDocumentLineList::construct();
        #
        #    while select childSourceDocumentLine
        #        where childSourceDocumentLine.ParentSourceDocumentLine == _validSourceDocumentLine.RecId
        #    {
        #        filteringSourceDocumentLineList.addEnd(childSourceDocumentLine);
        #        filteringSourceDocumentLineList.appendList(this.findChildrenList(childSourceDocumentLine));
        #    }
        #
        #    return filteringSourceDocumentLineList;
        #}
      ENDSOURCE
      SOURCE #generateInterunitBalancingEntries
        #private LedgerTmpInterunitBalancerAccountEntry generateInterunitBalancingEntries(NoYes _isReversal)
        #{
        #    LedgerTmpInterunitBalancerAccountEntry      interUnitBalancingEntries;
        #    SubledgerJournalInterunitBalancer           balancer;
        #    AmountMST                                   debitAmount;
        #    AmountMST                                   creditAmount;
        #
        #    select sum(AccountingCurrencyAmount) from subledgerJournalAccountEntryTmpDetail
        #        where subledgerJournalAccountEntryTmpDetail.DebitCredit == DebitCredit::Debit
        #            && subledgerJournalAccountEntryTmpDetail.IsReversal == _isReversal
        #            && subledgerJournalAccountEntryTmpDetail.IsRoundingAdjustment == NoYes::No;
        #    debitAmount = subledgerJournalAccountEntryTmpDetail.AccountingCurrencyAmount;
        #
        #    select sum(AccountingCurrencyAmount) from subledgerJournalAccountEntryTmpDetail
        #        where subledgerJournalAccountEntryTmpDetail.DebitCredit == DebitCredit::Credit
        #            && subledgerJournalAccountEntryTmpDetail.IsReversal == _isReversal
        #            && subledgerJournalAccountEntryTmpDetail.IsRoundingAdjustment == NoYes::No;
        #    creditAmount = subledgerJournalAccountEntryTmpDetail.AccountingCurrencyAmount;
        #
        #    // create balancing entries - but not when the entry is unbalanced in DR/CR overall to begin with
        #    if((creditAmount == -debitAmount))
        #    {
        #        balancer = SubledgerJournalInterunitBalancer::construct();
        #        balancer.addFromRecordset(subledgerJournalAccountEntryTmpDetail, _isReversal);
        #        interUnitBalancingEntries = balancer.performBalancing();
        #    }
        #
        #    return interUnitBalancingEntries;
        #}
      ENDSOURCE
      SOURCE #getExchangeRates
        #private container getExchangeRates(LedgerRecId _ledgerRecId, CurrencyCode _currencyCode, AccountingDate _exchangeRateDate)
        #{
        #    ExchangeRateHelper          exchangeRateHelper;
        #    container                   exchangeRatesContainer;
        #
        #
        #    if(exchangeRates.exists([_ledgerRecId, _currencyCode, _exchangeRateDate]))
        #    {
        #        exchangeRatesContainer = exchangeRates.lookup([_ledgerRecId, _currencyCode, _exchangeRateDate]);
        #    }
        #
        #    if (!exchangeRatesContainer)
        #    {
        #        exchangeRateHelper = ExchangeRateHelper::newExchangeDate(_ledgerRecId, _currencyCode, _exchangeRateDate);
        #        exchangeRates.insert([_ledgerRecId, _currencyCode, _exchangeRateDate], [exchangeRateHelper.getExchangeRate1(), exchangeRateHelper.getExchangeRate2()]);
        #        exchangeRatesContainer = exchangeRates.lookup([_ledgerRecId, _currencyCode, _exchangeRateDate]);
        #    }
        #
        #    return exchangeRatesContainer;
        #}
      ENDSOURCE
      SOURCE #getFiscalCalendarPeriod
        #private FiscalCalendarPeriodRecId getFiscalCalendarPeriod(AccountingDate _accountingDate, CompanyInfoRecId _legalEntity)
        #{
        #    FiscalCalendarPeriodRecId           fiscalCalendarPeriodRecId;
        #    SubledgerJournalizerExtensionArgs   subledgerJournalizerExtensionArgs;
        #
        #    if (fiscalCalendarPeriods.exists([_accountingDate,_legalEntity]))
        #    {
        #        fiscalCalendarPeriodRecId = fiscalCalendarPeriods.lookup([_accountingDate,_legalEntity]);
        #    }
        #
        #    if (fiscalCalendarPeriodRecId == 0)
        #    {
        #        subledgerJournalizerExtensionArgs = SubledgerJournalizerExtensionArgs::construct();
        #        this.gettingFiscalCalendarPeriod(_accountingDate, _legalEntity, subledgerJournalizerExtensionArgs);
        #        fiscalCalendarPeriodRecId = subledgerJournalizerExtensionArgs.parmFiscalCalendarPeriodRecId();
        #
        #        if (fiscalCalendarPeriodRecId == 0)
        #        {
        #            fiscalCalendarPeriodRecId = FiscalCalendars::findPeriodByPeriodCodeDate(Ledger::fiscalCalendar(_legalEntity), _accountingDate, FiscalPeriodType::Operating).RecId;
        #        }
        #
        #        fiscalCalendarPeriods.insert([_accountingDate,_legalEntity],fiscalCalendarPeriodRecId);
        #    }
        #
        #    return fiscalCalendarPeriodRecId;
        #}
      ENDSOURCE
      SOURCE #getGainLossLedgerDimension
        #private LedgerDimensionAccount getGainLossLedgerDimension(
        #        LedgerRecId                         _ledgerRecId,
        #        CurrencyCode                        _transactionCurrency,
        #        CurrencyGainLossAccountType         _currencyGainLossAccountType,
        #        SourceDocumentLineItem              _sourceDocumentLineItem)
        #{
        #    LedgerDimensionDefaultAccount                   ledgerDimensionDefaultAccount;
        #    LedgerDimensionAccount                          ledgerDimension;
        #    Object                                          object;
        #    SourceDocumentIDataProvider                     iDataProvider;
        #    LedgerDimensionAccount                          defaultLedgerDimension;
        #    DimensionDefault                                defaultDimension;
        #
        #    if (gainLossLedgerDimensions.exists([_ledgerRecId, _transactionCurrency, _currencyGainLossAccountType]))
        #    {
        #        ledgerDimension = gainLossLedgerDimensions.lookup([_ledgerRecId, _transactionCurrency, _currencyGainLossAccountType]);
        #    }
        #    else
        #    {
        #        ledgerDimensionDefaultAccount = CurrencyLedgerGainLossAccount::ledgerDimension
        #                                            (_ledgerRecId,
        #                                             _transactionCurrency,
        #                                             _currencyGainLossAccountType);
        #        if (ledgerDimensionDefaultAccount)
        #        {
        #            defaultLedgerDimension = DimensionStorage::getLedgerDefaultAccountFromLedgerDim(ledgerDimensionDefaultAccount);
        #
        #            object = _sourceDocumentLineItem.parmSourceDocument();
        #            if (object != null &&
        #                object is SourceDocumentIDataProvider)
        #            {
        #                iDataProvider = object as SourceDocumentIDataProvider;
        #                defaultDimension = iDataProvider.parmDefaultDimension();
        #            }
        #            ledgerDimension = DimensionDefaultingService::serviceCreateLedgerDimension(defaultLedgerDimension, defaultDimension);
        #            gainLossLedgerDimensions.insert([_ledgerRecId, _transactionCurrency, _currencyGainLossAccountType], ledgerDimension);
        #        }
        #    }
        #    return ledgerDimension;
        #}
      ENDSOURCE
      SOURCE #getLedgerDimensionOfDueToDueFrom
        #private LedgerDimensionAccount getLedgerDimensionOfDueToDueFrom(
        #    CompanyInfoRecId _legalEntityForDueToDueFromCreated,
        #    CompanyInfoRecId _legalEntityFromDueToDueFromCreated,
        #    LedgerDimensionAccount _ledgerDimensionForDimensionSource,
        #    Amount _transactionAmount)
        #{
        #    #define.LedgerAccountDefaultingPosition(2)
        #
        #    List dimensionSources = new List(Types::Class);
        #    LedgerDimensionAccount  ledgerDimension;
        #    DataAreaId dataAreaForDueToDueFromCreated = CompanyInfo::getDataArea(_legalEntityForDueToDueFromCreated);
        #    DataAreaId dataAreaFromDueToDueFromCreated = CompanyInfo::getDataArea(_legalEntityFromDueToDueFromCreated);
        #
        #    changecompany(dataAreaFromDueToDueFromCreated)
        #    {
        #        // get dimension sources.
        #        dimensionSources.addEnd(DimensionDefaultingEngine::getLedgerDimensionSpecifiers(_ledgerDimensionForDimensionSource));
        #
        #        // get ledger dimension for dueTo/dueFrom
        #        ledgerDimension = DimensionDefaultingEngine::createLedgerDimension(
        #            LedgerInterCompany::findLedgerDimensionWithAmount(_transactionAmount, dataAreaForDueToDueFromCreated),
        #            dimensionSources, #LedgerAccountDefaultingPosition);
        #    }
        #
        #    return ledgerDimension;
        #}
      ENDSOURCE
      SOURCE #getReferenceDistributionExchangeRates
        #private container getReferenceDistributionExchangeRates(AccountingDistributionTmpJournalize _accountingDistributionTmpJournalize)
        #{
        #    container exchangeRatesContainer = conNull();
        #
        #    if (referenceDistributionExchangeRates.exists(_accountingDistributionTmpJournalize.ReferenceDistribution))
        #    {
        #        exchangeRatesContainer = referenceDistributionExchangeRates.lookup(_accountingDistributionTmpJournalize.ReferenceDistribution);
        #    }
        #
        #    return exchangeRatesContainer;
        #}
      ENDSOURCE
      SOURCE #getSourceDocumentRelation
        #private SourceDocumentIRelation getSourceDocumentRelation()
        #{
        #    SourceDocumentRelationFactory       sourceDocumentRelationFactory;
        #    SourceDocumentIRelation             sourceDocumentIRelation;
        #
        #    sourceDocumentRelationFactory = SourceDocumentRelationFactory::newFromSourceDocument(sourceDocument);
        #    sourceDocumentIRelation = sourceDocumentRelationFactory.getSourceDocumentRelation();
        #
        #    return sourceDocumentIRelation;
        #}
      ENDSOURCE
      SOURCE #getSubledgerJournalAccountEntryTmp
        #public SubledgerJournalAccountEntryTmpDetail getSubledgerJournalAccountEntryTmp (SourceDocument _sourceDocument)
        #{
        #
        #    AccountingEvent                 accountingEvent;
        #
        #
        #    //load basic information into temp tables.
        #    this.loadsourceDocumentLineItemTmp(_sourceDocument);
        #    this.loadaccountingDistributionTmp(_sourceDocument);
        #
        #    //get Accounting Events that are not yet journalized
        #    while select forupdate accountingEvent
        #        where accountingEvent.State == AccountingEventState::Started &&
        #              accountingEvent.SourceDocumentHeader == sourceDocumentHeaderRecId
        #    {
        #        this.loadSubledgerJournalTmpDetail(accountingEvent);
        #    }
        #
        #    return subledgerJournalAccountEntryTmpDetail;
        #}
      ENDSOURCE
      SOURCE #getSubledgerJournalAcctEntryTmpSummary
        #public void getSubledgerJournalAcctEntryTmpSummary(
        #    SourceDocument          _sourceDocument,
        #    SubledgerJournalAccountEntryTmpSummary _tmpSummary,
        #    SourceDocumentLineList  _inputSourceDocumentLineList = null,
        #    AccountingEventRecId    _accountingEventRecId = 0)
        #{
        #    AccountingEvent                         accountingEvent;
        #    SubledgerJournalAccountEntryTmpSummary  subledgerJournalAccountEntryTmpSummary;
        #    SourceDocumentLineTmpJournalize         filteringSourceDocumentLineTmp;
        #
        #    subledgerJournalAccountEntryTmpSummary = _tmpSummary;
        #
        #    // wrap in transaction block to handle preview case
        #    // transaction is needed to handle updating to SourceDocumentLineRelieving tables
        #    ttsbegin;
        #
        #    if (_inputSourceDocumentLineList)
        #    {
        #        filteringSourceDocumentLineTmp = this.createLineFilteringTmpTable(_inputSourceDocumentLineList);
        #    }
        #
        #    // Process the accounting distributions with no accounting event (accounting event == 0)
        #    // It is for the preview of subledger journal accounting entry prior to posting.
        #    if (_accountingEventRecId == 0)
        #    {
        #        //load information into temp tables
        #        isPreviewMode = true;
        #        this.previewLoadSourceDocLineItemTmp(_sourceDocument);
        #        this.filterSourceDocumentLineItem(filteringSourceDocumentLineTmp);
        #        this.loadaccountingDistributionTmp(_sourceDocument);
        #        this.loadSubledgerJournalTmpDetail(accountingEvent);
        #        this.loadSubledgerJourTmpDetailWithRelieving(accountingEvent);
        #
        #        if (this.canPerformSummaryRoundingAdjustment(_sourceDocument))
        #        {
        #            this.previewSummarizeSJAEWithRounding(_sourceDocument, subledgerJournalAccountEntryTmpDetail, _tmpSummary);
        #        }
        #        else
        #        {
        #            this.previewSummarizeJournalAccEntryDetail(subledgerJournalAccountEntryTmpDetail, _tmpSummary);
        #        }
        #
        #        this.deleteRelievingInformation(sourceDocumentHeaderRecId);
        #    }
        #    else
        #    {
        #        //<GEEU>
        #        this.startingLoadAccDistrTmpForFinalization();
        #        //</GEEU>
        #
        #        if (filteringSourceDocumentLineTmp)
        #        {
        #            delete_from subledgerJournalAccountEntryTmpDetail;
        #            select RecId, State from accountingEvent where accountingEvent.RecId == _accountingEventRecId;
        #
        #            this.createDetailFromJournalAccountEntry(accountingEvent.RecId, filteringSourceDocumentLineTmp);
        #            this.summarizeJournalAccountEntryDetail(subledgerJournalAccountEntryTmpDetail, _tmpSummary, accountingEvent.State);
        #        }
        #        else
        #        {
        #            this.createSummaryFromJournalAccountEntry(_accountingEventRecId, _tmpSummary);
        #        }
        #    }
        #
        #    ttscommit;
        #}
      ENDSOURCE
      SOURCE #gettingFiscalCalendarPeriod
        #/// <summary>
        #/// An event handler delegate for Fiscal calendar period.
        #/// </summary>
        #/// <param name="_accountingDate">
        #/// An accounting date.
        #/// </param>
        #/// <param name="_legalEntity">
        #/// A record Id of legal entity.
        #/// </param>
        #/// <param name="_subledgerJournalizerExtensionArgs">
        #/// A class to hold fiscal calendar period for delegation.
        #/// </param>
        #delegate void gettingFiscalCalendarPeriod(
        #    AccountingDate   _accountingDate,
        #    CompanyInfoRecId _legalEntity,
        #    SubledgerJournalizerExtensionArgs _subledgerJournalizerExtensionArgs)
        #{
        #}
      ENDSOURCE
      SOURCE #getVoucher
        #private Voucher getVoucher(SourceDocument _sourceDocument, AccountingEvent _accountingEvent, Map _legalEntityVouchers, Map _finalizeVouchers, DataAreaId _dataAreaId)
        #{
        #    SourceDocumentIFinalize sourceDocumentIFinalize;
        #    SourceDocumentIYearEnd  sourceDocumentIYearEnd;
        #    Voucher                 voucher;
        #
        #    if (_accountingEvent.Type == AccountingEventType::PeriodClose && sourceDocument is SourceDocumentIYearEnd)
        #    {
        #        sourceDocumentIYearEnd = _sourceDocument as SourceDocumentIYearEnd;
        #        voucher = sourceDocumentIYearEnd.parmPeriodCloseVoucher();
        #    }
        #    else if (_accountingEvent.Type == AccountingEventType::PeriodOpen && sourceDocument is SourceDocumentIYearEnd)
        #    {
        #        sourceDocumentIYearEnd = _sourceDocument as SourceDocumentIYearEnd;
        #        voucher = sourceDocumentIYearEnd.parmPeriodOpenVoucher();
        #    }
        #    else if (_accountingEvent.Type == AccountingEventType::Finalize && _sourceDocument is SourceDocumentIFinalize)
        #    {
        #        sourceDocumentIFinalize = _sourceDocument as SourceDocumentIFinalize;
        #        if (_finalizeVouchers.exists(_dataAreaId))
        #        {
        #            voucher = _finalizeVouchers.lookup(_dataAreaId);
        #        }
        #        else
        #        {
        #            voucher = sourceDocumentIFinalize.parmFinalizedVoucher(_dataAreaId);
        #            _finalizeVouchers.insert(_dataAreaId, voucher);
        #        }
        #    }
        #    else
        #    {
        #        if (_legalEntityVouchers.exists(_dataAreaId))
        #        {
        #            voucher = _legalEntityVouchers.lookup(_dataAreaId);
        #        }
        #        else
        #        {
        #            if (caller != null && caller.parmVoucher() != '')
        #            {
        #                voucher = caller.parmVoucher();
        #            }
        #            else
        #            {
        #                if (_sourceDocument is SourceDocumentILineVoucher)
        #                {
        #                    voucher = _sourceDocument.parmCurrentLineVoucher(_accountingEvent);
        #                }
        #                else
        #                {
        #                    voucher = _sourceDocument.parmCurrentVoucher(_dataAreaId);
        #                }
        #            }
        #
        #            _legalEntityVouchers.insert(_dataAreaId, voucher);
        #        }
        #    }
        #
        #    return voucher;
        #}
      ENDSOURCE
      SOURCE #initialize
        #/// <summary>
        #/// Initializes the subledger journalizer.
        #/// </summary>
        #/// <param name="_sourceDocument">
        #/// A reference to an instance of the <c>SourceDocument</c> class.
        #/// </param>
        #/// <param name="_periodClosingFiscalCalendarPeriodRecId">
        #/// The identifier for the <c>FiscalCalendarPeriod</c> that should be used for period close accounting
        #/// event; optional.
        #/// </param>
        #/// <param name="_caller">
        #/// The caller class object for the <c>SubledgerJournalizer</c>; optional.
        #/// </param>
        #protected void initialize(SourceDocument _sourceDocument, FiscalCalendarPeriodRecId _periodClosingFiscalCalendarPeriodRecId = 0, SourceDocumentProcessorCaller _caller = null)
        #{
        #    Debug::assert(_sourceDocument != null);
        #
        #    sourceDocument = _sourceDocument;
        #    isPreviewMode = false;
        #    caller = _caller;
        #    //load basic information into temp tables.
        #
        #    // Init extension list
        #    subledgerJournalizerExtensionList = SubledgerJournalizerExtensionList::newFromSubledgerJournalizer(this);
        #
        #    validAccountingDateSet = new Set(Types::Container);
        #    fiscalCalendarPeriods = new Map(Types::Container, Types::Int64);
        #    exchangeRates   = new Map(Types::Container, Types::Container);
        #    referenceDistributionExchangeRates = new Map(Types::Int64, Types::Container);
        #    gainLossLedgerDimensions = new Map(Types::Container, Types::Int64);
        #    relieveingRequiredSet = new Set(Types::Int64);
        #    dimensionValuesUsedForSummaryAccount = LedgerParameters::dimensionValuesUsedForSummaryAccount();
        #
        #    sourceDocumentLineItemMap = new Map(Types::Int64, Types::Class);
        #    accountingPolicyMap = new Map(Types::Int64, Types::Class);
        #    sourceDocumentHeaderRecId = _sourceDocument.parmSourceDocumentHeader().RecId;
        #
        #    periodClosingFiscalCalendarPeriodRecId = _periodClosingFiscalCalendarPeriodRecId;
        #
        #    sourceDocumentLineItemImplMap = new Map(Types::Int64, Types::Record);
        #    subledgerJournalEntries = new Map(Types::Container, Types::Record);
        #}
      ENDSOURCE
      SOURCE #insertAccDistTmpForRoundingRelievingDiff
        #/// <summary>
        #/// Inserts an <c>AccountingDistributionTmp</c> record for the rounding relieving difference amount.
        #/// </summary>
        #/// <param name="_accountingCurrencyAmount">
        #/// The rounding difference accounting currency amount.
        #/// </param>
        #/// <param name="_reportingCurrencyAmount">
        #/// The rounding difference reporting currency amount.
        #/// </param>
        #/// <param name="_accountingCurrencyRoundingDiffAmountSide">
        #/// The amount side for the accounting rounding difference.
        #/// </param>
        #/// <param name="_reportingCurrencyRoundingDiffAmountSide">
        #/// The amount side for the reporting rounding difference.
        #/// </param>
        #protected void insertAccDistTmpForRoundingRelievingDiff(
        #    AmountMST _accountingCurrencyAmount,
        #    AmountMST _reportingCurrencyAmount,
        #    DebitCredit _accountingCurrencyRoundingDiffAmountSide,
        #    DebitCredit _reportingCurrencyRoundingDiffAmountSide)
        #{
        #    AccountingDistributionTmp accountingDistributionTmpCopy;
        #
        #    accountingDistributionTmpCopy.data(accountingDistributionTmp);
        #    accountingDistributionTmp.clear();
        #    accountingDistributionTmp.initFromLedger(Ledger::find(accountingDistributionTmpCopy.Ledger));
        #    accountingDistributionTmp.AccountingDate = accountingDistributionTmpCopy.AccountingDate;
        #
        #    accountingDistributionTmp.AccountingDistribution = accountingDistributionTmpCopy.AccountingDistribution;
        #    accountingDistributionTmp.AccountingEvent = accountingDistributionTmpCopy.AccountingEvent;
        #    accountingDistributionTmp.ExchangeRate1 = 0;
        #    accountingDistributionTmp.ExchangeRate2 = 0;
        #    accountingDistributionTmp.FiscalCalendarPeriod = accountingDistributionTmpCopy.FiscalCalendarPeriod;
        #    accountingDistributionTmp.IsRelieving = true;
        #    accountingDistributionTmp.LedgerDimension = accountingDistributionTmpCopy.LedgerDimension;
        #    accountingDistributionTmp.ParentDistribution = accountingDistributionTmpCopy.ParentDistribution;
        #
        #    accountingDistributionTmp.ReferenceRole = accountingDistributionTmpCopy.ReferenceRole;
        #    accountingDistributionTmp.RelievingSubledgerJournalEntryType = accountingDistributionTmpCopy.RelievingSubledgerJournalEntryType;
        #    accountingDistributionTmp.ReportingCurrency = accountingDistributionTmpCopy.ReportingCurrency;
        #    accountingDistributionTmp.ReportingExchangeRate1 = 0;
        #    accountingDistributionTmp.ReportingExchangeRate2 = 0;
        #    accountingDistributionTmp.SourceDocumentLine = accountingDistributionTmpCopy.SourceDocumentLine;
        #    accountingDistributionTmp.SourceDocLineLegalEntity = accountingDistributionTmpCopy.SourceDocLineLegalEntity;
        #    accountingDistributionTmp.SubledgerJournalEntryType = accountingDistributionTmpCopy.SubledgerJournalEntryType;
        #    accountingDistributionTmp.TransactionCurrency = accountingDistributionTmpCopy.TransactionCurrency;
        #    accountingDistributionTmp.TransactionCurrencyAmount = 0;
        #    accountingDistributionTmp.TransferPolicy = accountingDistributionTmpCopy.TransferPolicy;
        #
        #    if (_accountingCurrencyAmount)
        #    {
        #        accountingDistributionTmp.AccountingCurrencyAmount = _accountingCurrencyAmount;
        #        accountingDistributionTmp.AmountSign = _accountingCurrencyRoundingDiffAmountSide;
        #        accountingDistributionTmp.PostingType = LedgerPostingType::MSTDiff;
        #        accountingDistributionTmp.ReportingCurrencyAmount = 0;
        #        accountingDistributionTmp.applyFixedDimension();
        #        accountingDistributionTmp.insert();
        #    }
        #
        #    if (_reportingCurrencyAmount)
        #    {
        #        accountingDistributionTmp.AccountingCurrencyAmount = 0;
        #        accountingDistributionTmp.AmountSign = _reportingCurrencyRoundingDiffAmountSide;
        #        accountingDistributionTmp.PostingType = LedgerPostingType::MSTDiffSecond;
        #        accountingDistributionTmp.ReportingCurrencyAmount = _reportingCurrencyAmount;
        #        accountingDistributionTmp.applyFixedDimension();
        #        accountingDistributionTmp.insert();
        #    }
        #
        #    accountingDistributionTmp.clear();
        #    accountingDistributionTmp.data(accountingDistributionTmpCopy);
        #}
      ENDSOURCE
      SOURCE #insertedSubledgerJourAccEntryDistr
        #/// <summary>
        #/// Inserts a record into the <c>SubledgerJournalAccountEntryDistribution</c> table from a temporary
        #/// table.
        #/// </summary>
        #/// <param name="_subledgerJournalAccountEntryTmpDetail">
        #/// The source temporary table.
        #/// </param>
        #/// <param name="_accountingEvent">
        #/// An accounting event that is being processed.
        #/// </param>
        #delegate void insertedSubledgerJourAccEntryDistr(SubledgerJournalAccountEntryTmpDetail _subledgerJournalAccountEntryTmpDetail, AccountingEvent _accountingEvent)
        #{
        #}
      ENDSOURCE
      SOURCE #insertedSubledgerJournalAccountEntry
        #/// <summary>
        #/// Inserts a record into the <c>SubledgerJournalAccountEntry</c> table from a temporary table.
        #/// </summary>
        #/// <param name="_subledgerJournalAccountEntryTmpDetail">
        #/// The source temporary table.
        #/// </param>
        #delegate void insertedSubledgerJournalAccountEntry(SubledgerJournalAccountEntryTmpDetail _subledgerJournalAccountEntryTmpDetail)
        #{
        #}
      ENDSOURCE
      SOURCE #insertingDistributedTmp
        #/// <summary>
        #/// Inserts a <c>AccountingDistributionTmp</c> record.
        #/// </summary>
        #/// <param name="_record">
        #/// The record that is being inserted.
        #/// </param>
        #delegate void insertingDistributedTmp(AccountingDistributionTmp _record)
        #{
        #}
      ENDSOURCE
      SOURCE #insertingImportedSubledgerAccEntry
        #/// <summary>
        #/// Imports a <c>SubledgerJournalAccountEntry</c> record that is being inserted into the
        #/// <c>AccountingDistributionTmp</c> table.
        #/// </summary>
        #/// <param name="_subledgerJournalEntry">
        #/// A <c>SubledgerJournalEntry</c> record that is being imported.
        #/// </param>
        #/// <param name="_subledgerJournalAccountEntry">
        #/// The <c>SubledgerJournalAccountEntry</c> record that is being imported.
        #/// </param>
        #/// <param name="_accountingDistributionTmp">
        #/// A <c>AccountingDistributionTmp</c> record that is being inserted.
        #/// </param>
        #/// <param name="_recordInsertList">
        #/// A record list in which the record is being inserted.
        #/// </param>
        #delegate void insertingImportedSubledgerAccEntry(SubledgerJournalEntry _subledgerJournalEntry, SubledgerJournalAccountEntry _subledgerJournalAccountEntry, AccountingDistributionTmp _accountingDistributionTmp, RecordInsertList _recordInsertList)
        #{
        #}
      ENDSOURCE
      SOURCE #insertingImportedSubledgerAccEntryToDet
        #/// <summary>
        #/// Imports a <c>SubledgerJournalAccountEntry</c> record that is being inserted into the
        #/// <c>SubledgerJournalAccountEntryTmpDetail</c> table.
        #/// </summary>
        #/// <param name="_subledgerJournalEntry">
        #/// A <c>SublegerJournalEntry</c> record that is being imported.
        #/// </param>
        #/// <param name="_subledgerJournalAccountEntry">
        #/// The <c>SubledgerJournalAccountEntry</c> record that is being imported.
        #/// </param>
        #/// <param name="_tmpDetail">
        #/// The <c>SubledgerJournalAccountEntryTmpDetail</c> record that is being inserted.
        #/// </param>
        #delegate void insertingImportedSubledgerAccEntryToDet(SubledgerJournalEntry _subledgerJournalEntry, SubledgerJournalAccountEntry _subledgerJournalAccountEntry, SubledgerJournalAccountEntryTmpDetail _tmpDetail)
        #{
        #}
      ENDSOURCE
      SOURCE #insertingImportedSubledgerAccEntryToSum
        #/// <summary>
        #/// Imports a <c>SubledgerJournalAccountEntry</c> record that is being inserted into the
        #/// <c>SubledgerJournalAccountEntryTmpSummary</c> table.
        #/// </summary>
        #/// <param name="_subledgerJournalizerExtensionArgs">
        #/// An instance of <c>SubledgerJournalizerExtensionArgs</c> class.
        #/// </param>
        #delegate void insertingImportedSubledgerAccEntryToSum(SubledgerJournalizerExtensionArgs _subledgerJournalizerExtensionArgs)
        #{
        #}
      ENDSOURCE
      SOURCE #insertingJournalizingTmp
        #/// <summary>
        #/// Fires an event before a journalizing transaction is inserted.
        #/// </summary>
        #/// <param name="_record">
        #/// The journalizing transaction to be inserted.
        #/// </param>
        #/// <remarks>
        #/// The handler can change the transaction values.
        #/// </remarks>
        #delegate void insertingJournalizingTmp(AccountingDistributionTmp _record)
        #{
        #}
      ENDSOURCE
      SOURCE #insertInterunitBalancingEntries
        #private void insertInterunitBalancingEntries(LedgerTmpInterunitBalancerAccountEntry _interUnitBalancingEntries)
        #{
        #    SubledgerJournalAccountEntryTmpDetail       localsubledgerJournalAccountEntryTmpDetail;
        #
        #    select firstonly RecId
        #        from _interUnitBalancingEntries;
        #
        #    if(_interUnitBalancingEntries != null)
        #    {
        #        localsubledgerJournalAccountEntryTmpDetail.linkPhysicalTableInstance(subledgerJournalAccountEntryTmpDetail);
        #
        #        insert_recordset subledgerJournalAccountEntryTmpDetail(AccountingDistribution,
        #                                                                   // <GEEU>
        #                                                                   SourceAccountingDistributionTmp,
        #                                                                   // </GEEU>
        #                                                                   AccountingEvent,
        #                                                                   AccountingDate,
        #                                                                   ParentDistribution,
        #                                                                   TransferPolicy,
        #                                                                   IsCorrection,
        #                                                                   ExchangeRateDate,
        #                                                                   SubledgerJournalEntryType,
        #                                                                   ExchangeRate1,
        #                                                                   ExchangeRate2,
        #                                                                   ReportingExchangeRate1,
        #                                                                   ReportingExchangeRate2,
        #                                                                   FiscalCalendarPeriod,
        #                                                                   TransactionCurrencyCode,
        #                                                                   LegalEntity,
        #                                                                   Ledger,
        #                                                                   PostingLayer,
        #                                                                   LedgerName,
        #                                                                   AccountingCurrency,
        #                                                                   ReportingCurrency,
        #                                                                   SkipAccountValidation,
        #                                                                   AccountingCurrencyAmount,
        #                                                                   TransactionCurrencyAmount,
        #                                                                   ReportingCurrencyAmount,
        #                                                                   LedgerDimension,
        #                                                                   PostingType,
        #                                                                   DebitCredit)
        #
        #              select AccountingDistribution,
        #                    // <GEEU>
        #                    SourceAccountingDistributionTmp,
        #                    // </GEEU>
        #                    AccountingEvent,
        #                    AccountingDate,
        #                    ParentDistribution,
        #                    TransferPolicy,
        #                    IsCorrection,
        #                    ExchangeRateDate,
        #                    SubledgerJournalEntryType,
        #                    ExchangeRate1,
        #                    ExchangeRate2,
        #                    ReportingExchangeRate1,
        #                    ReportingExchangeRate2,
        #                    FiscalCalendarPeriod,
        #                    TransactionCurrencyCode,
        #                    LegalEntity,
        #                    Ledger,
        #                    PostingLayer,
        #                    LedgerName,
        #                    AccountingCurrency,
        #                    ReportingCurrency,
        #                    SkipAccountValidation
        #                from localsubledgerJournalAccountEntryTmpDetail
        #                join
        #                    AccountingCurrencyAmount,
        #                    TransactionCurrencyAmount,
        #                    ReportingCurrencyAmount,
        #                    LedgerDimension,
        #                    PostingType,
        #                    AmountSign
        #                from _interUnitBalancingEntries
        #                    where _interUnitBalancingEntries.SubledgerJournalAccountEntryTmpDetail == localsubledgerJournalAccountEntryTmpDetail.RecId;
        #    }
        #}
      ENDSOURCE
      SOURCE #isExcludedFromDetailOrSummaryRounding
        #private boolean isExcludedFromDetailOrSummaryRounding()
        #{
        #    return (hasInterCompany || SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoRU, #isoCZ, #isoHU, #isoPL, #isoBR, #isoMX ]));
        #}
      ENDSOURCE
      SOURCE #journalize
        #/// <summary>
        #/// Records accounting entries for a source document.
        #/// </summary>
        #public void journalize()
        #{
        #    AccountingEvent                         accountingEvent;
        #    SubledgerJournalTransferProcess         subledgerJournalTransferProcess;
        #    SubledgerJournalEntry                   subledgerJournalEntry;
        #
        #    Debug::assert(sourceDocument != null);
        #
        #    ttsbegin;
        #
        #    this.journalizingEventHandler(sourceDocument.parmSourceDocumentHeader());
        #
        #    //check if there are any finalize events that needs to be accounted.
        #    select firstonly RecId from accountingEvent
        #    where accountingEvent.State == AccountingEventState::Started &&
        #            accountingEvent.SourceDocumentHeader == sourceDocument.parmSourceDocumentHeader().RecId &&
        #            accountingEvent.Type == AccountingEventType::Finalize;
        #
        #    if (accountingEvent)
        #    {
        #        mustDoFinalize = true;
        #    }
        #
        #    //load basic information into temp tables.
        #    this.loadSourceDocumentLineItemTmp(sourceDocument);
        #    if (sourceDocumentLineItemTmp != null)
        #    {
        #        if (SubledgerJournalizerProjectExtension::isVendorRetainage(sourceDocument.parmSourceDocumentHeader().RecId))
        #        {
        #            this.PSALoadaccountingDistReleaseTmp(sourceDocument);
        #        }
        #        else
        #        {
        #        this.loadaccountingDistributionTmp(sourceDocument);
        #        }
        #
        #        //get Accounting Events that are not yet journalized
        #        while select forupdate accountingEvent
        #            where accountingEvent.State == AccountingEventState::Started &&
        #                  accountingEvent.SourceDocumentHeader == sourceDocument.parmSourceDocumentHeader().RecId &&
        #                  accountingEvent.Type != AccountingEventType::Finalize
        #        {
        #            delete_from subledgerJournalAccountEntryTmpDetail;
        #
        #            if (this.canPerformSummaryRoundingAdjustment(sourceDocument))
        #            {
        #                this.recordSubledgerJourAccEntriesForRounding(sourceDocument, accountingEvent);
        #            }
        #            else
        #            {
        #                this.recordSubledgerJournalAccountEntries(sourceDocument, accountingEvent);
        #            }
        #
        #            //Update Accounting Event to be Journalized
        #            accountingEvent.State = AccountingEventState::Journalized;
        #            accountingEvent.update();
        #
        #            //Transfer the accounting entries to GL if the synchronous mode of transfer is used
        #            subledgerJournalTransferProcess = new SubledgerJournalTransferProcess();
        #            subledgerJournalTransferProcess.transferJournalEntries(accountingEvent.RecId);
        #        }
        #
        #
        #        if (mustDoFinalize)
        #        {
        #
        #            this.finalizingEventHandler(sourceDocument.parmSourceDocumentHeader());
        #
        #            this.loadaccountingDistributionTmpFinalize(sourceDocument);
        #
        #            //get Accounting Events that are Finalize type
        #            while select forupdate accountingEvent
        #                where accountingEvent.State == AccountingEventState::Started &&
        #                      accountingEvent.SourceDocumentHeader == sourceDocument.parmSourceDocumentHeader().RecId &&
        #                      accountingEvent.Type == AccountingEventType::Finalize
        #            {
        #                delete_from subledgerJournalAccountEntryTmpDetail;
        #
        #                this.recordSubledgerJournalAccountEntries(sourceDocument, accountingEvent);
        #
        #                select firstonly RecId from subledgerJournalEntry
        #                where subledgerJournalEntry.AccountingEvent == accountingEvent.RecId;
        #
        #                if (subledgerJournalEntry)
        #                {
        #                    //Update Accounting Event to be Journalized
        #                    accountingEvent.State = AccountingEventState::Journalized;
        #                    accountingEvent.update();
        #                    //Transfer the accounting entries to GL if the synchronous mode of transfer is used
        #                    subledgerJournalTransferProcess = new SubledgerJournalTransferProcess();
        #                    subledgerJournalTransferProcess.transferJournalEntries(accountingEvent.RecId);
        #                }
        #                else
        #                {
        #                    accountingEvent.State = AccountingEventState::Complete;
        #                    accountingEvent.update();
        #                }
        #            }
        #
        #            this.finalizedEventHandler(sourceDocument.parmSourceDocumentHeader());
        #        }
        #    }
        #    else
        #    {
        #        // Update accounting event state to complete even though no accounting journal entries are needed for the accounting event.
        #        update_recordset accountingEvent
        #            setting State = AccountingEventState::Complete
        #            where accountingEvent.State == AccountingEventState::Started &&
        #                accountingEvent.SourceDocumentHeader == sourceDocument.parmSourceDocumentHeader().RecId;
        #    }
        #
        #    this.journalizedEventHandler(sourceDocument.parmSourceDocumentHeader());
        #
        #    ttscommit;
        #}
      ENDSOURCE
      SOURCE #journalizedEventHandler
        #/// <summary>
        #/// Serves as a journalized event handler delegate.
        #/// </summary>
        #/// <param name="_sourceDocumentHeader">
        #/// The source document header that is to be journalized.
        #/// </param>
        #delegate void journalizedEventHandler(SourceDocumentHeader _sourceDocumentHeader)
        #{
        #}
      ENDSOURCE
      SOURCE #journalizingEventHandler
        #/// <summary>
        #/// Serves as a journalizing event handler delegate.
        #/// </summary>
        #/// <param name="_sourceDocumentHeader">
        #/// The source document header that is to be journalized.
        #/// </param>
        #delegate void journalizingEventHandler(SourceDocumentHeader _sourceDocumentHeader)
        #{
        #}
      ENDSOURCE
      SOURCE #loadAccDistTmpRelieveAccrual
        #/// <summary>
        #/// Load subledgerJournalAccountEntryRelievingTmp with entries that need to be relieved
        #/// </summary>
        #/// <param name="_sourceDocument">
        #/// SourceDocument
        #/// </param>
        #
        #private void loadAccDistTmpRelieveAccrual(SourceDocument _sourceDocument)
        #{
        #        subledgerJournalReliever.performRelieving(subledgerJournalAccountEntryRelievingTmp);
        #
        #        while select forupdate subledgerJournalAccountEntryRelievingTmp
        #        {
        #            subledgerJournalAccountEntryRelievingTmp.FiscalCalendarPeriod = this.getFiscalCalendarPeriod(subledgerJournalAccountEntryRelievingTmp.DependentAccountingDate, subledgerJournalAccountEntryRelievingTmp.LegalEntity);
        #            subledgerJournalAccountEntryRelievingTmp.update();
        #        }
        #
        #            // <GEEU>
        #    this.loadedAccDistTmpRelieveAccrual(subledgerJournalAccountEntryRelievingTmp);
        #                // </GEEU>
        #}
      ENDSOURCE
      SOURCE #loadaccountingDistributionTmp
        #private void loadaccountingDistributionTmp(SourceDocument _sourceDocument)
        #{
        #    SourceDocumentLine                          sourceDocumentLine;
        #    AccountingDistribution                      accountingDistribution;
        #    AccountingDistribution                      accountingDistributionFromTmp;
        #    AccountingDistribution                      otherAccountingDistribution;
        #    AccountingDistribution                      reversingAccountingDistribution;
        #    SourceDocumentLineItem                      sourceDocumentLineItem;
        #    AccountingJournalizingRule                  journalizingAccountingRule;
        #    AccountingDistributionRule                  distributionAccountingRule;
        #    LedgerDimensionAllocationList               ledgerDimensionAllocationList;
        #    LedgerDimensionAllocationListEnumerator     ledgerDimensionAllocationListEnumerator;
        #    LedgerDimensionAllocation                   ledgerDimensionAllocation;
        #    SubledgerJournalAccountEntry                subledgerJournalAccountEntry;
        #    SubledgerJournalAccountEntryDistribution    subledgerJournalAccountEntryDistribution;
        #    SubledgerJournalEntry                       subledgerJournalEntry;
        #    Ledger                                      accountingDistributionLedger;
        #    boolean                                     isInterCompany;
        #    AccountingEvent                             accountingEvent;
        #    AccountingEvent                             otherAccountingEvent;
        #    AccountingEvent                             reversingAccountingEvent;
        #    accountingDistributionTmp                   otherAccountingDistributionTmp;
        #    AccountingPolicy                            accountingPolicy;
        #    SourceDocumentLineRecId                     previousSourceDocumentLineRecId;
        #    boolean                                     isRelievingVal = true;
        #    RecordInsertList                            recordInsertList;
        #    AccountingEventType                         accountingEventType;
        #    container                                   exchangeRatesContainer;
        #    container                                   reportingExchangeRatesContainer;
        #    container                                   referenceDistributionExchRatesContainer;
        #    boolean                                     isCorrection;
        #    boolean                                     isAccountingDistributionTmpJournalizeCorrection;
        #    boolean                                     isExchangeRateVarianceApplicable;
        #    LegalEntityRecId                            legalEntityRecId;
        #    LedgerRecId                                 ledgerRecId;
        #    Map                                         ledgerByLegalEntity = new Map(Types::Int64, Types::Record);
        #    Map                                         ledgerByRecId = new Map(Types::Int64, Types::Record);
        #    Map                                         accountingEventTypeByRecId = new Map(Types::Int64, Types::Enum);
        #    Set                                         fullRelievedDistributions = new Set(Types::Int64);
        #    Set                                         checkRecordExists = new Set(Types::Int64);
        #    boolean                                     reversingAccountingDistributionExists;
        #    boolean                                     doRelieving;
        #    SourceDocumentLineImplementation            sourceDocumentLineImplementation;
        #    VendInvoiceTrans                            vendInvoiceTrans;
        #    // <PubSect>
        #    SourceDocumentRelievingStrategy             sourceDocumentRelievingStrategy;
        #    SourceDocumentYearEndStrategy               sourceDocumentYearEndStrategy;
        #    boolean                                     doCreateSubledgerJournalLine = true;
        #    // </PubSect>
        #    SourceDocumentCorrection                    sourceDocumentCorrection;
        #    AllocationFactor                            allocationFactor;
        #    SubledgerJournalRoundingPolicy              primaryRoundingPolicy;
        #    SubledgerJournalRoundingPolicy              offsetRoundingPolicy;
        #
        #    #define.ExchangeRate1(1)
        #    #define.ExchangeRate2(2)
        #    #define.ReferenceDistExchangeRate1(1)
        #    #define.ReferenceDistExchangeRate2(2)
        #    #define.ReferenceDistReportingExchangeRate1(3)
        #    #define.ReferenceDistReportingExchangeRate2(4)
        #
        #    sourceDocumentCorrection = SourceDocumentCorrection::newFromSourceDocumentHeader(sourceDocumentHeaderRecId);
        #    reversingAccountingDistributionExists = sourceDocumentCorrection.isApplicable();
        #
        #    recordInsertList = new RecordInsertList(tableNum(AccountingDistributionTmp), true, true, true, false, true, accountingDistributionTmp);
        #    isCorrection = _sourceDocument.parmIsCorrection();
        #
        #    if (isPreviewMode)
        #    {
        #        insert_recordset accountingDistributionTmpJournalize(   TransactionCurrency,
        #                                                                TransactionCurrencyAmount,
        #                                                                LedgerDimension,
        #                                                                AmountSource,
        #                                                                ReferenceDistribution,
        #                                                                AccountingEvent,
        #                                                                SourceDocumentLine,
        #                                                                Type,
        #                                                                AccountingLegalEntity,
        #                                                                ParentDistribution,
        #                                                                AccountingDate,
        #                                                                AllocationFactor,
        #                                                                MonetaryAmount,
        #                                                                Number,
        #                                                                ReferenceRole,
        #                                                                AccountingDistribution
        #                                                                )
        #
        #            select  TransactionCurrency,
        #                    TransactionCurrencyAmount,
        #                    LedgerDimension,
        #                    AmountSource,
        #                    ReferenceDistribution,
        #                    AccountingEvent,
        #                    SourceDocumentLine,
        #                    Type,
        #                    AccountingLegalEntity,
        #                    ParentDistribution,
        #                    AccountingDate,
        #                    AllocationFactor,
        #                    MonetaryAmount,
        #                    Number,
        #                    ReferenceRole,
        #                    RecId
        #            from accountingDistribution
        #                where accountingDistribution.SourceDocumentHeader == sourceDocumentHeaderRecId
        #                    && accountingDistribution.AccountingEvent == 0
        #                    && accountingDistribution.ReferenceRole != AccountingDistributionReferenceRole::Reversing
        #            join sourceDocumentLineItemTmp
        #                where sourceDocumentLineItemTmp.SourceDocumentLine == accountingDistribution.SourceDocumentLine;
        #    }
        #    else
        #    {
        #        insert_recordset accountingDistributionTmpJournalize(   TransactionCurrency,
        #                                                                TransactionCurrencyAmount,
        #                                                                LedgerDimension,
        #                                                                AmountSource,
        #                                                                ReferenceDistribution,
        #                                                                AccountingEvent,
        #                                                                SourceDocumentLine,
        #                                                                Type,
        #                                                                AccountingLegalEntity,
        #                                                                ParentDistribution,
        #                                                                AccountingDate,
        #                                                                AllocationFactor,
        #                                                                MonetaryAmount,
        #                                                                Number,
        #                                                                ReferenceRole,
        #                                                                AccountingDistribution
        #                                                                )
        #
        #            select  TransactionCurrency,
        #                    TransactionCurrencyAmount,
        #                    LedgerDimension,
        #                    AmountSource,
        #                    ReferenceDistribution,
        #                    AccountingEvent,
        #                    SourceDocumentLine,
        #                    Type,
        #                    AccountingLegalEntity,
        #                    ParentDistribution,
        #                    AccountingDate,
        #                    AllocationFactor,
        #                    MonetaryAmount,
        #                    Number,
        #                    ReferenceRole,
        #                    RecId
        #            from accountingDistribution
        #                where accountingDistribution.ReferenceRole != AccountingDistributionReferenceRole::Reversing &&
        #                        accountingDistribution.AccountingEvent != 0 &&
        #                        accountingDistribution.SourceDocumentHeader == sourceDocumentHeaderRecId
        #            join sourceDocumentLineItemTmp // Or we can have seperate insert where we could do isRelieving
        #            where sourceDocumentLineItemTmp.SourceDocumentLine == accountingDistribution.SourceDocumentLine
        #            notexists join accountingEvent
        #                where  accountingDistribution.AccountingEvent == accountingEvent.RecId
        #                    && accountingEvent.State != AccountingEventState::Started;
        #    }
        #
        #    // Cache all reference distribution exchange rates and releiving that will be used
        #    this.loadReferenceDistributionInformation(accountingDistributionTmpJournalize);
        #
        #    while select accountingDistributionTmpJournalize
        #        join sourceDocumentLine
        #            order by RecId
        #            where sourceDocumentLine.RecId == accountingDistributionTmpJournalize.SourceDocumentLine
        #            // ATC_AA_EQ_045 - 20171017 - Begin
        #            && sourceDocumentLine.RecId == this.parmDocumentLine()
        #            // ATC_AA_EQ_045 - 20171017 - End
        #        join accountingDistributionFromTmp
        #            where accountingDistributionFromTmp.RecId == accountingDistributionTmpJournalize.AccountingDistribution
        #    {
        #        if (accountingDistributionTmpJournalize.TransactionCurrencyAmount == 0
        #            && accountingDistributionTmpJournalize.ReferenceDistribution != 0
        #            && !relieveingRequiredSet.in(accountingDistributionTmpJournalize.ReferenceDistribution))
        #        {
        #            continue;
        #        }
        #
        #        if (previousSourceDocumentLineRecId != sourceDocumentLine.RecId)
        #        {
        #            previousSourceDocumentLineRecId = accountingDistributionTmpJournalize.SourceDocumentLine;
        #            if (sourceDocumentLineItemMap.exists(sourceDocumentLine.RecId))
        #            {
        #                sourceDocumentLineItem = sourceDocumentLineItemMap.lookup(sourceDocumentLine.RecId);
        #                sourceDocumentLineImplementation = sourceDocumentLineItemImplMap.lookup(sourceDocumentLine.RecId);
        #            }
        #            else
        #            {
        #                sourceDocumentLineImplementation = sourceDocumentLine.getSourceDocumentLineImplementation();
        #                sourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(sourceDocumentLine, sourceDocumentLineImplementation);
        #            }
        #
        #            if (accountingPolicyMap.exists(sourceDocumentLine.RecId))
        #            {
        #                accountingPolicy = accountingPolicyMap.lookup(sourceDocumentLine.recId);
        #            }
        #            else
        #            {
        #                accountingPolicy = AccountingPolicy::newPolicy(sourceDocumentLineItem);
        #            }
        #            select sourceDocumentLineItemTmp where sourceDocumentLineItemTmp.SourceDocumentLine == sourceDocumentLine.RecId;
        #        }
        #
        #        // Buffer materializations are very expensive and few ledgers are in use, so cache
        #        // the buffer instances within this method scope to reduce the number of materializations
        #        legalEntityRecId = accountingDistributionTmpJournalize.AccountingLegalEntity;
        #        if (!ledgerByLegalEntity.exists(LegalEntityRecId))
        #        {
        #            ledgerByLegalEntity.insert(LegalEntityRecId, Ledger::findByLegalEntity(accountingDistributionTmpJournalize.AccountingLegalEntity));
        #        }
        #        accountingDistributionLedger = ledgerByLegalEntity.lookup(legalEntityRecId);
        #
        #        if (accountingDistributionLedger.ReportingCurrency)
        #        {
        #            reportingExchangeRatesContainer = this.getExchangeRates(accountingDistributionLedger.RecId, accountingDistributionLedger.ReportingCurrency, sourceDocumentLineItemTmp.ExchangeRateDate);
        #        }
        #
        #        if ((accountingDistributionTmpJournalize.AccountingLegalEntity != sourceDocumentLineItemTmp.LegalEntity) &&
        #            sourceDocumentLineItem.documentsInterCompanyBusinessEvent())
        #        {
        #            isInterCompany = true;
        #            if (!hasInterCompany)
        #            {
        #                hasInterCompany = true;
        #            }
        #        }
        #        else
        #        {
        #            isInterCompany = false;
        #        }
        #
        #        if(isInterCompany)
        #        {
        #            //The purpose of having this exchange rate helper instances is to compute the exchange rate
        #            // based on the exchange rate type associated with Accounting distributions ledger.
        #            // These exchange rates will be used only when we have accounting legal entity in the
        #            // accounting distribution different than that of the owning LE.
        #            // The Owning LE is the line LE.
        #            exchangeRatesContainer = this.getExchangeRates(accountingDistributionLedger.RecId, sourceDocumentLineItemTmp.CurrencyCode, sourceDocumentLineItemTmp.ExchangeRateDate);
        #
        #            if (sourceDocumentLineItemTmp.AccountingCurrency == accountingDistributionLedger.AccountingCurrency)
        #            {
        #                if (sourceDocumentLineItem.parmExchangeRate1())
        #                {
        #                    exchangeRatesContainer = conPoke(exchangeRatesContainer, 1, sourceDocumentLineItem.parmExchangeRate1());
        #                }
        #                if (sourceDocumentLineItem.parmExchangeRate2())
        #                {
        #                    exchangeRatesContainer = conPoke(exchangeRatesContainer, 2, sourceDocumentLineItem.parmExchangeRate2());
        #                }
        #            }
        #        }
        #
        #        // make sure context is set to company for line item. This may be different from current context (e.g. purchase req.)
        #        changeCompany(CompanyInfo::getDataArea(sourceDocumentLineItemTmp.LegalEntity))
        #        {
        #            if (!accountingEventTypeByRecId.exists(accountingDistributionTmpJournalize.AccountingEvent))
        #            {
        #                accountingEventTypeByRecId.insert(accountingDistributionTmpJournalize.AccountingEvent, AccountingEvent::find(accountingDistributionTmpJournalize.AccountingEvent).Type);
        #            }
        #            accountingEventType = accountingEventTypeByRecId.lookup(accountingDistributionTmpJournalize.AccountingEvent);
        #
        #            journalizingAccountingRule = accountingPolicy.parmJournalizingRule(accountingDistributionTmpJournalize.MonetaryAmount,accountingEventType);
        #
        #            // <GEEU>
        #            this.loadingDistributionToTmp();
        #            // </GEEU>
        #            if ((!sourceDocumentType.parmReclassifyDistributionAmounts()) || accountingPolicy.parmDocumentRecordsActual())
        #            {
        #                distributionAccountingRule = accountingPolicy.parmDistributionRule(accountingDistributionTmpJournalize.MonetaryAmount);
        #                isExchangeRateVarianceApplicable = accountingPolicy.parmExchangeRateVarianceApplicable();
        #
        #                distributionAccountingRule.parmAccountingdistribution(accountingDistributionFromTmp);
        #
        #                accountingDistributionTmp.clear();
        #                accountingDistributionTmp.initFromAccountingDistTmpJournalize(accountingDistributionTmpJournalize);
        #                accountingDistributionTmp.initFromLedger(accountingDistributionLedger);
        #
        #                accountingDistributionTmp.Offset = NoYes::No;
        #                accountingDistributionTmp.AmountSign = distributionAccountingRule.parmSide();
        #                accountingDistributionTmp.NegativeAmountSign = (distributionAccountingRule.parmSide() == DebitCredit::Credit)? DebitCredit::Debit : DebitCredit::Credit;
        #                accountingDistributionTmp.PostingType = distributionAccountingRule.parmLedgerPostingType();
        #                accountingDistributionTmp.ExchangeRateDate = sourceDocumentLineItemTmp.ExchangeRateDate;
        #                accountingDistributionTmp.HistoricalExchangeRateDate = distributionAccountingRule.getHistoricalExchangeRateDate();
        #
        #                primaryRoundingPolicy = SubledgerJournalRoundingPolicy::newPolicy(sourceDocumentLineItem, accountingDistributionTmp.PostingType);
        #                accountingDistributionTmp.RoundingLevel = primaryRoundingPolicy.parmSubledgerJournalRoundingLevel();
        #
        #                if (isInterCompany)
        #                {
        #                    accountingDistributionTmp.ExchangeRate1 = conPeek(exchangeRatesContainer,#ExchangeRate1);
        #                    accountingDistributionTmp.ExchangeRate2 = conPeek(exchangeRatesContainer,#ExchangeRate2);
        #                    accountingDistributionTmp.ReportingExchangeRate1 = conPeek(reportingExchangeRatesContainer,#ExchangeRate1);
        #                    accountingDistributionTmp.ReportingExchangeRate2 = conPeek(reportingExchangeRatesContainer,#ExchangeRate2);
        #                }
        #                else
        #                {
        #                    accountingDistributionTmp.ExchangeRate1 = sourceDocumentLineItemTmp.ExchangeRate1;
        #                    accountingDistributionTmp.ExchangeRate2 = sourceDocumentLineItemTmp.ExchangeRate2;
        #                    accountingDistributionTmp.ReportingExchangeRate1 = sourceDocumentLineItemTmp.ReportingExchangeRate1;
        #                    accountingDistributionTmp.ReportingExchangeRate2 = sourceDocumentLineItemTmp.ReportingExchangeRate2;
        #                }
        #                accountingDistributionTmp.IsIntercompany = isInterCompany;
        #                accountingDistributionTmp.FiscalCalendarPeriod = this.getFiscalCalendarPeriod(accountingDistributionTmpJournalize.AccountingDate,accountingDistributionTmpJournalize.AccountingLegalEntity);
        #                accountingDistributionTmp.SourceDocumentLine = sourceDocumentLine.RecId;
        #
        #                // Correction flag for primary and opposite match, so store in variable to save a call later
        #                isAccountingDistributionTmpJournalizeCorrection = this.determineCorrectionAccountingApplicable(isCorrection,
        #                                reversingAccountingDistributionExists,
        #                                accountingDistributionTmpJournalize.ReferenceDistribution,
        #                                accountingDistributionTmpJournalize.ReferenceRole);
        #
        #                accountingDistributionTmp.IsCorrection = isAccountingDistributionTmpJournalizeCorrection;
        #
        #                if (isInterCompany)
        #                {
        #                    // get due from
        #                    accountingDistributionTmp.DueFromLedgerDimension = this.getLedgerDimensionOfDueToDueFrom(
        #                                                                        accountingDistributionTmpJournalize.AccountingLegalEntity,
        #                                                                        sourceDocumentLineItemTmp.LegalEntity,
        #                                                                        accountingDistributionTmpJournalize.LedgerDimension,
        #                                                                        -accountingDistributionTmp.TransactionCurrencyAmount);
        #
        #                    accountingDistributionTmp.SourceDocLineLegalEntity = sourceDocumentLineItemTmp.LegalEntity;
        #                }
        #
        #                if ((accountingDistributionTmp.AmountSign == DebitCredit::Credit &&
        #                    accountingDistributionTmpJournalize.TransactionCurrencyAmount >0) ||
        #                    (accountingDistributionTmp.AmountSign == DebitCredit::Debit &&
        #                    accountingDistributionTmpJournalize.TransactionCurrencyAmount <0))
        #                {
        #                    accountingDistributionTmp.TransactionCurrencyAmount = -accountingDistributionTmpJournalize.TransactionCurrencyAmount;
        #                }
        #                else
        #                {
        #                    accountingDistributionTmp.TransactionCurrencyAmount = accountingDistributionTmpJournalize.TransactionCurrencyAmount;
        #                }
        #
        #                // corrections need to flip the sign not the amount.
        #                // If reversing distribution exists(e.g. while correcting a product receipt), the sign should be reversed on reversing entries and not the new ones.
        #                // Reversing distributions will not be present e.g. when creating a free text invoice credit note.
        #                if (accountingDistributionTmp.IsCorrection && !reversingAccountingDistributionExists)
        #                {
        #                    accountingDistributionTmp.AmountSign = accountingDistributionTmp.NegativeAmountSign;
        #                    accountingDistributionTmp.NegativeAmountSign = distributionAccountingRule.parmSide();
        #                }
        #
        #                if (isExchangeRateVarianceApplicable &&
        #                    !conFind([MonetaryAmount::ChargeVariance, MonetaryAmount::TaxNonRecoverableVariance,
        #                          MonetaryAmount::DiscountVariance, MonetaryAmount::PriceAdjustmentVariance,
        #                          MonetaryAmount::PriceVariance, MonetaryAmount::QuantityVariance,
        #                          MonetaryAmount::TaxVariance,MonetaryAmount::RoundingAmount,
        #                          MonetaryAmount::TotalDiscountRounding, MonetaryAmount::TotalDiscountVariance],
        #                          accountingDistributionTmpJournalize.MonetaryAmount))
        #                {
        #                    referenceDistributionExchRatesContainer = this.getReferenceDistributionExchangeRates(accountingDistributionTmpJournalize);
        #                    if (referenceDistributionExchRatesContainer != conNull())
        #                    {
        #                        if (accountingDistributionTmp.ExchangeRate1 != conPeek(referenceDistributionExchRatesContainer,#ReferenceDistExchangeRate1) ||
        #                            accountingDistributionTmp.ExchangeRate2 != conPeek(referenceDistributionExchRatesContainer,#ReferenceDistExchangeRate2) ||
        #                            accountingDistributionTmp.ReportingExchangeRate1 != conPeek(referenceDistributionExchRatesContainer,#ReferenceDistReportingExchangeRate1) ||
        #                            accountingDistributionTmp.ReportingExchangeRate2 != conPeek(referenceDistributionExchRatesContainer,#ReferenceDistReportingExchangeRate2))
        #                        {
        #                            //ERV is applicable & hence get the difference in the rate between current SD and reference SD
        #                            accountingDistributionTmp.ERVExchangeRate1 = accountingDistributionTmp.ExchangeRate1 - conPeek(referenceDistributionExchRatesContainer,#ReferenceDistExchangeRate1);
        #                            accountingDistributionTmp.ERVExchangeRate2 = accountingDistributionTmp.ExchangeRate2 - conPeek(referenceDistributionExchRatesContainer,#ReferenceDistExchangeRate2);
        #                            accountingDistributionTmp.ERVReportingExchangeRate1 = accountingDistributionTmp.ReportingExchangeRate1 - conPeek(referenceDistributionExchRatesContainer,#ReferenceDistReportingExchangeRate1);
        #                            accountingDistributionTmp.ERVReportingExchangeRate2 = accountingDistributionTmp.ReportingExchangeRate2 - conPeek(referenceDistributionExchRatesContainer,#ReferenceDistReportingExchangeRate2);
        #
        #                            //since ERV is applicable the current SD exchange rate should be using reference document exchange rate for computing the accounting and
        #                            // reporting currency amounts.
        #                            accountingDistributionTmp.ExchangeRate1 = conPeek(referenceDistributionExchRatesContainer,#ReferenceDistExchangeRate1);
        #                            accountingDistributionTmp.ExchangeRate2 = conPeek(referenceDistributionExchRatesContainer,#ReferenceDistExchangeRate2);
        #                            accountingDistributionTmp.ReportingExchangeRate1 = conPeek(referenceDistributionExchRatesContainer,#ReferenceDistReportingExchangeRate1);
        #                            accountingDistributionTmp.ReportingExchangeRate2 = conPeek(referenceDistributionExchRatesContainer,#ReferenceDistReportingExchangeRate2);
        #
        #                            accountingDistributionTmp.ERVAccountingDistribution = accountingDistributionTmpJournalize.ReferenceDistribution;
        #
        #                            if (accountingDistributionTmpJournalize.TransactionCurrencyAmount >0)
        #                            {
        #                                if (accountingDistributionTmp.ERVExchangeRate1 >0 || accountingDistributionTmp.ERVReportingExchangeRate1 >0)
        #                                {
        #                                    accountingDistributionTmp.ERVPostingType = LedgerPostingType::ExchRateLoss;
        #                                    accountingDistributionTmp.ERVAmountSign = DebitCredit::Debit;
        #                                    accountingDistributionTmp.ERVNegativeAmountSign = DebitCredit::Credit;
        #                                }
        #                                else
        #                                {
        #                                    accountingDistributionTmp.ERVPostingType = LedgerPostingType::ExchRateGain;
        #                                    accountingDistributionTmp.ERVAmountSign = DebitCredit::Credit;
        #                                    accountingDistributionTmp.ERVNegativeAmountSign = DebitCredit::Debit;
        #                                }
        #                            }
        #                            else
        #                            {
        #                                if (accountingDistributionTmp.ERVExchangeRate1 >0 || accountingDistributionTmp.ERVReportingExchangeRate1 >0)
        #                                {
        #                                    accountingDistributionTmp.ERVPostingType = LedgerPostingType::ExchRateGain;
        #                                    accountingDistributionTmp.ERVAmountSign = DebitCredit::Credit;
        #                                    accountingDistributionTmp.ERVNegativeAmountSign = DebitCredit::Debit;
        #                                }
        #                                else
        #                                {
        #                                    accountingDistributionTmp.ERVPostingType = LedgerPostingType::ExchRateLoss;
        #                                    accountingDistributionTmp.ERVAmountSign = DebitCredit::Debit;
        #                                    accountingDistributionTmp.ERVNegativeAmountSign = DebitCredit::Credit;
        #                                }
        #                            }
        #                            accountingDistributionTmp.ERVLedgerDimension =
        #                                    this.getGainLossLedgerDimension(accountingDistributionLedger.RecId,
        #                                                                    accountingDistributionTmp.TransactionCurrency,
        #                                                                    (accountingDistributionTmp.ERVPostingType == LedgerPostingType::ExchRateGain)?CurrencyGainLossAccountType::UnrealizedGain:CurrencyGainLossAccountType::UnrealizedLoss,
        #                                                                    sourceDocumentLineItem);
        #
        #                            accountingDistributionTmp.ERVTransactionCurrencyAmount = 0;
        #                        }
        #                    }
        #                }
        #
        #                this.calculateForeignCurAmounts(accountingDistributionTmp,sourceDocumentLineItemTmp);
        #                if (accountingDistributionTmp.ERVAccountingCurrencyAmount != 0 || accountingDistributionTmp.ERVReportingCurrencyAmount != 0)
        #                {
        #                    accountingDistributionTmp.IsExchangeRateVariance = true;
        #                    hasExchangeRateVariance = true;
        #                }
        #                accountingDistributionTmp.TransferPolicy =  (distributionAccountingRule.parmSummarize() == true) ? TransferPolicy::Summarize : TransferPolicy::TransferIndividual;
        #                accountingDistributionTmp.LedgerDimension = accountingDistributionTmpJournalize.LedgerDimension;
        #                accountingDistributionTmp.InterCompanyPostingType = LedgerPostingType::InterCompany;
        #
        #                accountingDistributionTmp.initFromAccountingDistributionTmp(accountingDistributionTmp);
        #                accountingDistributionTmp.IsRelieving = false;
        #                accountingDistributionTmp.IsYearEnd = false;
        #                accountingDistributionTmp.SubledgerJournalEntryType = sourceDocumentType.parmSubledgerJournalEntryType();
        #                accountingDistributionTmp.applyFixedDimension();
        #                // <GEEU>
        #                this.insertingDistributedTmp(accountingDistributionTmp);
        #                // </GEEU>
        #                recordInsertList.add(accountingDistributionTmp);
        #                // <GEEU>
        #                this.addedStandardAccountingDistributionTmp(sourceDocumentLineItem, accountingDistributionTmp, accountingDistributionTmpJournalize.AllocationFactor);
        #                // </GEEU>
        #            }
        #
        #            journalizingAccountingRule.parmAccountingdistribution(accountingDistributionFromTmp);
        #            journalizingAccountingRule.parmDimensionValuesUsedForSummaryAccount(true, dimensionValuesUsedForSummaryAccount);
        #            ledgerDimensionAllocationList = journalizingAccountingRule.parmLedgerDimensionAllocList();
        #            ledgerDimensionAllocationListEnumerator = ledgerDimensionAllocationList.getEnumerator();
        #
        #            while (ledgerDimensionAllocationListEnumerator.moveNext())
        #            {
        #                ledgerDimensionAllocation = ledgerDimensionAllocationListEnumerator.current();
        #                //<GEERU>
        #                journalizingAccountingRule.parmCurrentLedgerDimensionAllocation(ledgerDimensionAllocation);
        #                //</GEERU>
        #                accountingDistributionTmp.clear();
        #                accountingDistributionTmp.initFromAccountingDistTmpJournalize(accountingDistributionTmpJournalize);
        #                accountingDistributionTmp.initFromLedger(accountingDistributionLedger);
        #
        #                accountingDistributionTmp.Offset = ledgerDimensionAllocation.parmOppositeAccount();
        #                accountingDistributionTmp.AmountSign = ledgerDimensionAllocation.parmSide();
        #                accountingDistributionTmp.NegativeAmountSign = (ledgerDimensionAllocation.parmSide() == DebitCredit::Credit)? DebitCredit::Debit : DebitCredit::Credit;
        #                if (ledgerDimensionAllocation.parmLedgerPostingType())
        #                {
        #                    accountingDistributionTmp.PostingType = ledgerDimensionAllocation.parmLedgerPostingType();
        #                }
        #                else
        #                {
        #                    accountingDistributionTmp.PostingType = journalizingAccountingRule.parmLedgerPostingType();
        #                }
        #                offsetRoundingPolicy = SubledgerJournalRoundingPolicy::newPolicy(sourceDocumentLineItem, accountingDistributionTmp.PostingType);
        #                accountingDistributionTmp.RoundingLevel = offsetRoundingPolicy.parmSubledgerJournalRoundingLevel();
        #
        #                accountingDistributionTmp.SourceDocumentLine = sourceDocumentLine.RecId;
        #                accountingDistributionTmp.ExchangeRateDate = sourceDocumentLineItemTmp.ExchangeRateDate;
        #                if (isInterCompany)
        #                {
        #                    accountingDistributionTmp.ExchangeRate1 = conPeek(exchangeRatesContainer,#ExchangeRate1);
        #                    accountingDistributionTmp.ExchangeRate2 = conPeek(exchangeRatesContainer,#ExchangeRate2);
        #                    accountingDistributionTmp.ReportingExchangeRate1 = conPeek(reportingExchangeRatesContainer,#ExchangeRate1);
        #                    accountingDistributionTmp.ReportingExchangeRate2 = conPeek(reportingExchangeRatesContainer,#ExchangeRate2);
        #                }
        #                else
        #                {
        #                    accountingDistributionTmp.ExchangeRate1 = sourceDocumentLineItemTmp.ExchangeRate1;
        #                    accountingDistributionTmp.ExchangeRate2 = sourceDocumentLineItemTmp.ExchangeRate2;
        #                    accountingDistributionTmp.ReportingExchangeRate1 = sourceDocumentLineItemTmp.ReportingExchangeRate1;
        #                    accountingDistributionTmp.ReportingExchangeRate2 = sourceDocumentLineItemTmp.ReportingExchangeRate2;
        #                }
        #                accountingDistributionTmp.IsIntercompany = isInterCompany;
        #
        #                accountingDistributionTmp.IsCorrection = isAccountingDistributionTmpJournalizeCorrection;
        #
        #                if ((accountingDistributionTmp.AmountSign == DebitCredit::Credit &&
        #                    accountingDistributionTmpJournalize.TransactionCurrencyAmount >0) ||
        #                    (accountingDistributionTmp.AmountSign == DebitCredit::Debit &&
        #                    accountingDistributionTmpJournalize.TransactionCurrencyAmount <0))
        #                {
        #                    accountingDistributionTmp.TransactionCurrencyAmount = -accountingDistributionTmpJournalize.TransactionCurrencyAmount;
        #                }
        #                else
        #                {
        #                    accountingDistributionTmp.TransactionCurrencyAmount = accountingDistributionTmpJournalize.TransactionCurrencyAmount;
        #                }
        #
        #                // in the correction case the amount sign was reversed above so we don't want to reverse the amount
        #                // If reversing distribution exists(e.g. while correcting a product receipt), the sign should be reversed on reversing entries and not the new ones.
        #                // Reversing distribution will not be present e.g. when creating a free text invoice credit note.
        #                if (accountingDistributionTmp.IsCorrection && !reversingAccountingDistributionExists)
        #                {
        #                    accountingDistributionTmp.AmountSign = accountingDistributionTmp.NegativeAmountSign;
        #                    accountingDistributionTmp.NegativeAmountSign = distributionAccountingRule.parmSide();
        #                }
        #
        #                this.calculateForeignCurAmounts(accountingDistributionTmp,sourceDocumentLineItemTmp);
        #
        #                accountingDistributionTmp.TransferPolicy = (journalizingAccountingRule.parmSummarize() == true) ? TransferPolicy::Summarize : TransferPolicy::TransferIndividual;
        #
        #                journalizingAccountingRule.parmJournalizingCurrentLedgerPostingType(accountingDistributionTmp.PostingType);
        #
        #                if (sourceDocument.parmReferenceSourceDocument() is TSTimesheetTableSourceDoc)
        #                {
        #                    accountingDistributionTmp.LedgerDimension = ledgerDimensionAllocation.parmLedgerDimension();
        #                }
        #                else
        #                {
        #                    accountingDistributionTmp.LedgerDimension = journalizingAccountingRule.getJournalAccountEntryLedgerDimension(ledgerDimensionAllocation.parmLedgerDimension(),accountingDistributionTmpJournalize.LedgerDimension);
        #                }
        #
        #                accountingDistributionTmp.HistoricalExchangeRateDate = journalizingAccountingRule.getHistoricalExchangeRateDate();
        #
        #                if (isInterCompany)
        #                {
        #                    // get due to
        #                    accountingDistributionTmp.DueToLedgerDimension = this.getLedgerDimensionOfDueToDueFrom(
        #                                                                        sourceDocumentLineItemTmp.LegalEntity,
        #                                                                        accountingDistributionTmpJournalize.AccountingLegalEntity,
        #                                                                        accountingDistributionTmpJournalize.LedgerDimension,
        #                                                                        -accountingDistributionTmpJournalize.TransactionCurrencyAmount);
        #
        #                    accountingDistributionTmp.SourceDocLineLegalEntity = sourceDocumentLineItemTmp.LegalEntity;
        #                    accountingDistributionTmp.FiscalCalendarPeriod = this.getFiscalCalendarPeriod(accountingDistributionTmpJournalize.AccountingDate, accountingDistributionTmpJournalize.AccountingLegalEntity);
        #                }
        #                else
        #                {
        #                    accountingDistributionTmp.FiscalCalendarPeriod = this.getFiscalCalendarPeriod(accountingDistributionTmpJournalize.AccountingDate,sourceDocumentLineItem.parmLegalEntityRecId());
        #                }
        #
        #                accountingDistributionTmp.InterCompanyPostingType = LedgerPostingType::InterCompany;
        #
        #                accountingDistributionTmp.initFromAccountingDistributionTmp(accountingDistributionTmp);
        #                accountingDistributionTmp.IsRelieving = false;
        #
        #                switch (accountingEventType)
        #                {
        #                    // closing entries, this section handles encumbrance entries for opening event
        #                    case AccountingEventType::PeriodClose:
        #                        accountingDistributionTmp.YearEndReversalSubledgerJournalEntryType = SubledgerJournalEntryType::PeriodClosed;
        #                        accountingDistributionTmp.IsYearEnd = true;
        #                        if (periodClosingFiscalCalendarPeriodRecId != 0)
        #                        {
        #                            accountingDistributionTmp.FiscalCalendarPeriod = periodClosingFiscalCalendarPeriodRecId;
        #                        }
        #                        break;
        #                    default:
        #                        accountingDistributionTmp.SubledgerJournalEntryType = sourceDocumentType.parmSubledgerJournalEntryType();
        #                        accountingDistributionTmp.IsYearEnd = false;
        #                        break;
        #                }
        #
        #                accountingDistributionTmp.applyFixedDimension();
        #                // <GEEU>
        #                this.insertingJournalizingTmp(accountingDistributionTmp);
        #                // </GEEU>
        #                recordInsertList.add(accountingDistributionTmp);
        #            }
        #
        #            if(isConfigurationkeyEnabled(configurationkeynum(Project3)) && sourceDocumentLineImplementation.TableId == tableNum(VendInvoiceTrans))
        #            {
        #                vendInvoiceTrans = sourceDocumentLineImplementation;
        #
        #                if((vendInvoiceTrans.psaReleaseAmount || vendInvoiceTrans.psaRetainageAmount) &&
        #                   !checkRecordExists.in(sourceDocumentLineImplementation.RecId))
        #                {
        #                    if(vendInvoiceTrans.purchLine().ProjId)
        #                    {
        #                        this.PSALoadAccountingEventHandler(
        #                                                    sourceDocumentLine,
        #                                                    sourceDocumentLineItemTmp,
        #                                                    accountingDistributionTmpJournalize,
        #                                                    accountingDistributionLedger,
        #                                                    sourceDocumentType,
        #                                                    sourceDocumentLineItem,
        #                                                    journalizingAccountingRule,
        #                                                    ledgerDimensionAllocation,
        #                                                    recordInsertList,
        #                                                    accountingEventType,
        #                                                    isInterCompany,
        #                                                    isCorrection,
        #                                                    exchangeRatesContainer,
        #                                                    reportingexchangeRatesContainer);
        #                    }
        #
        #                    allocationFactor += accountingDistributionTmpJournalize.AllocationFactor;
        #
        #                    if (allocationFactor == 1)
        #                    {
        #                        checkRecordExists.add(sourceDocumentLineImplementation.RecId);
        #                    }
        #                }
        #            }
        #
        #            // relieving code
        #            if (sourceDocumentLineItemTmp.SubledgerJournalRelievingMethod != SubledgerJournalRelievingMethod::None &&
        #                accountingDistributionTmpJournalize.ReferenceDistribution != 0 &&
        #                relieveingRequiredSet.in(accountingDistributionTmpJournalize.ReferenceDistribution) &&
        #                !fullRelievedDistributions.in(accountingDistributionTmpJournalize.ReferenceDistribution) &&
        #                !conFind([MonetaryAmount::ChargeVariance, MonetaryAmount::TaxNonRecoverableVariance,
        #                          MonetaryAmount::DiscountVariance, MonetaryAmount::PriceAdjustmentVariance,
        #                          MonetaryAmount::PriceVariance, MonetaryAmount::QuantityVariance,
        #                          MonetaryAmount::TaxVariance],
        #                          accountingDistributionTmpJournalize.MonetaryAmount)
        #               )
        #            {
        #                doRelieving = true;
        #
        #                if (sourceDocumentLineItemTmp.SubledgerJournalRelievingMethod == SubledgerJournalRelievingMethod::Full)
        #                {
        #                    // The upstream SLJAEs were already relievied during a prior confirmation/posting.
        #                    select firstOnly RecId from otherAccountingDistribution
        #                        where otherAccountingDistribution.ReferenceDistribution == accountingDistributionTmpJournalize.ReferenceDistribution
        #                            && otherAccountingDistribution.RecId != accountingDistributionTmpJournalize.AccountingDistribution
        #                            && otherAccountingDistribution.ReferenceRole == AccountingDistributionReferenceRole::Matching
        #                        exists join otherAccountingEvent
        #                            where otherAccountingEvent.RecId == otherAccountingDistribution.AccountingEvent
        #                                && otherAccountingEvent.State != AccountingEventState::Started;
        #
        #                    if (otherAccountingDistribution)
        #                    {
        #                        doRelieving = false;
        #                    }
        #                }
        #
        #                if (doRelieving)
        #                {
        #                    // <GEEU>
        #                    this.startingLoadAccDistrTmpForFinalization();
        #                    // </GEEU>
        #
        #                    // <PubSect>
        #                    sourceDocumentRelievingStrategy = SourceDocumentRelievingStrategy::newFromBusinessEvent(sourceDocumentLineItem.documentsBusinessEvent());
        #
        #                    // </PubSect>
        #                    while select SourceDocumentLine, RecId, LedgerDimension, TransactionCurrency, TransactionCurrencyAmount, ParentDistribution, AccountingDate, AccountingEvent, ReferenceRole
        #                        from accountingDistribution
        #                            where ((sourceDocumentLineItemTmp.SubledgerJournalRelievingMethod == SubledgerJournalRelievingMethod::Full &&
        #                                    accountingDistribution.RecId == accountingDistributionTmpJournalize.ReferenceDistribution &&
        #                                    accountingDistribution.SourceDocumentLine != accountingDistributionTmpJournalize.SourceDocumentLine) ||
        #                                   (sourceDocumentLineItemTmp.SubledgerJournalRelievingMethod == SubledgerJournalRelievingMethod::Partial &&
        #                                    accountingDistribution.RecId == accountingDistributionTmpJournalize.AccountingDistribution &&
        #                                    accountingDistribution.SourceDocumentLine == accountingDistributionTmpJournalize.SourceDocumentLine))
        #                        join AccountingDistribution, SubledgerJournalAccountEntry from subledgerJournalAccountEntryDistribution
        #                            where ((subledgerJournalAccountEntryDistribution.AccountingDistribution ==  accountingDistribution.RecId &&
        #                                    sourceDocumentLineItemTmp.SubledgerJournalRelievingMethod == SubledgerJournalRelievingMethod::Full) ||
        #                                   (subledgerJournalAccountEntryDistribution.AccountingDistribution ==  accountingDistribution.ReferenceDistribution &&
        #                                    sourceDocumentLineItemTmp.SubledgerJournalRelievingMethod == SubledgerJournalRelievingMethod::Partial))
        #                        join RecId, Side, SubledgerJournalEntry, IsCorrection, PostingType, ExchangeRate1, ReportingExchangeRate1, TransactionCurrencyAmount, TransactionCurrency, LedgerDimension, ExchangeRate2, ReportingExchangeRate2, ExchangeRateDate, IsTransferredInDetail
        #                        from subledgerJournalAccountEntry
        #                            where subledgerJournalAccountEntry.RecId == subledgerJournalAccountEntryDistribution.SubledgerJournalAccountEntry &&
        #                                subledgerJournalAccountEntry.PostingType != LedgerPostingType::PurchOrderYearEnd
        #                                // <PubSect>
        #                                && subledgerJournalAccountEntry.PostingType != LedgerPostingType::BudgetReservationYearEnd_PSN
        #                                // </PubSect>
        #                        join RecId, Ledger, Type
        #                        from subledgerJournalEntry
        #                            where subledgerJournalEntry.RecId == subledgerJournalAccountEntry.SubledgerJournalEntry
        #                    {
        #                        // <PubSect>
        #                        doCreateSubledgerJournalLine = sourceDocumentRelievingStrategy.doCreateSubledgerJournalLine(
        #                            subledgerJournalAccountEntry.PostingType,
        #                            subledgerJournalAccountEntry.RecId);
        #
        #                        if (doCreateSubledgerJournalLine)
        #                        {
        #                        // </PubSect>
        #                        accountingDistributionTmp.clear();
        #
        #                        accountingDistributionTmp.IsRelieving = true;
        #                        accountingDistributionTmp.IsYearEnd = false;
        #
        #                        //Initialize from SLJE
        #                        accountingDistributionTmp.RelievingSubledgerJournalEntryType =  subledgerJournalEntry.Type;
        #                        accountingDistributionTmp.Ledger = subledgerJournalEntry.Ledger;
        #                        accountingDistributionTmp.initFromLedger(Ledger::find(accountingDistributionTmp.Ledger));
        #
        #                        // Initialize from accountingDistribution
        #                        accountingDistributionTmp.AccountingDistribution = accountingDistribution.RecId;
        #                        accountingDistributionTmp.FiscalCalendarPeriod = this.getFiscalCalendarPeriod(accountingDistributionTmpJournalize.AccountingDate,accountingDistributionTmpJournalize.AccountingLegalEntity);
        #                        accountingDistributionTmp.ParentDistribution = accountingDistribution.ParentDistribution;
        #                        accountingDistributionTmp.AccountingDate = accountingDistributionTmpJournalize.AccountingDate;
        #
        #                        if (sourceDocumentLineItemTmp.SubledgerJournalRelievingMethod == SubledgerJournalRelievingMethod::Partial)
        #                        {
        #                            accountingDistributionTmp.AccountingEvent = accountingDistribution.AccountingEvent;
        #                            accountingDistributionTmp.SourceDocumentLine = accountingDistribution.SourceDocumentLine;
        #                        }
        #                        else
        #                        {
        #                            accountingDistributionTmp.AccountingEvent = accountingDistributionTmpJournalize.AccountingEvent;
        #                            accountingDistributionTmp.SourceDocumentLine = accountingDistributionTmpJournalize.SourceDocumentLine;
        #                        }
        #
        #                        accountingDistributionTmp.ReferenceRole = accountingDistribution.ReferenceRole;
        #
        #
        #                        // Initialize from SLJAE
        #                        accountingDistributionTmp.IsCorrection = subledgerJournalAccountEntry.IsCorrection;
        #                        accountingDistributionTmp.TransferPolicy = subledgerJournalAccountEntry.IsTransferredInDetail;
        #                        accountingDistributionTmp.PostingType = subledgerJournalAccountEntry.PostingType;
        #                        accountingDistributionTmp.TransactionCurrency = subledgerJournalAccountEntry.TransactionCurrency;
        #                        accountingDistributionTmp.ExchangeRateDate = subledgerJournalAccountEntry.ExchangeRateDate;
        #                        accountingDistributionTmp.ExchangeRate1 = subledgerJournalAccountEntry.ExchangeRate1;
        #                        accountingDistributionTmp.ExchangeRate2 = subledgerJournalAccountEntry.ExchangeRate2;
        #                        if (accountingDistributionTmp.ReportingCurrency)
        #                        {
        #                            accountingDistributionTmp.ReportingExchangeRate1 = subledgerJournalAccountEntry.ReportingExchangeRate1;
        #                            accountingDistributionTmp.ReportingExchangeRate2 = subledgerJournalAccountEntry.ReportingExchangeRate2;
        #                        }
        #                        accountingDistributionTmp.LedgerDimension = subledgerJournalAccountEntry.LedgerDimension;
        #
        #                            /* <SYS>
        #                        accountingDistributionTmp.AmountSign = (subledgerJournalAccountEntry.TransactionCurrencyAmount >0 ? DebitCredit::Debit : DebitCredit::Credit);
        #                            //</SYS> */
        #                            // <PubSect>
        #                            accountingDistributionTmp.AmountSign = sourceDocumentRelievingStrategy.determineRelievingEntryAmountSign(
        #                                accountingDistributionTmpJournalize.MonetaryAmount,
        #                                subledgerJournalAccountEntry.TransactionCurrencyAmount,
        #                                subledgerJournalAccountEntry.PostingType);
        #                            // </PubSect>
        #                        accountingDistributionTmp.NegativeAmountSign = (accountingDistributionTmp.AmountSign == DebitCredit::Credit)? DebitCredit::Debit : DebitCredit::Credit;
        #                        if ((accountingDistributionTmp.AmountSign == DebitCredit::Credit && accountingDistribution.TransactionCurrencyAmount <0) ||
        #                            (accountingDistributionTmp.AmountSign == DebitCredit::Debit && accountingDistribution.TransactionCurrencyAmount >0))
        #                        {
        #                            accountingDistributionTmp.TransactionCurrencyAmount = -accountingDistribution.TransactionCurrencyAmount;
        #
        #                        }
        #                        else
        #                        {
        #                            accountingDistributionTmp.TransactionCurrencyAmount = accountingDistribution.TransactionCurrencyAmount;
        #                        }
        #
        #                        this.calculateForeignCurAmounts(accountingDistributionTmp);
        #
        #                        if (accountingDistributionTmp.TransactionCurrencyAmount > 0||
        #                            (accountingDistributionTmp.TransactionCurrencyAmount < 0 && accountingDistributionTmp.IsCorrection))
        #                        {
        #                            accountingDistributionTmp.AmountSign = DebitCredit::Debit;
        #                            accountingDistributionTmp.NegativeAmountSign = (accountingDistributionTmp.AmountSign == DebitCredit::Credit)? DebitCredit::Debit : DebitCredit::Credit;
        #                        }
        #                        else
        #                        {
        #                            accountingDistributionTmp.AmountSign = DebitCredit::Credit;
        #                            accountingDistributionTmp.NegativeAmountSign = (accountingDistributionTmp.AmountSign == DebitCredit::Credit)? DebitCredit::Debit : DebitCredit::Credit;
        #                        }
        #
        #                        //intercompany details
        #                        accountingDistributionTmp.IsIntercompany = isInterCompany;
        #                        accountingDistributionTmp.InterCompanyPostingType = LedgerPostingType::InterCompany;
        #
        #                        accountingDistributionTmp.initFromAccountingDistributionTmp(accountingDistributionTmp);
        #                        accountingDistributionTmp.applyFixedDimension();
        #                        // <GEEU>
        #                        this.insertingImportedSubledgerAccEntry(subledgerJournalEntry, subledgerJournalAccountEntry, accountingDistributionTmp, recordInsertList);
        #                        // </GEEU>
        #
        #                        recordInsertList.add(accountingDistributionTmp);
        #
        #                        hasRelieving = true;
        #                        // <PubSect>
        #                        }
        #                        // </PubSect>
        #                    }
        #                }
        #
        #                if (sourceDocumentLineItemTmp.SubledgerJournalRelievingMethod == SubledgerJournalRelievingMethod::Full)
        #                {
        #                    fullRelievedDistributions.add(accountingDistributionTmpJournalize.ReferenceDistribution);
        #                }
        #            }
        #
        #            // Period Close, Period Open
        #            if ((accountingEventType == AccountingEventType::PeriodClose || accountingEventType == AccountingEventType::PeriodOpen) &&
        #                accountingDistributionTmpJournalize.ReferenceDistribution != 0)
        #            {
        #                if (isPreviewMode && accountingEventType == AccountingEventType::PeriodOpen)
        #                {
        #                    // flush list to db so records are visible to query
        #                    recordInsertList.insertDatabase();
        #
        #                    // if we are previewing the closing accounting event hasn't been journalized yet. We need to
        #                    // contruct the information related to the reversing of closing entries from the temp table
        #                    while select accountingDistribution
        #                        where accountingDistribution.RecId == accountingDistributionTmpJournalize.ReferenceDistribution
        #                        join accountingDistributionTmp
        #                            where accountingDistributionTmp.AccountingDistribution == accountingDistribution.RecId &&
        #                                accountingDistributionTmp.SourceDocumentLine == accountingDistribution.SourceDocumentLine &&
        #                                accountingDistributionTmp.YearEndReversalSubledgerJournalEntryType == SubledgerJournalEntryType::PeriodClosed
        #
        #                    {
        #                        otherAccountingDistributionTmp.clear();
        #
        #                        otherAccountingDistributionTmp.IsRelieving = false;
        #                        otherAccountingDistributionTmp.IsFinalizing = false;
        #                        otherAccountingDistributionTmp.IsYearEnd = true;
        #
        #                        otherAccountingDistributionTmp.YearEndReversalSubledgerJournalEntryType = SubledgerJournalEntryType::PeriodOpened;
        #
        #                        otherAccountingDistributionTmp.Ledger = accountingDistributionTmp.Ledger;
        #                        otherAccountingDistributionTmp.initFromLedger(Ledger::find(accountingDistributionTmp.Ledger));
        #
        #                        // Initialize from accountingDistribution
        #                        otherAccountingDistributionTmp.AccountingDistribution = accountingDistributionTmpJournalize.AccountingDistribution;
        #                        otherAccountingDistributionTmp.FiscalCalendarPeriod = this.getFiscalCalendarPeriod(accountingDistributionTmpJournalize.AccountingDate,accountingDistributionTmpJournalize.AccountingLegalEntity);
        #                        otherAccountingDistributionTmp.ParentDistribution = accountingDistributionTmpJournalize.ParentDistribution; //check
        #                        otherAccountingDistributionTmp.AccountingDate = accountingDistributionTmpJournalize.AccountingDate;
        #                        otherAccountingDistributionTmp.AccountingEvent = accountingDistributionTmpJournalize.AccountingEvent;
        #                        otherAccountingDistributionTmp.SourceDocumentLine = accountingDistributionTmpJournalize.SourceDocumentLine;
        #                        otherAccountingDistributionTmp.ReferenceRole = accountingDistributionTmpJournalize.ReferenceRole;
        #
        #
        #                        // Initialize from SLJAE
        #                        otherAccountingDistributionTmp.IsCorrection = accountingDistributionTmp.IsCorrection;
        #                        otherAccountingDistributionTmp.TransferPolicy = accountingDistributionTmp.TransferPolicy;
        #                        otherAccountingDistributionTmp.PostingType = accountingDistributionTmp.PostingType;
        #                        otherAccountingDistributionTmp.TransactionCurrency = accountingDistributionTmp.TransactionCurrency;
        #                        otherAccountingDistributionTmp.ExchangeRateDate = accountingDistributionTmp.ExchangeRateDate;
        #                        otherAccountingDistributionTmp.ExchangeRate1 = accountingDistributionTmp.ExchangeRate1;
        #                        otherAccountingDistributionTmp.ExchangeRate2 = accountingDistributionTmp.ExchangeRate2;
        #                        if (accountingDistributionTmp.ReportingCurrency)
        #                        {
        #                            otherAccountingDistributionTmp.ReportingExchangeRate1 = accountingDistributionTmp.ReportingExchangeRate1;
        #                            otherAccountingDistributionTmp.ReportingExchangeRate2 = accountingDistributionTmp.ReportingExchangeRate2;
        #                        }
        #                        otherAccountingDistributionTmp.LedgerDimension = accountingDistributionTmp.LedgerDimension;
        #                        otherAccountingDistributionTmp.AmountSign = (accountingDistributionTmp.AmountSign == DebitCredit::Credit ? DebitCredit::Debit : DebitCredit::Credit);
        #                        otherAccountingDistributionTmp.NegativeAmountSign = (otherAccountingDistributionTmp.AmountSign == DebitCredit::Credit)? DebitCredit::Debit : DebitCredit::Credit;
        #                        if (accountingDistributionTmp.TransactionCurrencyAmount > 0)
        #                        {
        #                            otherAccountingDistributionTmp.TransactionCurrencyAmount = -abs(accountingDistributionTmpJournalize.TransactionCurrencyAmount);
        #
        #                        }
        #                        else
        #                        {
        #                            otherAccountingDistributionTmp.TransactionCurrencyAmount = abs(accountingDistributionTmpJournalize.TransactionCurrencyAmount);
        #                        }
        #
        #                        this.calculateForeignCurAmounts(otherAccountingDistributionTmp);
        #
        #                        //intercompany details
        #                        otherAccountingDistributionTmp.IsIntercompany = isInterCompany;
        #                        otherAccountingDistributionTmp.InterCompanyPostingType = LedgerPostingType::InterCompany;
        #
        #                        otherAccountingDistributionTmp.initFromAccountingDistributionTmp(otherAccountingDistributionTmp);
        #
        #                        otherAccountingDistributionTmp.applyFixedDimension();
        #                        recordInsertList.add(otherAccountingDistributionTmp);
        #
        #                        hasYearEnd = true;
        #
        #                    }
        #                }
        #                else
        #                {
        #                    // <PubSect>
        #                    sourceDocumentYearEndStrategy = SourceDocumentYearEndStrategy::newFromBusinessEvent(sourceDocumentLineItem.documentsBusinessEvent());
        #                    // </PubSect>
        #
        #                    // <GEEU>
        #                    this.startingLoadAccDistrTmpForFinalization();
        #                    // </GEEU>
        #                    while select SourceDocumentLine, RecId, LedgerDimension, TransactionCurrency, TransactionCurrencyAmount, ParentDistribution, AccountingDate, AccountingEvent, ReferenceRole
        #                        from accountingDistribution
        #                            where accountingDistribution.RecId == accountingDistributionTmpJournalize.ReferenceDistribution
        #                        join AccountingDistribution, SubledgerJournalAccountEntry from subledgerJournalAccountEntryDistribution
        #                            where subledgerJournalAccountEntryDistribution.AccountingDistribution ==  accountingDistribution.RecId
        #                        join RecId from otherAccountingEvent
        #                            where otherAccountingEvent.RecId == accountingDistribution.AccountingEvent
        #                        join RecId, Side, SubledgerJournalEntry, IsCorrection, PostingType, ExchangeRate1, ReportingExchangeRate1, TransactionCurrencyAmount, TransactionCurrency, LedgerDimension, ExchangeRate2, ReportingExchangeRate2, ExchangeRateDate, IsTransferredInDetail
        #                        from subledgerJournalAccountEntry
        #                            where subledgerJournalAccountEntry.RecId == subledgerJournalAccountEntryDistribution.SubledgerJournalAccountEntry &&
        #                            // processing period open distributions that reference period close distributions. Only pickup sljae related to year close and not reversal of encumbrances.
        #                            /*<SYS>
        #                            ((otherAccountingEvent.Type == AccountingEventType::PeriodClose && subledgerJournalAccountEntry.PostingType == LedgerPostingType::PurchOrderYearEnd) ||
        #                            </SYS>*/
        #                            // <PubSect>
        #                            ((otherAccountingEvent.Type == AccountingEventType::PeriodClose && (subledgerJournalAccountEntry.PostingType == LedgerPostingType::PurchOrderYearEnd ||
        #                            subledgerJournalAccountEntry.PostingType == LedgerPostingType::BudgetReservationYearEnd_PSN)) ||
        #                            // </PubSect>
        #                            // processing period close distributions that reference purchase order distributions.
        #                             (otherAccountingEvent.Type != accountingEventType::PeriodClose))
        #                        join RecId, Ledger, Type
        #                        from subledgerJournalEntry
        #                            where subledgerJournalEntry.RecId == subledgerJournalAccountEntry.SubledgerJournalEntry &&
        #                                  subledgerJournalEntry.AccountingEvent == accountingDistribution.AccountingEvent &&
        #                                  // don't include period open distributions
        #                                  ((otherAccountingEvent.Type != AccountingEventType::PeriodOpen) ||
        #                                   (otherAccountingEvent.Type == AccountingEventType::PeriodOpen &&
        #                                    subledgerJournalEntry.Type != subledgerJournalEntryType::PeriodOpened))
        #                    {
        #
        #                        // <PubSect>
        #                        if (!sourceDocumentYearEndStrategy.doCreateYearEndEntry(subledgerJournalAccountEntry.PostingType))
        #                        {
        #                            continue;
        #                        }
        #                        // </PubSect>
        #
        #                        accountingDistributionTmp.clear();
        #
        #                        accountingDistributionTmp.IsRelieving = false;
        #                        accountingDistributionTmp.IsFinalizing = false;
        #                        accountingDistributionTmp.IsYearEnd = true;
        #
        #                        if (accountingEventType == AccountingEventType::PeriodOpen)
        #                        {
        #                            // for the reversal of closing entries
        #                            accountingDistributionTmp.YearEndReversalSubledgerJournalEntryType = SubledgerJournalEntryType::PeriodOpened;
        #                        }
        #                        else
        #                        {
        #                            // for the closing entries
        #                            accountingDistributionTmp.YearEndReversalSubledgerJournalEntryType = sourceDocumentType.parmSubledgerJournalEntryType();
        #                        }
        #
        #                        accountingDistributionTmp.Ledger = subledgerJournalEntry.Ledger;
        #                        accountingDistributionTmp.initFromLedger(Ledger::find(accountingDistributionTmp.Ledger));
        #
        #                        // Initialize from accountingDistribution
        #                        accountingDistributionTmp.AccountingDistribution = accountingDistributionTmpJournalize.AccountingDistribution;
        #                        // need to get period closing if closing event.
        #                        if (accountingEventType == AccountingEventType::PeriodClose && periodClosingFiscalCalendarPeriodRecId != 0)
        #                        {
        #                            accountingDistributionTmp.FiscalCalendarPeriod = periodClosingFiscalCalendarPeriodRecId;
        #                        }
        #                        else
        #                        {
        #                            accountingDistributionTmp.FiscalCalendarPeriod = this.getFiscalCalendarPeriod(accountingDistributionTmpJournalize.AccountingDate,accountingDistributionTmpJournalize.AccountingLegalEntity);
        #                        }
        #                        accountingDistributionTmp.ParentDistribution = accountingDistributionTmpJournalize.ParentDistribution; //check
        #                        accountingDistributionTmp.AccountingDate = accountingDistributionTmpJournalize.AccountingDate;
        #                        accountingDistributionTmp.AccountingEvent = accountingDistributionTmpJournalize.AccountingEvent;
        #                        accountingDistributionTmp.SourceDocumentLine = accountingDistributionTmpJournalize.SourceDocumentLine;
        #                        accountingDistributionTmp.ReferenceRole = accountingDistributionTmpJournalize.ReferenceRole;
        #
        #
        #                        // Initialize from SLJAE
        #                        accountingDistributionTmp.IsCorrection = subledgerJournalAccountEntry.IsCorrection;
        #                        accountingDistributionTmp.TransferPolicy = subledgerJournalAccountEntry.IsTransferredInDetail;
        #                        accountingDistributionTmp.PostingType = subledgerJournalAccountEntry.PostingType;
        #                        accountingDistributionTmp.TransactionCurrency = subledgerJournalAccountEntry.TransactionCurrency;
        #                        accountingDistributionTmp.ExchangeRateDate = subledgerJournalAccountEntry.ExchangeRateDate;
        #                        accountingDistributionTmp.ExchangeRate1 = subledgerJournalAccountEntry.ExchangeRate1;
        #                        accountingDistributionTmp.ExchangeRate2 = subledgerJournalAccountEntry.ExchangeRate2;
        #                        if (accountingDistributionTmp.ReportingCurrency)
        #                        {
        #                            accountingDistributionTmp.ReportingExchangeRate1 = subledgerJournalAccountEntry.ReportingExchangeRate1;
        #                            accountingDistributionTmp.ReportingExchangeRate2 = subledgerJournalAccountEntry.ReportingExchangeRate2;
        #                        }
        #                        accountingDistributionTmp.LedgerDimension = subledgerJournalAccountEntry.LedgerDimension;
        #                        accountingDistributionTmp.AmountSign = (subledgerJournalAccountEntry.Side == DebitCredit::Credit ? DebitCredit::Debit : DebitCredit::Credit);
        #                        accountingDistributionTmp.NegativeAmountSign = (accountingDistributionTmp.AmountSign == DebitCredit::Credit)? DebitCredit::Debit : DebitCredit::Credit;
        #                        if (subledgerJournalAccountEntry.TransactionCurrencyAmount > 0)
        #                        {
        #                            accountingDistributionTmp.TransactionCurrencyAmount = -abs(accountingDistributionTmpJournalize.TransactionCurrencyAmount);
        #
        #                        }
        #                        else
        #                        {
        #                            accountingDistributionTmp.TransactionCurrencyAmount = abs(accountingDistributionTmpJournalize.TransactionCurrencyAmount);
        #                        }
        #
        #                        this.calculateForeignCurAmounts(accountingDistributionTmp);
        #
        #                        //intercompany details
        #                        accountingDistributionTmp.IsIntercompany = isInterCompany;
        #                        accountingDistributionTmp.InterCompanyPostingType = LedgerPostingType::InterCompany;
        #
        #                        accountingDistributionTmp.initFromAccountingDistributionTmp(accountingDistributionTmp);
        #
        #                        accountingDistributionTmp.applyFixedDimension();
        #                        // <GEEU>
        #                        this.insertingImportedSubledgerAccEntry(subledgerJournalEntry, subledgerJournalAccountEntry, accountingDistributionTmp, recordInsertList);
        #                        // </GEEU>
        #                        recordInsertList.add(accountingDistributionTmp);
        #
        #                        hasYearEnd = true;
        #                    }
        #                }
        #            }
        #        }
        #    }
        #
        #    this.loadAccDistTmpRelieveAccrual(_sourceDocument);
        #
        #    //Populate Distributions Tmp Table for the Reversal Scenario
        #    //Reversal is handled differently because we want to get the same accounts and amounts
        #    //Hence we use the links to get to the original accounting entries and use the accounts and amounts.
        #    //Since the setup entities associated are not date effective, we cannot rely on the
        #    //setup to consistently give the same account. Also the amounts could include
        #    //rounded amounts and we want to reverse exactly what was recorded.
        #    //Also the accountingcurrency exchange rate and reporting currency exchange rate are all
        #    // used based on what is already recorded in SLJ
        #
        #    // <GEEU>
        #    this.startingLoadAccDistrTmpForFinalization();
        #    // </GEEU>
        #
        #    if (reversingAccountingDistributionExists)
        #    {
        #        while select reversingAccountingDistribution
        #            where reversingAccountingDistribution.SourceDocumentHeader == sourceDocumentHeaderRecId
        #                && reversingAccountingDistribution.ReferenceRole == AccountingDistributionReferenceRole::Reversing
        #            join AccountingCurrencyAmount from subledgerJournalAccountEntryDistribution
        #                where subledgerJournalAccountEntryDistribution.AccountingDistribution == reversingAccountingDistribution.ReferenceDistribution
        #            join Side, IsCorrection, PostingType, ExchangeRate1, ReportingExchangeRate1, LedgerDimension, ExchangeRate2, ReportingExchangeRate2, ExchangeRateDate, OriginalTransferPolicy from subledgerJournalAccountEntry
        #                where subledgerJournalAccountEntry.RecId == subledgerJournalAccountEntryDistribution.SubledgerJournalAccountEntry
        #                    && subledgerJournalAccountEntry.PostingType != LedgerPostingType::PurchOrderYearEnd
        #                    // <PubSect>
        #                    && subledgerJournalAccountEntry.PostingType != LedgerPostingType::BudgetReservationYearEnd_PSN
        #                    // </PubSect>
        #            join Type, Ledger from subledgerJournalEntry
        #                where subledgerJournalEntry.RecId == subledgerJournalAccountEntry.SubledgerJournalEntry
        #            exists join reversingAccountingEvent
        #                where reversingAccountingEvent.RecId == reversingAccountingDistribution.AccountingEvent
        #                    && reversingAccountingEvent.State == AccountingEventState::Started
        #        {
        #            // Buffer materializations are very expensive and few ledgers are in use, so cache
        #            // the buffer instances within this method scope to reduce the number of materializations
        #            ledgerRecId = subledgerJournalEntry.Ledger;
        #
        #            if (!ledgerByRecId.exists(ledgerRecId))
        #            {
        #                ledgerByRecId.insert(ledgerRecId, Ledger::find(ledgerRecId));
        #            }
        #
        #            accountingDistributionLedger = ledgerByRecId.lookup(ledgerRecId);
        #
        #            accountingDistributionTmp.clear();
        #            accountingDistributionTmp.initFromAccountingDistribution(reversingAccountingDistribution);
        #            accountingDistributionTmp.initFromLedger(accountingDistributionLedger);
        #            accountingDistributionTmp.SourceDocumentLine = reversingAccountingDistribution.SourceDocumentLine;
        #            accountingDistributionTmp.LedgerDimension = subledgerJournalAccountEntry.LedgerDimension;
        #            accountingDistributionTmp.PostingType = subledgerJournalAccountEntry.PostingType;
        #            accountingDistributionTmp.ExchangeRateDate = subledgerJournalAccountEntry.ExchangeRateDate;
        #            accountingDistributionTmp.ExchangeRate1 = subledgerJournalAccountEntry.ExchangeRate1;
        #            accountingDistributionTmp.ExchangeRate2 = subledgerJournalAccountEntry.ExchangeRate2;
        #            accountingDistributionTmp.SubledgerJournalEntryType = subledgerJournalEntry.Type;
        #
        #            if (accountingDistributionTmp.ReportingCurrency)
        #            {
        #                accountingDistributionTmp.ReportingExchangeRate1 = subledgerJournalAccountEntry.ReportingExchangeRate1;
        #                accountingDistributionTmp.ReportingExchangeRate2 = subledgerJournalAccountEntry.ReportingExchangeRate2;
        #            }
        #
        #            if (isCorrection)
        #            {
        #                accountingDistributionTmp.IsCorrection = isCorrection;
        #            }
        #            else
        #            {
        #                accountingDistributionTmp.IsCorrection = subledgerJournalAccountEntry.IsCorrection;
        #            }
        #
        #            if (accountingDistributionTmp.IsCorrection)
        #            {
        #                accountingDistributionTmp.AmountSign = subledgerJournalAccountEntry.Side;
        #                accountingDistributionTmp.NegativeAmountSign = (subledgerJournalAccountEntry.Side == DebitCredit::Credit ? DebitCredit::Debit : DebitCredit::Credit);
        #            }
        #            else
        #            {
        #                accountingDistributionTmp.AmountSign = (subledgerJournalAccountEntry.Side == DebitCredit::Credit ? DebitCredit::Debit : DebitCredit::Credit);
        #                accountingDistributionTmp.NegativeAmountSign = subledgerJournalAccountEntry.Side;
        #            }
        #
        #            if(subledgerJournalAccountEntryDistribution.AccountingCurrencyAmount < 0)
        #            {
        #                accountingDistributionTmp.TransactionCurrencyAmount = abs(reversingAccountingDistribution.TransactionCurrencyAmount);
        #            }
        #            else
        #            {
        #                accountingDistributionTmp.TransactionCurrencyAmount = -abs(reversingAccountingDistribution.TransactionCurrencyAmount);
        #            }
        #
        #            accountingDistributionTmp.FiscalCalendarPeriod = this.getFiscalCalendarPeriod(reversingAccountingDistribution.AccountingDate, accountingDistributionTmp.LegalEntity);
        #            this.calculateForeignCurAmounts(accountingDistributionTmp);
        #
        #            // During posting the entries in the subledger journal may have been modified to do not transfer, therefore during
        #            // correction they need to default to the original transfer policy as defined by the accounting rule, or unbalanced
        #            // subledger journal entries will occur.
        #            // For all the other source documents, transfer policy is the original transfer policy, as defined by the accounting rule.
        #            accountingDistributionTmp.TransferPolicy = subledgerJournalAccountEntry.OriginalTransferPolicy;
        #            accountingDistributionTmp.InterCompanyPostingType = LedgerPostingType::InterCompany;
        #            accountingDistributionTmp.initFromAccountingDistributionTmp(accountingDistributionTmp);
        #            accountingDistributionTmp.IsRelieving = false;
        #            accountingDistributionTmp.applyFixedDimension();
        #            // <GEEU>
        #            this.insertingImportedSubledgerAccEntry(subledgerJournalEntry, subledgerJournalAccountEntry, accountingDistributionTmp, recordInsertList);
        #            // </GEEU>
        #            recordInsertList.add(accountingDistributionTmp);
        #        }
        #    }
        #
        #    recordInsertList.insertDatabase();
        #    // <GEEU>
        #    this.loadedAccountingDistributionTmp();
        #    // </GEEU>
        #}
      ENDSOURCE
      SOURCE #loadaccountingDistributionTmpFinalize
        #private void loadaccountingDistributionTmpFinalize(SourceDocument _sourceDocument)
        #{
        #    SourceDocumentLine                          sourceDocumentLine;
        #    AccountingDistribution                      accountingDistribution;
        #    AccountingDistribution                      yearEndAccountingDistribution;
        #    AccountingDistribution                      refAccountingDistribution;
        #    accountingDistribution                      reversingAccountingDistribution;
        #    SubledgerJournalAccountEntry                subledgerJournalAccountEntry;
        #    SubledgerJournalAccountEntryDistribution    subledgerJournalAccountEntryDistribution;
        #    SubledgerJournalEntry                       subledgerJournalEntry;
        #    AccountingEvent                             accountingEvent;
        #    SourceDocumentLine                          refSourceDocumentLine;
        #    SourceDocumentLineItem                      sourceDocumentLineItem;
        #    boolean                                     isInterCompany;
        #    Set                                         yearEndReferenceDistributions;
        #    // <PubSect>
        #    SourceDocumentFinalizeStrategy              sourceDocumentFinalizeStrategy;
        #    boolean                                     doCreateSubledgerJournalLine = true;
        #    // </PubSect>
        #
        #    yearEndReferenceDistributions = new Set(Types::Int64);
        #
        #    while select ReferenceDistribution from yearEndAccountingDistribution
        #        where yearEndAccountingDistribution.SourceDocumentHeader == sourceDocumentHeaderRecId
        #        exists join accountingEvent
        #        where accountingEvent.RecId == yearEndAccountingDistribution.AccountingEvent
        #        &&  (accountingEvent.Type == AccountingEventType::PeriodClose ||
        #            accountingEvent.Type == AccountingEventType::PeriodOpen)
        #    {
        #        yearEndReferenceDistributions.add(yearEndAccountingDistribution.ReferenceDistribution);
        #    }
        #
        #    // <GEEU>
        #    this.startingLoadAccDistrTmpForFinalization();
        #    // </GEEU>
        #
        #    while select *
        #        from accountingDistribution
        #        order by SourceDocumentLine, MonetaryAmount, subledgerJournalAccountEntryDistribution.SubledgerJournalAccountEntry
        #        where accountingDistribution.ReferenceRole != AccountingDistributionReferenceRole::Reversing
        #              && accountingDistribution.SourceDocumentHeader == sourceDocumentHeaderRecId
        #        join LegalEntity, ExchangeRate1, ReportingExchangeRate1, TypeEnumName
        #        from sourceDocumentLineItemTmp
        #            where sourceDocumentLineItemTmp.SourceDocumentLine == accountingDistribution.SourceDocumentLine
        #        join *
        #        from sourceDocumentLine
        #            where sourceDocumentLine.recId == sourceDocumentLineItemTmp.SourceDocumentLine
        #        join RecId, State, Type, AccountingDate
        #        from accountingEvent
        #            where  accountingEvent.RecId == accountingDistribution.FinalizeAccountingEvent
        #                && accountingEvent.State == AccountingEventState::Started
        #                && accountingEvent.Type == AccountingEventType::Finalize
        #        join AccountingDistribution, SubledgerJournalAccountEntry
        #        from subledgerJournalAccountEntryDistribution
        #            where subledgerJournalAccountEntryDistribution.AccountingDistribution == accountingDistribution.RecId
        #        join RecId, Side, SubledgerJournalEntry, IsCorrection, PostingType, ExchangeRate1, ReportingExchangeRate1, TransactionCurrencyAmount, TransactionCurrency, LedgerDimension, ExchangeRate2, ReportingExchangeRate2, ExchangeRateDate, IsTransferredInDetail, OriginalTransferPolicy
        #        from subledgerJournalAccountEntry
        #            where subledgerJournalAccountEntryDistribution.SubledgerJournalAccountEntry == subledgerJournalAccountEntry.RecId &&
        #                subledgerJournalAccountEntry.PostingType != LedgerPostingType::PurchOrderYearEnd
        #                // <PubSect>
        #                && subledgerJournalAccountEntry.PostingType != LedgerPostingType::BudgetReservationYearEnd_PSN
        #                // </PubSect>
        #        join Ledger, FiscalCalendarPeriod, Type from subledgerJournalEntry
        #            where subledgerJournalEntry.RecId == subledgerJournalAccountEntry.SubledgerJournalEntry
        #        notexists join reversingAccountingDistribution
        #            where reversingAccountingDistribution.ReferenceDistribution == accountingDistribution.RecId
        #               && reversingAccountingDistribution.ReferenceRole == AccountingDistributionReferenceRole::Reversing
        #    {
        #        // <PubSect>
        #        sourceDocumentLineItem          = SourceDocumentLineItem::newFromSourceDocumentLine(sourceDocumentLine);
        #        sourceDocumentFinalizeStrategy  = SourceDocumentFinalizeStrategy::newFromBusinessEvent(sourceDocumentLineItem.documentsBusinessEvent());
        #        doCreateSubledgerJournalLine    = sourceDocumentFinalizeStrategy.doCreateSubledgerJournalLine(subledgerJournalAccountEntry.PostingType);
        #        // </PubSect>
        #
        #        // if an accounting distribution is referenced in a year end distribution, it is not an active distribution.
        #        /* <SYS>
        #        if (yearEndReferenceDistributions.in(accountingDistribution.RecId))
        #        </SYS> */
        #        // <PubSect>
        #        if (yearEndReferenceDistributions.in(accountingDistribution.RecId) || !doCreateSubledgerJournalLine)
        #        // </PubSect>
        #        {
        #            continue;
        #        }
        #
        #        if (sourceDocumentLineItemTmp.TypeEnumName != enumStr(SourceDocumentLine_ProductReceipt))
        #        {
        #                select sum(TransactionCurrencyAmount) from refAccountingDistribution // currency would be same or diff?
        #                        where  refAccountingDistribution.ReferenceDistribution == accountingDistribution.RecId &&
        #                                refAccountingDistribution.MonetaryAmount != MonetaryAmount::ChargeVariance &&
        #                                refAccountingDistribution.MonetaryAmount != MonetaryAmount::TaxNonRecoverableVariance &&
        #                                refAccountingDistribution.MonetaryAmount != MonetaryAmount::DiscountVariance &&
        #                                refAccountingDistribution.MonetaryAmount != MonetaryAmount::PriceAdjustmentVariance &&
        #                                refAccountingDistribution.MonetaryAmount != MonetaryAmount::PriceVariance &&
        #                                refAccountingDistribution.MonetaryAmount != MonetaryAmount::QuantityVariance &&
        #                                refAccountingDistribution.MonetaryAmount != MonetaryAmount::TaxVariance
        #                    notexists join refSourceDocumentLine
        #                         where refSourceDocumentLine.RecId == refAccountingDistribution.SourceDocumentLine &&
        #                         refSourceDocumentLine.TypeEnumName == enumstr(SourceDocumentLine_ProductReceipt);
        #
        #                if (abs(accountingDistribution.TransactionCurrencyAmount) > abs(refAccountingDistribution.TransactionCurrencyAmount))
        #                {
        #                    accountingDistributionTmp.clear();
        #                    accountingDistributionTmp.IsRelieving = false;
        #                    accountingDistributionTmp.IsFinalizing = true;
        #
        #                    accountingDistributionTmp.TransactionCurrencyAmount = accountingDistribution.TransactionCurrencyAmount-refAccountingDistribution.TransactionCurrencyAmount;
        #                    accountingDistributionTmp.AmountSign = subledgerJournalAccountEntry.Side == DebitCredit::Credit ? DebitCredit::Debit : DebitCredit::Credit;
        #                    accountingDistributionTmp.NegativeAmountSign = subledgerJournalAccountEntry.Side;
        #
        #                    if ((accountingDistributionTmp.AmountSign == DebitCredit::Credit && accountingDistributionTmp.TransactionCurrencyAmount >0) ||
        #                        (accountingDistributionTmp.AmountSign == DebitCredit::Debit && accountingDistributionTmp.TransactionCurrencyAmount <0))
        #                    {
        #                        accountingDistributionTmp.TransactionCurrencyAmount = -accountingDistributionTmp.TransactionCurrencyAmount;
        #
        #                    }
        #
        #                    //Initialize from SLJE
        #                    accountingDistributionTmp.RelievingSubledgerJournalEntryType =  subledgerJournalEntry.Type;
        #                    accountingDistributionTmp.Ledger = subledgerJournalEntry.Ledger;
        #                    accountingDistributionTmp.initFromLedger(Ledger::find(accountingDistributionTmp.Ledger));
        #
        #                    // Initialize from accountingDistribution
        #                    accountingDistributionTmp.SourceDocumentLine = accountingDistribution.SourceDocumentLine;
        #                    accountingDistributionTmp.initFromAccountingDistribution(accountingDistribution);
        #                    accountingDistributionTmp.LedgerDimension = subledgerJournalAccountEntry.LedgerDimension;
        #                    accountingDistributionTmp.FiscalCalendarPeriod = this.getFiscalCalendarPeriod(accountingEvent.AccountingDate, sourceDocumentLineItemTmp.LegalEntity);
        #                    accountingDistributionTmp.FinalizeAccountingEvent = accountingDistribution.FinalizeAccountingEvent;
        #
        #                    // Initialize from SLJAE
        #                    accountingDistributionTmp.TransactionCurrency = subledgerJournalAccountEntry.TransactionCurrency;
        #                    accountingDistributionTmp.TransferPolicy = subledgerJournalAccountEntry.IsTransferredInDetail;
        #                    accountingDistributionTmp.IsCorrection = subledgerJournalAccountEntry.IsCorrection;
        #                    accountingDistributionTmp.PostingType = subledgerJournalAccountEntry.PostingType;
        #                    accountingDistributionTmp.ExchangeRateDate = subledgerJournalAccountEntry.ExchangeRateDate;
        #                    accountingDistributionTmp.ExchangeRate1 = subledgerJournalAccountEntry.ExchangeRate1;
        #                    accountingDistributionTmp.ExchangeRate2 = subledgerJournalAccountEntry.ExchangeRate2;
        #
        #                    if (accountingDistributionTmp.ReportingCurrency)
        #                    {
        #                        accountingDistributionTmp.ReportingExchangeRate1 = subledgerJournalAccountEntry.ReportingExchangeRate1;
        #                        accountingDistributionTmp.ReportingExchangeRate2 = subledgerJournalAccountEntry.ReportingExchangeRate2;
        #                    }
        #
        #                    this.calculateForeignCurAmounts(accountingDistributionTmp);
        #                    /* <SYS>
        #                    sourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(sourceDocumentLine);
        #                    </SYS> */
        #                    if ((accountingDistributionTmp.LegalEntity != sourceDocumentLineItemTmp.LegalEntity) &&
        #                        sourceDocumentLineItem.documentsInterCompanyBusinessEvent())
        #                    {
        #                        isInterCompany = true;
        #                    }
        #                    else
        #                    {
        #                        isInterCompany = false;
        #                    }
        #
        #                    //intercompany details
        #                    accountingDistributionTmp.IsIntercompany = isInterCompany;
        #                    accountingDistributionTmp.InterCompanyPostingType = LedgerPostingType::InterCompany;
        #                    accountingDistributionTmp.initFromAccountingDistributionTmp(accountingDistributionTmp);
        #                    accountingDistributionTmp.applyFixedDimension();
        #
        #                    // <GEEU>
        #                    this.insertingImportedSubledgerAccEntry(subledgerJournalEntry, subledgerJournalAccountEntry, accountingDistributionTmp, null);
        #                    // </GEEU>
        #                    accountingDistributionTmp.insert();
        #                    hasFinalizing = true;
        #
        #            }
        #        }
        #    }
        #                }
        #
      ENDSOURCE
      SOURCE #loadedAccDistTmpRelieveAccrual
        #/// <summary>
        #/// Load subledgerJournalAccountEntryRelievingTmp with entries that need to be relieved.
        #/// </summary>
        #/// <param name="_subledgerJournalAccountEntryRelievingTmp">
        #/// The destination <c>SubledgerJournalAccountEntryRelievingTmp</c> table.
        #/// </param>
        #delegate void loadedAccDistTmpRelieveAccrual(SubledgerJournalAccountEntryRelievingTmp _subledgerJournalAccountEntryRelievingTmp)
        #                {
        #                    }
      ENDSOURCE
      SOURCE #loadedAccountingDistributionTmp
        #/// <summary>
        #/// An <c>AccountingDistributionTmp</c> record loaded event handler delegate.
        #/// </summary>
        #delegate void loadedAccountingDistributionTmp()
        #{
        #}
      ENDSOURCE
      SOURCE #loadedSubledgerJournalTmpDetail
        #/// <summary>
        #/// Transfers the <c>AccountingDistributionTmp</c> table into the
        #/// <c>SubledgerJournalAccountEntryTmpDetail</c> table.
        #/// </summary>
        #/// <param name="_accountingEvent">
        #/// An accounting event.
        #/// </param>
        #/// <param name="_accountingDistributionTmp">
        #/// The source <c>AccountingDistributionTmp</c> table.
        #/// </param>
        #/// <param name="_subledgerJournalAccountEntryTmpDetail">
        #/// The destination <c>SubledgerJournalAccountEntryTmpDetail</c> table.
        #/// </param>
        #/// <remarks>
        #/// The event handler can transfer additional information.
        #/// </remarks>
        #delegate void loadedSubledgerJournalTmpDetail(AccountingEvent _accountingEvent, AccountingDistributionTmp _accountingDistributionTmp, SubledgerJournalAccountEntryTmpDetail _subledgerJournalAccountEntryTmpDetail)
        #{
        #}
      ENDSOURCE
      SOURCE #loadedSubledgerJourTmpDetailForAddition
        #/// <summary>
        #/// An <c>SubledgerJournalAccountEntryTmpDetail</c> record loaded event handler delegate.
        #/// </summary>
        #/// <param name="_accountingEvent">
        #/// An accounting event
        #/// </param>
        #/// <param name="_subledgerJournalAccountEntryTmpDetail">
        #/// The <c>SubledgerJournalAccountEntryTmpDetail</c> table.
        #/// </param>
        #/// <param name="_sourceDocumentLineItemTmp">
        #/// The <c>SourceDocumentLineItemTmp</c> table.
        #/// </param>
        #delegate void loadedSubledgerJourTmpDetailForAddition(
        #    AccountingEvent                         _accountingEvent,
        #    SubledgerJournalAccountEntryTmpDetail   _subledgerJournalAccountEntryTmpDetail,
        #    SourceDocumentLineItemTmp               _sourceDocumentLineItemTmp)
        #{
        #}
      ENDSOURCE
      SOURCE #loadingDistributionToTmp
        #/// <summary>
        #/// Starts loading a single distribution into the <c>AccountingDistributionTmp</c> table.
        #/// </summary>
        #delegate void loadingDistributionToTmp()
        #{
        #}
      ENDSOURCE
      SOURCE #loadReferenceDistributionInformation
        #private void loadReferenceDistributionInformation(AccountingDistributionTmpJournalize _accountingDistributionTmpJournalize)
        #{
        #    AccountingDistribution                                  accountingDistribution;
        #    SubledgerJournalAccountEntryDistribution                subledgerJournalAccountEntryDistribution;
        #    SubledgerJournalAccountEntry                            subledgerJournalAccountEntry;
        #    // <PubSect>
        #    AccountingEvent                                         accountingEventPeriodOpenClose;
        #    // </PubSect>
        #
        #    // Loop over all tmpJournalize records with a reference distribution and look up the exchange rate information
        #    while select _accountingDistributionTmpJournalize
        #        group by
        #            _accountingDistributionTmpJournalize.ReferenceDistribution,
        #            subledgerJournalAccountEntry.ExchangeRate1,
        #            subledgerJournalAccountEntry.ExchangeRate2,
        #            subledgerJournalAccountEntry.ReportingExchangeRate1,
        #            subledgerJournalAccountEntry.ReportingExchangeRate2
        #        where
        #            _accountingDistributionTmpJournalize.ReferenceDistribution != 0
        #        join SourceDocumentLine from accountingDistribution
        #            where accountingDistribution.RecId == _accountingDistributionTmpJournalize.ReferenceDistribution
        #            // ATC_AA_EQ_045 - 20171017 - Begin
        #            && accountingDistribution.SourceDocumentLine == this.parmDocumentLine()
        #            // ATC_AA_EQ_045 - 20171017 - End
        #        join RecId from subledgerJournalAccountEntryDistribution
        #            where subledgerJournalAccountEntryDistribution.AccountingDistribution == _accountingDistributionTmpJournalize.ReferenceDistribution
        #        join ExchangeRate1, ExchangeRate2, ReportingExchangeRate1, ReportingExchangeRate2 from subledgerJournalAccountEntry
        #            where subledgerJournalAccountEntry.RecId == subledgerJournalAccountEntryDistribution.SubledgerJournalAccountEntry
        #        // <PubSect>
        #        notexists join accountingEventPeriodOpenClose
        #            where accountingEventPeriodOpenClose.RecId == _accountingDistributionTmpJournalize.AccountingEvent
        #                && (accountingEventPeriodOpenClose.Type     == AccountingEventType::PeriodClose
        #                    || accountingEventPeriodOpenClose.Type  == AccountingEventType::PeriodOpen)
        #        // </PubSect>
        #    {
        #        // Exchange rate information
        #        referenceDistributionExchangeRates.insert(
        #            _accountingDistributionTmpJournalize.ReferenceDistribution, // Key of the map is the reference distribution
        #           [subledgerJournalAccountEntry.ExchangeRate1,                 // Value is the exchange rates
        #            subledgerJournalAccountEntry.ExchangeRate2,
        #            subledgerJournalAccountEntry.ReportingExchangeRate1,
        #            subledgerJournalAccountEntry.ReportingExchangeRate2]);
        #
        #        // Any records that are found require relieving
        #        relieveingRequiredSet.add(_accountingDistributionTmpJournalize.ReferenceDistribution);
        #    }
        #}
      ENDSOURCE
      SOURCE #loadRelievingDetailsExtension
        #/// <summary>
        #///   Event is called before loading relieving details records to <c>SubledgerJournalAccountEntryTmpDetail</c> table.
        #/// </summary>
        #/// <param name="_sysEventOverride">
        #///   Insertion override status.
        #/// </param>
        #/// <param name="_subledgerJournalAccountEntryTmpDetail">
        #///   <c>_subledgerJournalAccountEntryTmpDetail</c> table instance.
        #/// </param>
        #/// <param name="_relievingTmp">
        #///   <c>SubledgerJournalAccountEntryRelievingTmp</c> table instance.
        #/// </param>
        #/// <param name="_accountingEvent">
        #///   Record id of accounting event.
        #/// </param>
        #delegate void loadRelievingDetailsExtension(
        #    SysEventOverride _sysEventOverride,
        #    SubledgerJournalAccountEntryTmpDetail _subledgerJournalAccountEntryTmpDetail,
        #    SubledgerJournalAccountEntryRelievingTmp _relievingTmp,
        #    AccountingEventRecId _accountingEvent)
        #                    {
        #                    }
      ENDSOURCE
      SOURCE #loadRelievingDetailsInExtension
        #/// <summary>
        #///   Allows to override insertoin of records to <c>SubledgerJournalAccountEntryTmpDetail</c> from <c>SubledgerJournalAccountEntryRelievingTmp</c>.
        #/// </summary>
        #/// <param name="_subledgerJournalAccountEntryTmpDetail">
        #///  <c>SubledgerJournalAccountEntryTmpDetail</c> table instance.
        #/// </param>
        #/// <param name="_relievingTmp">
        #///   <c>SubledgerJournalAccountEntryRelievingTmp</c> table instance.
        #/// </param>
        #/// <param name="_accountingEvent">
        #///   Record id of accounting event.
        #/// </param>
        #/// <returns>
        #///   True, if records were inserted in extension; Otherwise, false.
        #/// </returns>
        #private boolean loadRelievingDetailsInExtension(
        #    SubledgerJournalAccountEntryTmpDetail _subledgerJournalAccountEntryTmpDetail,
        #    SubledgerJournalAccountEntryRelievingTmp _relievingTmp,
        #    AccountingEventRecId _accountingEvent)
        #                    {
        #    SysEventOverride sysEventOverride = SysEventOverride::construct();
        #
        #    this.loadRelievingDetailsExtension(sysEventOverride, _subledgerJournalAccountEntryTmpDetail, _relievingTmp, _accountingEvent);
        #
        #    return sysEventOverride.isOverridden();
        #}
      ENDSOURCE
      SOURCE #loadSourceDocumentLineItemTmp
        #private void loadSourceDocumentLineItemTmp(SourceDocument _sourceDocument, boolean _skipPeriodCloseEvent = false)
        #{
        #    SourceDocumentLineTmpJournalize         sourceDocumentLineTmpJournalize;
        #    SourceDocumentLineItem                  sourceDocumentLineItem;
        #    SourceDocumentLine                      sourceDocumentLine;
        #    AccountingDistribution                  accountingDistribution;
        #    AccountingEvent                         accountingEvent;
        #    AccountingPolicy                        accountingPolicy;
        #    AccountingEventTmp                      tmpEvent;
        #    AccountingDistributionEventTmp          tmpDistribution;
        #    AccountingEventDateTmp                  tmpEventDate;
        #    AccountingEventDateTmp                  tmpEventDate2;
        #    SourceDocumentLineImplementation        sourceDocumentLineImplementation;
        #
        #    sourceDocumentLineTmpJournalize.skipDataMethods(true);
        #
        #    if(sourceDocument)
        #    {
        #        // Fill temp accounting event
        #        insert_recordset tmpEvent (Type, State, AccountingEventRecId, AccountingDate)
        #            select Type, State, RecId, AccountingDate from accountingEvent
        #            where accountingEvent.SourceDocumentHeader == sourceDocumentHeaderRecId;
        #
        #        // Fill temp accounting distribution
        #        insert_recordset tmpDistribution (SourceDocumentLine, AccountingEvent, FinalizeAccountingEvent)
        #            select SourceDocumentLine, AccountingEvent, FinalizeAccountingEvent from accountingDistribution
        #            where accountingDistribution.SourceDocumentHeader == sourceDocumentHeaderRecId;
        #
        #        // Calculate the accounting dates for standard
        #        insert_recordset tmpEventDate (AccountingDate, SourceDocumentLine)
        #            select AccountingDate from tmpEvent
        #                group by AccountingDate
        #                where tmpEvent.State == AccountingEventState::Started &&
        #                    (!_skipPeriodCloseEvent || tmpEvent.Type != AccountingEventType::PeriodClose)
        #            join SourceDocumentLine from tmpDistribution
        #                group by SourceDocumentLine
        #                where tmpEvent.AccountingEventRecId == tmpDistribution.AccountingEvent;
        #
        #        if (mustDoFinalize)
        #        {
        #            // Calculate the accounting dates for finalized types (skip any combinations that already exist in the table)
        #            insert_recordset tmpEventDate (AccountingDate, SourceDocumentLine)
        #                select AccountingDate from tmpEvent
        #                    group by AccountingDate
        #                    where tmpEvent.Type == AccountingEventType::Finalize &&
        #                        tmpEvent.State == AccountingEventState::Started
        #                join SourceDocumentLine from tmpDistribution
        #                    group by SourceDocumentLine
        #                    where tmpEvent.AccountingEventRecId == tmpDistribution.FinalizeAccountingEvent
        #                notexists join tmpEventDate2 where
        #                    tmpEventDate2.AccountingDate == tmpEvent.AccountingDate &&
        #                    tmpEventDate2.SourceDocumentLine == tmpDistribution.SourceDocumentLine;
        #
        #        }
        #
        #        // Fill the tmp journalize
        #        insert_recordset sourceDocumentLineTmpJournalize (  IsFinal,
        #                                                            TypeEnumName,
        #                                                            TypeEnumValue,
        #                                                            Status,
        #                                                            SourceDocumentHeader,
        #                                                            ParentSourceDocumentLine,
        #                                                            SourceRelationType,
        #                                                            ExchangeRateDate,
        #                                                            SourceDocumentLine,
        #                                                            AccountingDate
        #                                                                )
        #        select  IsFinal,
        #                TypeEnumName,
        #                TypeEnumValue,
        #                AccountingStatus,
        #                SourceDocumentHeader,
        #                ParentSourceDocumentLine,
        #                SourceRelationType,
        #                ExchangeRateDate,
        #                RecId
        #        from sourceDocumentLine
        #            where sourceDocumentLine.SourceDocumentHeader == sourceDocumentHeaderRecId
        #        join AccountingDate from tmpEventDate
        #            where tmpEventDate.SourceDocumentLine == sourceDocumentLine.RecId;
        #
        #        while select sourceDocumentLineTmpJournalize
        #        join sourceDocumentLine
        #        where sourceDocumentLine.RecId == sourceDocumentLineTmpJournalize.SourceDocumentLine
        #        {
        #            sourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(sourceDocumentLine);
        #            sourceDocumentLineItemMap.insert(sourceDocumentLine.RecId, sourceDocumentLineItem);
        #
        #            sourceDocumentLineImplementation = sourceDocumentLine.getSourceDocumentLineImplementation();
        #            sourceDocumentLineItemImplMap.insert(sourceDocumentLine.RecId, sourceDocumentLineImplementation);
        #
        #            accountingPolicy = AccountingPolicy::newPolicy(sourceDocumentLineItem);
        #            accountingPolicyMap.insert(sourceDocumentLine.RecId, accountingPolicy);
        #
        #            if (accountingPolicy.parmAccountingRequired())
        #            {
        #                this.createSourceDocLineItemTmp(_sourceDocument, sourceDocumentLineItem, sourceDocumentLineTmpJournalize, accountingPolicy);
        #            }
        #        }
        #        }
        #
        #    this.setSubledgerJournalReliever(sourceDocument);
        #
        #    sourceDocument.parmSourceDocumentLinesForCurrentVoucher(sourceDocumentLineItemMap);
        #}
        #
      ENDSOURCE
      SOURCE #loadSubledgerJournalTmpDetail
        #private void loadSubledgerJournalTmpDetail(AccountingEvent _accountingEvent)
        #{
        #    AccountingDistribution              reversingAccountingDistribution;
        #    NoYes                               skipAccountValidationYes;
        #    NoYes                               skipAccountValidationNo;
        #    NoYes                               skipAccountValidation;
        #    NoYes                               isReversalYes;
        #
        #    skipAccountValidationYes = NoYes::Yes;
        #    skipAccountValidationNo = NoYes::No;
        #    skipAccountValidation = sourceDocument.parmSkipAccountValidation();
        #
        #    isReversalYes = NoYes::Yes;
        #
        #    //------------------------------------------------------------------------------------------
        #    //Standard non Intercompany Case
        #    //------------------------------------------------------------------------------------------
        #    if (_accountingEvent.Type != AccountingEventType::Finalize)
        #    {
        #        insert_recordset subledgerJournalAccountEntryTmpDetail(AccountingDistribution,
        #                                                               // <GEEU>
        #                                                               SourceAccountingDistributionTmp,
        #                                                               // </GEEU>
        #                                                               AccountingEvent,
        #                                                               AccountingDate,
        #                                                               ParentDistribution,
        #                                                               LedgerDimension,
        #                                                               PostingType,
        #                                                               TransferPolicy,
        #                                                               IsCorrection,
        #                                                               DebitCredit,
        #                                                               TransactionCurrencyAmount,
        #                                                               AccountingCurrencyAmount,
        #                                                               ReportingCurrencyAmount,
        #                                                               ExchangeRateDate,
        #                                                               HistoricalExchangeRateDate,
        #                                                               SubledgerJournalEntryType,
        #                                                               AccountingCurrencyAmountUnrounded,
        #                                                               ReportingCurrencyAmountUnrounded,
        #                                                               RoundingLevel,
        #                                                               ExchangeRate1,
        #                                                               ExchangeRate2,
        #                                                               ReportingExchangeRate1,
        #                                                               ReportingExchangeRate2,
        #                                                               FiscalCalendarPeriod,
        #                                                               TransactionCurrencyCode,
        #                                                               LegalEntity,
        #                                                               Ledger,
        #                                                               PostingLayer,
        #                                                               LedgerName,
        #                                                               AccountingCurrency,
        #                                                               ReportingCurrency,
        #                                                               SkipAccountValidation)
        #
        #          select AccountingDistribution,
        #                 // <GEEU>
        #                 RecId,
        #                 // </GEEU>
        #                 AccountingEvent,
        #                 AccountingDate,
        #                 ParentDistribution,
        #                 LedgerDimension,
        #                 PostingType,
        #                 TransferPolicy,
        #                 IsCorrection,
        #                 AmountSign,
        #                 TransactionCurrencyAmount,
        #                 SourceDocLineAccountingCurrencyAmount,
        #                 SourceDocLineReportingCurrencyAmount,
        #                 ExchangeRateDate,
        #                 HistoricalExchangeRateDate,
        #                 SubledgerJournalEntryType,
        #                 AccountingCurrencyAmountUnrounded,
        #                 ReportingCurrencyAmountUnrounded,
        #                 RoundingLevel
        #                 from accountingDistributionTmp
        #                    where accountingDistributionTmp.AccountingEvent == _accountingEvent.RecId &&
        #                          accountingDistributionTmp.ReferenceRole != AccountingDistributionReferenceRole::Reversing &&
        #                          accountingDistributionTmp.IsIntercompany == NoYes::No &&
        #                          accountingDistributionTmp.IsRelieving == NoYes::No &&
        #                          accountingDistributionTmp.IsFinalizing == NoYes::No &&
        #                          accountingDistributionTmp.IsYearEnd == NoYes::No
        #            join ExchangeRate1,
        #                 ExchangeRate2,
        #                 ReportingExchangeRate1,
        #                 ReportingExchangeRate2,
        #                 FiscalCalendarPeriod,
        #                 CurrencyCode,
        #                 LegalEntity,
        #                 Ledger,
        #                 PostingLayer,
        #                 LedgerName,
        #                 AccountingCurrency,
        #                 ReportingCurrency,
        #                 skipAccountValidation
        #                from sourceDocumentLineItemTmp
        #        where sourceDocumentLineItemTmp.SourceDocumentLine == accountingDistributionTmp.SourceDocumentLine;
        #
        #        if (hasExchangeRateVariance)
        #        {
        #            insert_recordset subledgerJournalAccountEntryTmpDetail(AccountingDistribution,
        #                                                                   // <GEEU>
        #                                                                   SourceAccountingDistributionTmp,
        #                                                                   // </GEEU>
        #                                                                   AccountingEvent,
        #                                                                   AccountingDate,
        #                                                                   ParentDistribution,
        #                                                                   LedgerDimension,
        #                                                                   PostingType,
        #                                                                   TransferPolicy,
        #                                                                   IsCorrection,
        #                                                                   DebitCredit,
        #                                                                   TransactionCurrencyAmount,
        #                                                                   AccountingCurrencyAmount,
        #                                                                   ReportingCurrencyAmount,
        #                                                                   ExchangeRateDate,
        #                                                                   SubledgerJournalEntryType,
        #                                                                   ExchangeRate1,
        #                                                                   ExchangeRate2,
        #                                                                   ReportingExchangeRate1,
        #                                                                   ReportingExchangeRate2,
        #                                                                   FiscalCalendarPeriod,
        #                                                                   TransactionCurrencyCode,
        #                                                                   LegalEntity,
        #                                                                   Ledger,
        #                                                                   PostingLayer,
        #                                                                   LedgerName,
        #                                                                   AccountingCurrency,
        #                                                                   ReportingCurrency,
        #                                                                   SkipAccountValidation)
        #
        #              select ervAccountingDistribution,
        #                     // <GEEU>
        #                     RecId,
        #                     // </GEEU>
        #                     AccountingEvent,
        #                     AccountingDate,
        #                     ParentDistribution,
        #                     ervLedgerDimension,
        #                     ervPostingType,
        #                     TransferPolicy,
        #                     IsCorrection,
        #                     ervAmountSign,
        #                     ervTransactionCurrencyAmount,
        #                     ervAccountingCurrencyAmount,
        #                     ervReportingCurrencyAmount,
        #                     ExchangeRateDate,
        #                     SubledgerJournalEntryType,
        #                     ervExchangeRate1,
        #                     ervExchangeRate2,
        #                     ervReportingExchangeRate1,
        #                     ervReportingExchangeRate2
        #                     from accountingDistributionTmp
        #                        where accountingDistributionTmp.AccountingEvent == _accountingEvent.RecId &&
        #                              accountingDistributionTmp.ReferenceRole != AccountingDistributionReferenceRole::Reversing &&
        #                              accountingDistributionTmp.IsIntercompany == NoYes::No &&
        #                              accountingDistributionTmp.IsRelieving == NoYes::No &&
        #                              accountingDistributionTmp.IsFinalizing == NoYes::No &&
        #                              accountingDistributionTmp.IsYearEnd == NoYes::No &&
        #                              accountingDistributionTmp.IsExchangeRateVariance == NoYes::Yes &&
        #                              (accountingDistributionTmp.ervAccountingCurrencyAmount != 0 ||
        #                               accountingDistributionTmp.ervReportingCurrencyAmount != 0)
        #                join
        #                     FiscalCalendarPeriod,
        #                     CurrencyCode,
        #                     LegalEntity,
        #                     Ledger,
        #                     PostingLayer,
        #                     LedgerName,
        #                     AccountingCurrency,
        #                     ReportingCurrency,
        #                     skipAccountValidationNo
        #                   from sourceDocumentLineItemTmp
        #            where sourceDocumentLineItemTmp.SourceDocumentLine == accountingDistributionTmp.SourceDocumentLine;
        #        }
        #
        #        select firstonly RecId from reversingAccountingDistribution
        #            where reversingAccountingDistribution.AccountingEvent == _accountingEvent.RecId &&
        #            reversingAccountingDistribution.ReferenceRole == AccountingDistributionReferenceRole::Reversing;
        #
        #        if(reversingAccountingDistribution)
        #        {
        #
        #            //------------------------------------------------------------------------------------------
        #            //Reversal Case
        #            //------------------------------------------------------------------------------------------
        #            insert_recordset subledgerJournalAccountEntryTmpDetail (AccountingDistribution,
        #                                                                    // <GEEU>
        #                                                                    SourceAccountingDistributionTmp,
        #                                                                    // </GEEU>
        #                                                                    AccountingEvent,
        #                                                                    AccountingDate,
        #                                                                    TransactionCurrencyCode,
        #                                                                    AccountingCurrency,
        #                                                                    ReportingCurrency,
        #                                                                    LedgerDimension,
        #                                                                    PostingType,
        #                                                                    TransferPolicy,
        #                                                                    IsCorrection,
        #                                                                    DebitCredit,
        #                                                                    TransactionCurrencyAmount,
        #                                                                    AccountingCurrencyAmount,
        #                                                                    ReportingCurrencyAmount,
        #                                                                    LegalEntity,
        #                                                                    ExchangeRateDate,
        #                                                                    ExchangeRate1,
        #                                                                    ExchangeRate2,
        #                                                                    ReportingExchangeRate1,
        #                                                                    ReportingExchangeRate2,
        #                                                                    FiscalCalendarPeriod,
        #                                                                    Ledger,
        #                                                                    PostingLayer,
        #                                                                    SubledgerJournalEntryType,
        #                                                                    SkipAccountValidation,
        #                                                                    IsReversal)
        #
        #            select AccountingDistribution,
        #                // <GEEU>
        #                RecId,
        #                // </GEEU>
        #                AccountingEvent,
        #                AccountingDate,
        #                TransactionCurrency,
        #                AccountingCurrency,
        #                ReportingCurrency,
        #                LedgerDimension,
        #                PostingType,
        #                TransferPolicy,
        #                IsCorrection,
        #                AmountSign,
        #                TransactionCurrencyAmount,
        #                AccountingCurrencyAmount,
        #                ReportingCurrencyAmount,
        #                LegalEntity,
        #                ExchangeRateDate,
        #                ExchangeRate1,
        #                ExchangeRate2,
        #                ReportingExchangeRate1,
        #                ReportingExchangeRate2,
        #                FiscalCalendarPeriod,
        #                Ledger
        #            from accountingDistributionTmp
        #                where accountingDistributionTmp.AccountingEvent == _accountingEvent.RecId &&
        #                    accountingDistributionTmp.ReferenceRole == AccountingDistributionReferenceRole::Reversing
        #            join PostingLayer,
        #                SubledgerJournalEntryType,
        #                skipAccountValidationYes,
        #                isReversalYes
        #            from sourceDocumentLineItemTmp
        #                where sourceDocumentLineItemTmp.SourceDocumentLine == accountingDistributionTmp.SourceDocumentLine;
        #        }
        #        if(hasInterCompany)
        #        {
        #            //------------------------------------------------------------------------------------------
        #            //InterCompany Case
        #            //------------------------------------------------------------------------------------------
        #            //Insert Dr side based on Distribution
        #            insert_recordset subledgerJournalAccountEntryTmpDetail(AccountingDistribution,
        #                                                                   // <GEEU>
        #                                                                   SourceAccountingDistributionTmp,
        #                                                                   // </GEEU>
        #                                                                   AccountingEvent,
        #                                                                   AccountingDate,
        #                                                                   ParentDistribution,
        #                                                                   TransactionCurrencyCode,
        #                                                                   LedgerDimension,
        #                                                                   PostingType,
        #                                                                   TransferPolicy,
        #                                                                   DebitCredit,
        #                                                                   TransactionCurrencyAmount,
        #                                                                   AccountingCurrencyAmount,
        #                                                                   ReportingCurrencyAmount,
        #                                                                   ExchangeRateDate,
        #                                                                   ExchangeRate1,
        #                                                                   ReportingExchangeRate1,
        #                                                                   ExchangeRate2,
        #                                                                   ReportingExchangeRate2,
        #                                                                   FiscalCalendarPeriod,
        #                                                                   LegalEntity,
        #                                                                   Ledger,
        #                                                                   LedgerName,
        #                                                                   AccountingCurrency,
        #                                                                   ReportingCurrency,
        #                                                                   PostingLayer,
        #                                                                   SubledgerJournalEntryType,
        #                                                                   SkipAccountValidation)
        #            select AccountingDistribution,
        #                 // <GEEU>
        #                 RecId,
        #                 // </GEEU>
        #                 AccountingEvent,
        #                 AccountingDate,
        #                 ParentDistribution,
        #                 TransactionCurrency,
        #                 LedgerDimension,
        #                 PostingType,
        #                 TransferPolicy,
        #                 AmountSign,
        #                 TransactionCurrencyAmount,
        #                 AccountingCurrencyAmount,
        #                 ReportingCurrencyAmount,
        #                 ExchangeRateDate,
        #                 ExchangeRate1,
        #                 ReportingExchangeRate1,
        #                 ExchangeRate2,
        #                 ReportingExchangeRate2,
        #                 FiscalCalendarPeriod,
        #                 LegalEntity,
        #                 Ledger,
        #                 LedgerName,
        #                 AccountingCurrency,
        #                 ReportingCurrency
        #                 from accountingDistributionTmp
        #                    where accountingDistributionTmp.AccountingEvent == _accountingEvent.RecId &&
        #                          accountingDistributionTmp.ReferenceRole != AccountingDistributionReferenceRole::Reversing &&
        #                          accountingDistributionTmp.Offset == NoYes::No &&
        #                          accountingDistributionTmp.IsIntercompany == NoYes::Yes
        #            join PostingLayer,
        #                 SubledgerJournalEntryType,
        #                 skipAccountValidationNo
        #                from sourceDocumentLineItemTmp
        #            where sourceDocumentLineItemTmp.SourceDocumentLine == accountingDistributionTmp.SourceDocumentLine;
        #
        #            //Insert Cr side for the DueTo based on distribution
        #            insert_recordset subledgerJournalAccountEntryTmpDetail(AccountingDistribution,
        #                                                                   // <GEEU>
        #                                                                   SourceAccountingDistributionTmp,
        #                                                                   // </GEEU>
        #                                                                   AccountingEvent,
        #                                                                   AccountingDate,
        #                                                                   ParentDistribution,
        #                                                                   TransactionCurrencyCode,
        #                                                                   LedgerDimension,
        #                                                                   PostingType,
        #                                                                   TransferPolicy,
        #                                                                   DebitCredit,
        #                                                                   TransactionCurrencyAmount,
        #                                                                   AccountingCurrencyAmount,
        #                                                                   ReportingCurrencyAmount,
        #                                                                   ExchangeRateDate,
        #                                                                   ExchangeRate1,
        #                                                                   ReportingExchangeRate1,
        #                                                                   ExchangeRate2,
        #                                                                   ReportingExchangeRate2,
        #                                                                   FiscalCalendarPeriod,
        #                                                                   LegalEntity,
        #                                                                   Ledger,
        #                                                                   LedgerName,
        #                                                                   AccountingCurrency,
        #                                                                   ReportingCurrency,
        #                                                                   PostingLayer,
        #                                                                   SubledgerJournalEntryType,
        #                                                                   SkipAccountValidation)
        #              select AccountingDistribution,
        #                     // <GEEU>
        #                     RecId,
        #                     // </GEEU>
        #                     AccountingEvent,
        #                     AccountingDate,
        #                     ParentDistribution,
        #                     TransactionCurrency,
        #                     DueToLedgerDimension,
        #                     InterCompanyPostingType,
        #                     TransferPolicy,
        #                     AmountSign,
        #                     TransactionCurrencyAmount,
        #                     AccountingCurrencyAmount,
        #                     ReportingCurrencyAmount,
        #                     ExchangeRateDate,
        #                     ExchangeRate1,
        #                     ReportingExchangeRate1,
        #                     ExchangeRate2,
        #                     ReportingExchangeRate2,
        #                     FiscalCalendarPeriod,
        #                     LegalEntity,
        #                     Ledger,
        #                     LedgerName,
        #                     AccountingCurrency,
        #                     ReportingCurrency
        #                     from accountingDistributionTmp
        #                        where accountingDistributionTmp.AccountingEvent == _accountingEvent.RecId &&
        #                              accountingDistributionTmp.ReferenceRole != AccountingDistributionReferenceRole::Reversing &&
        #                              accountingDistributionTmp.Offset == NoYes::Yes &&
        #                              accountingDistributionTmp.IsIntercompany == NoYes::Yes
        #                join PostingLayer,
        #                     SubledgerJournalEntryType,
        #                     skipAccountValidationNo
        #                from sourceDocumentLineItemTmp
        #                where sourceDocumentLineItemTmp.SourceDocumentLine == accountingDistributionTmp.SourceDocumentLine;
        #
        #            //insert dr due from case based on line:
        #            insert_recordset subledgerJournalAccountEntryTmpDetail(AccountingDistribution,
        #                                                                   // <GEEU>
        #                                                                   SourceAccountingDistributionTmp,
        #                                                                   // </GEEU>
        #                                                                   AccountingEvent,
        #                                                                   AccountingDate,
        #                                                                   ParentDistribution,
        #                                                                   LedgerDimension,
        #                                                                   PostingType,
        #                                                                   TransferPolicy,
        #                                                                   DebitCredit,
        #                                                                   TransactionCurrencyAmount,
        #                                                                   AccountingCurrencyAmount,
        #                                                                   ReportingCurrencyAmount,
        #                                                                   ExchangeRateDate,
        #                                                                   ExchangeRate1,
        #                                                                   ReportingExchangeRate1,
        #                                                                   ExchangeRate2,
        #                                                                   ReportingExchangeRate2,
        #                                                                   FiscalCalendarPeriod,
        #                                                                   TransactionCurrencyCode,
        #                                                                   LegalEntity,
        #                                                                   Ledger,
        #                                                                   LedgerName,
        #                                                                   AccountingCurrency,
        #                                                                   ReportingCurrency,
        #                                                                   PostingLayer,
        #                                                                   SubledgerJournalEntryType,
        #                                                                   SkipAccountValidation)
        #              select AccountingDistribution,
        #                     // <GEEU>
        #                     RecId,
        #                     // </GEEU>
        #                     AccountingEvent,
        #                     AccountingDate,
        #                     ParentDistribution,
        #                     DueFromLedgerDimension,
        #                     InterCompanyPostingType,
        #                     TransferPolicy,
        #                     AmountSign,
        #                     TransactionCurrencyAmount,
        #                     SourceDocLineAccountingCurrencyAmount,
        #                     SourceDocLineReportingCurrencyAmount
        #                from accountingDistributionTmp
        #                where accountingDistributionTmp.AccountingEvent == _accountingEvent.RecId &&
        #                      accountingDistributionTmp.ReferenceRole != AccountingDistributionReferenceRole::Reversing &&
        #                      accountingDistributionTmp.Offset == NoYes::No &&
        #                      accountingDistributionTmp.IsIntercompany == NoYes::Yes
        #                join ExchangeRateDate,
        #                     ExchangeRate1,
        #                     ReportingExchangeRate1,
        #                     ExchangeRate2,
        #                     ReportingExchangeRate2,
        #                     FiscalCalendarPeriod,
        #                     CurrencyCode,
        #                     LegalEntity,
        #                     Ledger,
        #                     LedgerName,
        #                     AccountingCurrency,
        #                     ReportingCurrency,
        #                     PostingLayer,
        #                     SubledgerJournalEntryType,
        #                     skipAccountValidationNo
        #                    from sourceDocumentLineItemTmp
        #                where sourceDocumentLineItemTmp.SourceDocumentLine == accountingDistributionTmp.SourceDocumentLine;
        #
        #            //insert cr due from case based on line:
        #            insert_recordset subledgerJournalAccountEntryTmpDetail(AccountingDistribution,
        #                                                                   // <GEEU>
        #                                                                   SourceAccountingDistributionTmp,
        #                                                                   // </GEEU>
        #                                                                   AccountingEvent,
        #                                                                   AccountingDate,
        #                                                                   ParentDistribution,
        #                                                                   LedgerDimension,
        #                                                                   PostingType,
        #                                                                   TransferPolicy,
        #                                                                   DebitCredit,
        #                                                                   TransactionCurrencyAmount,
        #                                                                   AccountingCurrencyAmount,
        #                                                                   ReportingCurrencyAmount,
        #                                                                   ExchangeRateDate,
        #                                                                   ExchangeRate1,
        #                                                                   ReportingExchangeRate1,
        #                                                                   ExchangeRate2,
        #                                                                   ReportingExchangeRate2,
        #                                                                   FiscalCalendarPeriod,
        #                                                                   TransactionCurrencyCode,
        #                                                                   LegalEntity,
        #                                                                   Ledger,
        #                                                                   LedgerName,
        #                                                                   AccountingCurrency,
        #                                                                   ReportingCurrency,
        #                                                                   PostingLayer,
        #                                                                   SubledgerJournalEntryType,
        #                                                                   SkipAccountValidation)
        #             select AccountingDistribution,
        #                    // <GEEU>
        #                    RecId,
        #                    // </GEEU>
        #                    AccountingEvent,
        #                    AccountingDate,
        #                    ParentDistribution,
        #                    LedgerDimension,
        #                    PostingType,
        #                    TransferPolicy,
        #                    AmountSign,
        #                    TransactionCurrencyAmount,
        #                    SourceDocLineAccountingCurrencyAmount,
        #                    SourceDocLineReportingCurrencyAmount
        #                from accountingDistributionTmp
        #                where accountingDistributionTmp.AccountingEvent == _accountingEvent.RecId &&
        #                      accountingDistributionTmp.ReferenceRole != AccountingDistributionReferenceRole::Reversing &&
        #                      accountingDistributionTmp.Offset == NoYes::Yes &&
        #                      accountingDistributionTmp.IsIntercompany == NoYes::Yes
        #                join ExchangeRateDate,
        #                     ExchangeRate1,
        #                     ReportingExchangeRate1,
        #                     ExchangeRate2,
        #                     ReportingExchangeRate2,
        #                     FiscalCalendarPeriod,
        #                     CurrencyCode,
        #                     LegalEntity,
        #                     Ledger,
        #                     LedgerName,
        #                     AccountingCurrency,
        #                     ReportingCurrency,
        #                     PostingLayer,
        #                     SubledgerJournalEntryType,
        #                     skipAccountValidationNo
        #                    from sourceDocumentLineItemTmp
        #                where sourceDocumentLineItemTmp.SourceDocumentLine == accountingDistributionTmp.SourceDocumentLine;
        #        }
        #
        #        if(hasRelieving)
        #        {
        #            //------------------------------------------------------------------------------------------
        #            //Relieving Case
        #            //------------------------------------------------------------------------------------------
        #            insert_recordset subledgerJournalAccountEntryTmpDetail (AccountingDistribution,
        #                                                                    // <GEEU>
        #                                                                    SourceAccountingDistributionTmp,
        #                                                                    // </GEEU>
        #                                                                    AccountingEvent,
        #                                                                    AccountingDate,
        #                                                                    TransactionCurrencyCode,
        #                                                                    AccountingCurrency,
        #                                                                    ReportingCurrency,
        #                                                                    LedgerDimension,
        #                                                                    PostingType,
        #                                                                    TransferPolicy,
        #                                                                    IsCorrection,
        #                                                                    DebitCredit,
        #                                                                    TransactionCurrencyAmount,
        #                                                                    AccountingCurrencyAmount,
        #                                                                    ReportingCurrencyAmount,
        #                                                                    LegalEntity,
        #                                                                    ExchangeRateDate,
        #                                                                    ExchangeRate1,
        #                                                                    ReportingExchangeRate1,
        #                                                                    ExchangeRate2,
        #                                                                    ReportingExchangeRate2,
        #                                                                    FiscalCalendarPeriod,
        #                                                                    Ledger,
        #                                                                    SubledgerJournalEntryType,
        #                                                                    PostingLayer,
        #                                                                    SkipAccountValidation,
        #                                                                    IsReversal)
        #         select AccountingDistribution,
        #                // <GEEU>
        #                RecId,
        #                // </GEEU>
        #                AccountingEvent,
        #                AccountingDate,
        #                TransactionCurrency,
        #                AccountingCurrency,
        #                ReportingCurrency,
        #                LedgerDimension,
        #                PostingType,
        #                TransferPolicy,
        #                IsCorrection,
        #                AmountSign,
        #                TransactionCurrencyAmount,
        #                AccountingCurrencyAmount,
        #                ReportingCurrencyAmount,
        #                LegalEntity,
        #                ExchangeRateDate,
        #                ExchangeRate1,
        #                ReportingExchangeRate1,
        #                ExchangeRate2,
        #                ReportingExchangeRate2,
        #                FiscalCalendarPeriod,
        #                Ledger,
        #                RelievingSubledgerJournalEntryType
        #            from accountingDistributionTmp
        #                where accountingDistributionTmp.AccountingEvent == _accountingEvent.RecId &&
        #                      accountingDistributionTmp.IsRelieving == NoYes::Yes &&
        #                      accountingDistributionTmp.IsFinalizing == NoYes::No &&
        #                      accountingDistributionTmp.IsYearEnd == NoYes::No
        #            join PostingLayer,
        #                 skipAccountValidationYes,
        #                 isReversalYes //reversal/relieving: relieving entries should be treated like reversals for rounding, interunit
        #            from sourceDocumentLineItemTmp
        #                where sourceDocumentLineItemTmp.SourceDocumentLine == accountingDistributionTmp.SourceDocumentLine;
        #        }
        #        if(hasYearEnd)
        #        {
        #
        #            //------------------------------------------------------------------------------------------
        #            //Year End Case
        #            //------------------------------------------------------------------------------------------
        #            insert_recordset subledgerJournalAccountEntryTmpDetail (AccountingDistribution,
        #                                                                    // <GEEU>
        #                                                                    SourceAccountingDistributionTmp,
        #                                                                    // </GEEU>
        #                                                                    AccountingEvent,
        #                                                                    AccountingDate,
        #                                                                    TransactionCurrencyCode,
        #                                                                    AccountingCurrency,
        #                                                                    ReportingCurrency,
        #                                                                    LedgerDimension,
        #                                                                    PostingType,
        #                                                                    TransferPolicy,
        #                                                                    IsCorrection,
        #                                                                    DebitCredit,
        #                                                                    TransactionCurrencyAmount,
        #                                                                    AccountingCurrencyAmount,
        #                                                                    ReportingCurrencyAmount,
        #                                                                    LegalEntity,
        #                                                                    ExchangeRateDate,
        #                                                                    ExchangeRate1,
        #                                                                    ReportingExchangeRate1,
        #                                                                    ExchangeRate2,
        #                                                                    ReportingExchangeRate2,
        #                                                                    FiscalCalendarPeriod,
        #                                                                    Ledger,
        #                                                                    SubledgerJournalEntryType,
        #                                                                    PostingLayer,
        #                                                                    SkipAccountValidation)
        #         select AccountingDistribution,
        #                // <GEEU>
        #                RecId,
        #                // </GEEU>
        #                AccountingEvent,
        #                AccountingDate,
        #                TransactionCurrency,
        #                AccountingCurrency,
        #                ReportingCurrency,
        #                LedgerDimension,
        #                PostingType,
        #                TransferPolicy,
        #                IsCorrection,
        #                AmountSign,
        #                TransactionCurrencyAmount,
        #                AccountingCurrencyAmount,
        #                ReportingCurrencyAmount,
        #                LegalEntity,
        #                ExchangeRateDate,
        #                ExchangeRate1,
        #                ReportingExchangeRate1,
        #                ExchangeRate2,
        #                ReportingExchangeRate2,
        #                FiscalCalendarPeriod,
        #                Ledger,
        #                YearEndReversalSubledgerJournalEntryType
        #            from accountingDistributionTmp
        #                where accountingDistributionTmp.AccountingEvent == _accountingEvent.RecId &&
        #                      accountingDistributionTmp.IsRelieving == NoYes::No &&
        #                      accountingDistributionTmp.IsFinalizing == NoYes::No &&
        #                      accountingDistributionTmp.IsYearEnd == NoYes::Yes
        #            join PostingLayer,
        #                 skipAccountValidationNo
        #            from sourceDocumentLineItemTmp
        #                where sourceDocumentLineItemTmp.SourceDocumentLine == accountingDistributionTmp.SourceDocumentLine;
        #        }
        #    }
        #    else
        #    {
        #
        #        if(hasFinalizing)
        #        {
        #
        #            //------------------------------------------------------------------------------------------
        #            //Finalizing Case
        #            //------------------------------------------------------------------------------------------
        #            insert_recordset subledgerJournalAccountEntryTmpDetail (AccountingDistribution,
        #                                                                    // <GEEU>
        #                                                                    SourceAccountingDistributionTmp,
        #                                                                    // </GEEU>
        #                                                                    AccountingEvent,
        #                                                                    AccountingDate,
        #                                                                    TransactionCurrencyCode,
        #                                                                    AccountingCurrency,
        #                                                                    ReportingCurrency,
        #                                                                    LedgerDimension,
        #                                                                    PostingType,
        #                                                                    TransferPolicy,
        #                                                                    IsCorrection,
        #                                                                    DebitCredit,
        #                                                                    TransactionCurrencyAmount,
        #                                                                    AccountingCurrencyAmount,
        #                                                                    ReportingCurrencyAmount,
        #                                                                    LegalEntity,
        #                                                                    ExchangeRateDate,
        #                                                                    ExchangeRate1,
        #                                                                    ReportingExchangeRate1,
        #                                                                    ExchangeRate2,
        #                                                                    ReportingExchangeRate2,
        #                                                                    FiscalCalendarPeriod,
        #                                                                    Ledger,
        #                                                                    PostingLayer,
        #                                                                    SubledgerJournalEntryType,
        #                                                                    SkipAccountValidation)
        #         select AccountingDistribution,
        #                // <GEEU>
        #                RecId,
        #                // </GEEU>
        #                FinalizeAccountingEvent,
        #                AccountingDate,
        #                TransactionCurrency,
        #                AccountingCurrency,
        #                ReportingCurrency,
        #                LedgerDimension,
        #                PostingType,
        #                TransferPolicy,
        #                IsCorrection,
        #                AmountSign,
        #                TransactionCurrencyAmount,
        #                AccountingCurrencyAmount,
        #                ReportingCurrencyAmount,
        #                LegalEntity,
        #                ExchangeRateDate,
        #                ExchangeRate1,
        #                ReportingExchangeRate1,
        #                ExchangeRate2,
        #                ReportingExchangeRate2,
        #                FiscalCalendarPeriod,
        #                Ledger
        #            from accountingDistributionTmp
        #                where accountingDistributionTmp.FinalizeAccountingEvent == _accountingEvent.RecId &&
        #                      accountingDistributionTmp.IsFinalizing == NoYes::Yes &&
        #                      accountingDistributionTmp.IsRelieving == NoYes::No &&
        #                      accountingDistributionTmp.IsYearEnd == NoYes::No
        #            join PostingLayer,
        #                SubledgerJournalEntryType,
        #                skipAccountValidationYes
        #            from sourceDocumentLineItemTmp
        #                where sourceDocumentLineItemTmp.SourceDocumentLine == accountingDistributionTmp.SourceDocumentLine;
        #        }
        #    }
        #
        #    // <GEEU>
        #    this.loadedSubledgerJournalTmpDetail(_accountingEvent, accountingDistributionTmp, subledgerJournalAccountEntryTmpDetail);
        #    // </GEEU>
        #    // <GEEU>
        #    this.loadedSubledgerJourTmpDetailForAddition(_accountingEvent, subledgerJournalAccountEntryTmpDetail, sourceDocumentLineItemTmp);
        #    // </GEEU>
        #
        #    if (this.canPerformDetailRoundingAdjustment(sourceDocument))
        #    {
        #        this.performDetailLevelRoundingAdjustment(sourceDocument, subledgerJournalAccountEntryTmpDetail);
        #    }
        #    else
        #    {
        #        this.roundSubledgerJournalTmpDetail();
        #    }
        #
        #    this.balanceSubledgerJournalEntryTmpInterunit();
        #}
      ENDSOURCE
      SOURCE #loadSubledgerJourTmpDetailWithRelieving
        #/// <summary>
        #/// Transfer entries that need to be relieved from subledgerJournalAccountEntryRelievingTmp to subledgerJournalAccountEntryTmpDetail
        #/// </summary>
        #/// <param name="_accountingEvent">
        #/// AccouningEvent
        #/// </param>
        #
        #private void loadSubledgerJourTmpDetailWithRelieving(AccountingEvent _accountingEvent)
        #{
        #    NoYes skipAccountValidationYes = NoYes::Yes;
        #
        #    //<GEEU>
        #    if (!this.loadRelievingDetailsInExtension(
        #        subledgerJournalAccountEntryTmpDetail,
        #        subledgerJournalAccountEntryRelievingTmp,
        #        _accountingEvent.RecId))
        #    {
        #    //</GEEU>
        #    insert_recordset subledgerJournalAccountEntryTmpDetail (SkipAccountValidation,
        #                                                            AccountingCurrencyAmount,
        #                                                            AccountingDate,
        #                                                            AccountingEvent,
        #                                                            ExchangeRate1,
        #                                                            ExchangeRate2,
        #                                                            ExchangeRateDate,
        #                                                            HistoricalExchangeRateDate,
        #                                                            IsCorrection,
        #                                                            LedgerDimension,
        #                                                            PostingType,
        #                                                            ReportingCurrencyAmount,
        #                                                            ReportingExchangeRate1,
        #                                                            TransactionCurrencyAmount,
        #                                                            DebitCredit,
        #                                                            TransactionCurrencyCode,
        #                                                            TransferPolicy,
        #                                                            LegalEntity,
        #                                                            AccountingCurrency,
        #                                                            ReportingCurrency,
        #                                                            FiscalCalendarPeriod,
        #                                                            PostingLayer,
        #                                                            LedgerName,
        #                                                            Ledger,
        #                                                            SubledgerJournalEntryType)
        #                select SkipAccountValidationYes,
        #                    AccountingCurrencyAmount,
        #                    DependentAccountingDate,
        #                    AccountingEvent,
        #                    ExchangeRate1,
        #                    ExchangeRate2,
        #                    ExchangeRateDate,
        #                    HistoricalExchangeRateDate,
        #                    IsCorrection,
        #                    LedgerDimension,
        #                    PostingType,
        #                    ReportingCurrencyAmount,
        #                    ReportingExchangeRate1,
        #                    TransactionCurrencyAmount,
        #                    Side,
        #                    TransactionCurrency,
        #                    OriginalTransferPolicy,
        #                    LegalEntity,
        #                    AccountingCurrency,
        #                    ReportingCurrency,
        #                    FiscalCalendarPeriod,
        #                    PostingLayer,
        #                    LedgerName,
        #                    Ledger,
        #                    SubledgerJournalEntryType
        #                from subledgerJournalAccountEntryRelievingTmp
        #                    where subledgerJournalAccountEntryRelievingTmp.AccountingEvent == _accountingEvent.RecId;
        #    //<GEEU>
        #    }
        #    //</GEEU>
        #}
      ENDSOURCE
      SOURCE #logDebitCreditBalanceErrors
        #private void logDebitCreditBalanceErrors(Voucher _voucher, AccountingEventRecId _accountingEventRecId, AccountingDate _accountingDate, AmountMST _accountingCurrencyAmount, AmountMSTSecondary _reportingCurrencyAmount)
        #{
        #    this.addToSubledgerJournalErrorLog(_accountingEventRecId, Exception::Warning, literalStr("@SYS70033"),
        #                                [_voucher, _accountingDate, _accountingCurrencyAmount, _reportingCurrencyAmount]);
        #
        #    checkFailed(strFmt("@SYS70033", _voucher, _accountingDate, _accountingCurrencyAmount, _reportingCurrencyAmount));
        #}
      ENDSOURCE
      SOURCE #markReferenceIdentityStatus
        #/// <summary>
        #/// Determines which reference identity transfer mode to mark a subledger journal entry
        #/// </summary>
        #/// <returns>
        #/// The reference identity transfer mode to use
        #/// </returns>
        #private ReferenceIdentityTransferStatus markReferenceIdentityStatus()
        #{
        #    ReferenceIdentityTransferStatus     referenceIdentityTransferStatus;
        #
        #    if (sourceDocument.parmSourceDocumentType().parmReferenceIdentityDocument())
        #    {
        #        referenceIdentityTransferStatus = ReferenceIdentityTransferStatus::ReadyForTransfer;
        #    }
        #    else
        #    {
        #        referenceIdentityTransferStatus = ReferenceIdentityTransferStatus::DoNotTransfer;
        #    }
        #
        #    return referenceIdentityTransferStatus;
        #}
      ENDSOURCE
      SOURCE #new
        #protected void new()
        #{
        #}
      ENDSOURCE
      SOURCE #parmCaller
        #public SourceDocumentProcessorCaller parmCaller()
        #{
        #    return caller;
        #}
      ENDSOURCE
      SOURCE #parmSourceDocument
        #public SourceDocument parmSourceDocument()
        #{
        #    return sourceDocument;
        #}
        #
      ENDSOURCE
      SOURCE #performDetailLevelRoundingAdjustment
        #private void performDetailLevelRoundingAdjustment(
        #    SourceDocument _sourceDocument,
        #    SubledgerJournalAccountEntryTmpDetail _tmpDetail)
        #{
        #    SubledgerJourDetailRoundingAdjuster detailRoundingAdjuster;
        #    SubledgerJourIDetailRoundingAdjustEntry detailRoundingAdjustmentEntry;
        #    SubledgerJournalAccountEntryTmpDetail tmpDetailCopy;
        #
        #    detailRoundingAdjuster = SubledgerJourDetailRoundingAdjuster::newFromDocument(_sourceDocument);
        #    detailRoundingAdjustmentEntry = SubledgerJourDetailRoundingAdjustEntry::newFromTmpDetail(_tmpDetail);
        #
        #    // Get a copy of the tmp detail table to avoid adjuster making direct modifications to the table.
        #    // The SubledgerJourDetailRoundingAdjustEntry object will be responsible for making modifications to tmp detail table.
        #    tmpDetailCopy = _tmpDetail.getCopy();
        #
        #    detailRoundingAdjuster.performAdjustment(tmpDetailCopy, detailRoundingAdjustmentEntry);
        #}
      ENDSOURCE
      SOURCE #performSubledgerAllocation
        #private void performSubledgerAllocation(SubledgerJournalAccountEntryTmpSummary _subledgerJournalAccountEntryTmpSummary)
        #{
        #    SubledgerJournalizerExtensionArgs subledgerJournalizerExtensionArgs = SubledgerJournalizerExtensionArgs::construct();
        #    SubledgerAllocator subledgerAllocator = new SubledgerAllocator();
        #
        #    subledgerJournalizerExtensionArgs.parmSubledgerJournalAccEntryTmpSummary(_subledgerJournalAccountEntryTmpSummary);
        #
        #    this.subledgerAllocating(subledgerJournalizerExtensionArgs);
        #
        #    subledgerAllocator.applyAllocationsToSubledgerJournalTmp(_subledgerJournalAccountEntryTmpSummary);
        #
        #    this.subledgerAllocated(subledgerJournalizerExtensionArgs);
        #}
      ENDSOURCE
      SOURCE #performSummaryLevelRoundingAdjustment
        #private void performSummaryLevelRoundingAdjustment(
        #    SourceDocument _sourceDocument,
        #    SubledgerJournalAccountEntryTmpSummary _tmpSummary)
        #{
        #    SubledgerJourSummaryRoundingAdjuster summaryRoundingAdjuster;
        #    SubledgerJourISummaryRoundingAdjustEntry summaryRoundingAdjustmentEntry;
        #    SubledgerJournalAccountEntryTmpSummary tmpSummaryCopy;
        #
        #    summaryRoundingAdjuster = SubledgerJourSummaryRoundingAdjuster::newFromDocument(_sourceDocument);
        #    summaryRoundingAdjustmentEntry = SubledgerJourSummaryRoundingAdjustEntry::newFromTmpSummary(_tmpSummary);
        #
        #    // Get a copy of the tmp summary table to avoid adjuster making direct modifications to the table.
        #    // The SubledgerJourSummaryRoundingAdjustEntry object will be responsible for making modifications to tmpSummary table.
        #    tmpSummaryCopy = _tmpSummary.getCopy();
        #
        #    summaryRoundingAdjuster.performAdjustment(tmpSummaryCopy, summaryRoundingAdjustmentEntry);
        #}
      ENDSOURCE
      SOURCE #previewLoadSourceDocLineItemTmp
        #private void previewLoadSourceDocLineItemTmp(SourceDocument _sourceDocument)
        #{
        #    SourceDocumentLineTmpJournalize         sourceDocumentLineTmpJournalize;
        #    SourceDocumentLineItem                  sourceDocumentLineItem;
        #    SourceDocumentLine                      sourceDocumentLine;
        #    AccountingDistribution                  accountingDistribution;
        #    AccountingPolicy                        accountingPolicy;
        #    SourceDocumentLineTmpRelation           sourceDocumentLineTmpRelation;
        #
        #    sourceDocumentLineTmpJournalize.skipDataMethods(true);
        #
        #    if(sourceDocument)
        #    {
        #        insert_recordset sourceDocumentLineTmpJournalize (  IsFinal,
        #                                                            TypeEnumName,
        #                                                            TypeEnumValue,
        #                                                            Status,
        #                                                            SourceDocumentHeader,
        #                                                            ParentSourceDocumentLine,
        #                                                            SourceRelationType,
        #                                                            SourceDocumentLine,
        #                                                            ExchangeRateDate
        #                                                                )
        #        select  IsFinal,
        #                TypeEnumName,
        #                TypeEnumValue,
        #                AccountingStatus,
        #                SourceDocumentHeader,
        #                ParentSourceDocumentLine,
        #                SourceRelationType,
        #                RecId,
        #                ExchangeRateDate
        #        from sourceDocumentLine
        #            where sourceDocumentLine.SourceDocumentHeader == sourceDocumentHeaderRecId
        #            exists join accountingDistribution
        #                where accountingDistribution.SourceDocumentLine == sourceDocumentLine.RecId
        #                &&  accountingDistribution.AccountingEvent == 0;
        #
        #        while select sourceDocumentLineTmpJournalize
        #        join sourceDocumentLine
        #        where sourceDocumentLine.RecId == sourceDocumentLineTmpJournalize.SourceDocumentLine
        #        {
        #            sourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(sourceDocumentLine);
        #            accountingPolicy = AccountingPolicy::newPolicy(sourceDocumentLineItem);
        #
        #            if (accountingPolicy.parmAccountingRequired())
        #            {
        #                select firstonly AccountingDate from accountingDistribution
        #                    where accountingDistribution.SourceDocumentLine == sourceDocumentLine.RecId
        #                    &&  accountingDistribution.AccountingEvent == 0;
        #
        #                sourceDocumentLineTmpJournalize.AccountingDate = accountingDistribution.AccountingDate;
        #                this.createSourceDocLineItemTmp(_sourceDocument, sourceDocumentLineItem, sourceDocumentLineTmpJournalize, accountingPolicy);
        #
        #                    // Only create relieving matching list for parent documents
        #                    if (sourceDocumentLine.ParentSourceDocumentLine == 0)
        #                    {
        #                        this.createSourceDocumentLineRelieving(sourceDocumentLineItem.parmSourceDocumentLineRelievingList(), sourceDocumentLineTmpRelation);
        #                    }
        #                }
        #            }
        #
        #            subledgerJournalReliever = SubledgerJournalPreviewReliever::construct(sourceDocumentLineTmpRelation);
        #        }
        #    }
      ENDSOURCE
      SOURCE #previewSummarizeJournalAccEntryDetail
        #private void previewSummarizeJournalAccEntryDetail(SubledgerJournalAccountEntryTmpDetail  _tmpDetail,
        #                                               SubledgerJournalAccountEntryTmpSummary _tmpSummary)
        #{
        #    AccountingEventState    accountingEventState;
        #
        #    accountingEventState = AccountingEventState::Started;
        #
        #    insert_recordset _tmpSummary (
        #        LedgerDimension, PostingType, DebitCredit, TransferPolicy, IsCorrection, LegalEntity, AccountingDate, TransactionCurrencyCode, AccountingEvent,SubledgerJournalEntry,
        #        ExchangeRate1, ReportingExchangeRate1, TransactionCurrencyAmount, AccountingCurrencyAmount, ReportingCurrencyAmount,
        #        PostingLayer, LedgerName, AccountingCurrency, ReportingCurrency, JournalNumber, SubledgerJournalEntryType,
        #        ExchangeRateDate, HistoricalExchangeRateDate, ExchangeRate2, ReportingExchangeRate2 )
        #    select
        #        LedgerDimension, PostingType, DebitCredit, TransferPolicy, IsCorrection, LegalEntity, AccountingDate, TransactionCurrencyCode, AccountingEvent,SubledgerJournalEntry,
        #        ExchangeRate1, ReportingExchangeRate1, sum(TransactionCurrencyAmount), sum(AccountingCurrencyAmount), sum(ReportingCurrencyAmount),
        #        PostingLayer, LedgerName, AccountingCurrency, ReportingCurrency, JournalNumber, SubledgerJournalEntryType,
        #        ExchangeRateDate, HistoricalExchangeRateDate, ExchangeRate2, ReportingExchangeRate2
        #        from _tmpDetail
        #        group by
        #            LedgerDimension, PostingType, DebitCredit, TransferPolicy, IsCorrection, LegalEntity, AccountingDate, TransactionCurrencyCode,
        #            SubledgerJournalEntry, AccountingEvent, ExchangeRate1, ReportingExchangeRate1, FiscalCalendarPeriod, PostingLayer,
        #            LedgerName, AccountingCurrency, ReportingCurrency, JournalNumber, SubledgerJournalEntryType,
        #            ExchangeRateDate, HistoricalExchangeRateDate, ExchangeRate2, ReportingExchangeRate2
        #        where _tmpDetail.TransferPolicy == TransferPolicy::TransferIndividual
        #        &&  _tmpDetail.AccountingEvent == 0;
        #
        #    insert_recordset _tmpSummary (
        #        LedgerDimension, PostingType, DebitCredit, TransferPolicy, IsCorrection, LegalEntity, AccountingDate, TransactionCurrencyCode, AccountingEvent,SubledgerJournalEntry,
        #        ExchangeRate1, ReportingExchangeRate1, TransactionCurrencyAmount, AccountingCurrencyAmount, ReportingCurrencyAmount,
        #        PostingLayer, LedgerName, AccountingCurrency, ReportingCurrency, JournalNumber, SubledgerJournalEntryType,
        #        ExchangeRateDate, HistoricalExchangeRateDate, ExchangeRate2, ReportingExchangeRate2 )
        #    select
        #        LedgerDimension, PostingType, DebitCredit, TransferPolicy, IsCorrection, LegalEntity, AccountingDate, TransactionCurrencyCode, AccountingEvent,SubledgerJournalEntry,
        #        ExchangeRate1, ReportingExchangeRate1, sum(TransactionCurrencyAmount), sum(AccountingCurrencyAmount), sum(ReportingCurrencyAmount),
        #        PostingLayer, LedgerName, AccountingCurrency, ReportingCurrency, JournalNumber, SubledgerJournalEntryType,
        #        ExchangeRateDate, HistoricalExchangeRateDate, ExchangeRate2, ReportingExchangeRate2
        #        from _tmpDetail
        #        group by
        #            LedgerDimension, PostingType, DebitCredit, TransferPolicy, IsCorrection, LegalEntity, AccountingDate, TransactionCurrencyCode,
        #            SubledgerJournalEntry, AccountingEvent, ExchangeRate1, ReportingExchangeRate1, FiscalCalendarPeriod, PostingLayer,
        #            LedgerName, AccountingCurrency, ReportingCurrency, JournalNumber, SubledgerJournalEntryType,
        #            ExchangeRateDate, HistoricalExchangeRateDate, ExchangeRate2, ReportingExchangeRate2
        #        where _tmpDetail.TransferPolicy == TransferPolicy::Summarize
        #        &&  _tmpDetail.AccountingEvent == 0;
        #
        #    this.performSubledgerAllocation(_tmpSummary);
        #
        #    // <GEEU>
        #    this.summarizedPreviewJourAccEntryDetail(_tmpDetail, _tmpSummary);
        #    // </GEEU>
        #
        #    _tmpDetail.delete();
        #    accountingDistributionTmp.delete();
        #    sourceDocumentLineItemTmp.delete();
        #}
      ENDSOURCE
      SOURCE #previewSummarizeSJAEWithRounding
        #private void previewSummarizeSJAEWithRounding(
        #    SourceDocument _sourceDocument,
        #    SubledgerJournalAccountEntryTmpDetail  _tmpDetail,
        #    SubledgerJournalAccountEntryTmpSummary _tmpSummary)
        #{
        #    AccountingEventState    accountingEventState;
        #
        #    accountingEventState = AccountingEventState::Started;
        #
        #    this.fillPreviewTmpSummaryWithRounding(_tmpDetail, _tmpSummary);
        #    this.roundSJAELevelAccAndRptAmtsInTmpSummary(_tmpSummary);
        #    this.performSummaryLevelRoundingAdjustment(_sourceDocument, _tmpSummary);
        #    this.performSubledgerAllocation(_tmpSummary);
        #
        #    // We cannot recognize penny difference during preview. Penny difference needs to be recognized per subledger journal entry grouping. Subledger journal entry grouping depends
        #    // on accounting event. Accounting event is created based on accounting date and some other criteria provided by extensions. Since we don't know what criteria extensions may
        #    // provide, we simply couldn't get the grouping correctly.
        #
        #    // <GEEU>
        #    this.summarizedPreviewJourAccEntryDetail(_tmpDetail, _tmpSummary);
        #    // </GEEU>
        #
        #    _tmpDetail.delete();
        #    accountingDistributionTmp.delete();
        #    sourceDocumentLineItemTmp.delete();
        #}
      ENDSOURCE
      SOURCE #PSALoadaccountingDistReleaseTmp
        #private void PSALoadaccountingDistReleaseTmp(SourceDocument _sourceDocument)
        #{
        #    SourceDocumentLine                          sourceDocumentLine;
        #    AccountingDistribution                      accountingDistribution;
        #    AccountingDistribution                      accountingDistributionFromTmp;
        #    AccountingDistribution                      otherAccountingDistribution;
        #    AccountingDistribution                      reversingAccountingDistribution;
        #    SourceDocumentLineItem                      sourceDocumentLineItem;
        #    AccountingJournalizingRule                  journalizingAccountingRule;
        #    AccountingDistributionRule                  distributionAccountingRule;
        #    LedgerDimensionAllocationList               ledgerDimensionAllocationList;
        #    LedgerDimensionAllocationListEnumerator     ledgerDimensionAllocationListEnumerator;
        #    LedgerDimensionAllocation                   ledgerDimensionAllocation;
        #    SubledgerJournalAccountEntry                subledgerJournalAccountEntry;
        #    SubledgerJournalAccountEntryDistribution    subledgerJournalAccountEntryDistribution;
        #    SubledgerJournalEntry                       subledgerJournalEntry;
        #    Ledger                                      accountingDistributionLedger;
        #    boolean                                     isInterCompany;
        #    AccountingEvent                             accountingEvent;
        #    AccountingEvent                             otherAccountingEvent;
        #    AccountingEvent                             reversingAccountingEvent;
        #    AccountingPolicy                            accountingPolicy;
        #    SourceDocumentLineRecId                     previousSourceDocumentLineRecId;
        #    boolean                                     isRelievingVal = true;
        #    RecordInsertList                            recordInsertList;
        #    AccountingEventType                         accountingEventType;
        #    container                                   exchangeRatesContainer;
        #    container                                   reportingExchangeRatesContainer;
        #    container                                   referenceDistributionExchRatesContainer;
        #    boolean                                     isCorrection;
        #    boolean                                     isExchangeRateVarianceApplicable;
        #    LegalEntityRecId                            legalEntityRecId;
        #    LedgerRecId                                 ledgerRecId;
        #    Map                                         ledgerByLegalEntity = new Map(Types::Int64, Types::Record);
        #    Map                                         ledgerByRecId = new Map(Types::Int64, Types::Record);
        #    Map                                         accountingEventTypeByRecId = new Map(Types::Int64, Types::Enum);
        #    Set                                         checkRecordExists = new Set(Types::Int64);
        #    VendInvoiceInfoLine                         vendInvoiceInfoLine;
        #    SourceDocumentLineImplementation            sourceDocumentLineImplementation;
        #    VendInvoiceTrans                            vendInvoiceTrans;
        #    AllocationFactor                            allocationFactor;
        #
        #    #define.ExchangeRate1(1)
        #    #define.ExchangeRate2(2)
        #    #define.ReferenceDistExchangeRate1(1)
        #    #define.ReferenceDistExchangeRate2(2)
        #    #define.ReferenceDistReportingExchangeRate1(3)
        #    #define.ReferenceDistReportingExchangeRate2(4)
        #
        #    recordInsertList = new RecordInsertList(tableNum(AccountingDistributionTmp), true, true, true, false, true, accountingDistributionTmp);
        #    isCorrection = _sourceDocument.parmIsCorrection();
        #
        #    if (isPreviewMode)
        #    {
        #        insert_recordset accountingDistributionTmpJournalize(   TransactionCurrency,
        #                                                                TransactionCurrencyAmount,
        #                                                                LedgerDimension,
        #                                                                AmountSource,
        #                                                                ReferenceDistribution,
        #                                                                AccountingEvent,
        #                                                                SourceDocumentLine,
        #                                                                Type,
        #                                                                AccountingLegalEntity,
        #                                                                ParentDistribution,
        #                                                                AccountingDate,
        #                                                                AllocationFactor,
        #                                                                MonetaryAmount,
        #                                                                Number,
        #                                                                ReferenceRole,
        #                                                                AccountingDistribution
        #                                                                )
        #
        #            select  TransactionCurrency,
        #                    TransactionCurrencyAmount,
        #                    LedgerDimension,
        #                    AmountSource,
        #                    ReferenceDistribution,
        #                    AccountingEvent,
        #                    SourceDocumentLine,
        #                    Type,
        #                    AccountingLegalEntity,
        #                    ParentDistribution,
        #                    AccountingDate,
        #                    AllocationFactor,
        #                    MonetaryAmount,
        #                    Number,
        #                    ReferenceRole,
        #                    RecId
        #            from accountingDistribution
        #                where accountingDistribution.ReferenceRole != AccountingDistributionReferenceRole::Reversing &&
        #                  accountingDistribution.SourceDocumentHeader == sourceDocumentHeaderRecId
        #            join sourceDocumentLineItemTmp // Or we can have seperate insert where we could do isRelieving
        #            where sourceDocumentLineItemTmp.SourceDocumentLine == accountingDistribution.SourceDocumentLine
        #            notexists join accountingEvent
        #                where  accountingDistribution.AccountingEvent == accountingEvent.RecId
        #                    && accountingEvent.State != AccountingEventState::Started;
        #    }
        #    else
        #    {
        #        insert_recordset accountingDistributionTmpJournalize(   TransactionCurrency,
        #                                                                TransactionCurrencyAmount,
        #                                                                LedgerDimension,
        #                                                                AmountSource,
        #                                                                ReferenceDistribution,
        #                                                                AccountingEvent,
        #                                                                SourceDocumentLine,
        #                                                                Type,
        #                                                                AccountingLegalEntity,
        #                                                                ParentDistribution,
        #                                                                AccountingDate,
        #                                                                AllocationFactor,
        #                                                                MonetaryAmount,
        #                                                                Number,
        #                                                                ReferenceRole,
        #                                                                AccountingDistribution
        #                                                                )
        #
        #            select  TransactionCurrency,
        #                    TransactionCurrencyAmount,
        #                    LedgerDimension,
        #                    AmountSource,
        #                    ReferenceDistribution,
        #                    AccountingEvent,
        #                    SourceDocumentLine,
        #                    Type,
        #                    AccountingLegalEntity,
        #                    ParentDistribution,
        #                    AccountingDate,
        #                    AllocationFactor,
        #                    MonetaryAmount,
        #                    Number,
        #                    ReferenceRole,
        #                    RecId
        #            from accountingDistribution
        #                where accountingDistribution.ReferenceRole != AccountingDistributionReferenceRole::Reversing &&
        #                        accountingDistribution.AccountingEvent != 0 &&
        #                        accountingDistribution.SourceDocumentHeader == sourceDocumentHeaderRecId
        #            join sourceDocumentLineItemTmp // Or we can have seperate insert where we could do isRelieving
        #            where sourceDocumentLineItemTmp.SourceDocumentLine == accountingDistribution.SourceDocumentLine
        #            notexists join accountingEvent
        #                where  accountingDistribution.AccountingEvent == accountingEvent.RecId
        #                    && accountingEvent.State != AccountingEventState::Started;
        #    }
        #
        #    // Cache all reference distribution exchange rates and releiving that will be used
        #    this.loadReferenceDistributionInformation(accountingDistributionTmpJournalize);
        #
        #    while select accountingDistributionTmpJournalize
        #        join sourceDocumentLine
        #            order by RecId
        #            where sourceDocumentLine.RecId == accountingDistributionTmpJournalize.SourceDocumentLine
        #        join accountingDistributionFromTmp
        #            where accountingDistributionFromTmp.RecId == accountingDistributionTmpJournalize.AccountingDistribution
        #    {
        #        if (previousSourceDocumentLineRecId != sourceDocumentLine.RecId)
        #        {
        #            previousSourceDocumentLineRecId = accountingDistributionTmpJournalize.SourceDocumentLine;
        #            if (sourceDocumentLineItemMap.exists(sourceDocumentLine.RecId))
        #            {
        #                sourceDocumentLineItem = sourceDocumentLineItemMap.lookup(sourceDocumentLine.RecId);
        #                sourceDocumentLineImplementation = sourceDocumentLineItemImplMap.lookup(sourceDocumentLine.RecId);
        #            }
        #            else
        #            {
        #                sourceDocumentLineImplementation = sourceDocumentLine.getSourceDocumentLineImplementation();
        #                sourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(sourceDocumentLine, sourceDocumentLineImplementation);
        #            }
        #
        #            if (accountingPolicyMap.exists(sourceDocumentLine.RecId))
        #            {
        #                accountingPolicy = accountingPolicyMap.lookup(sourceDocumentLine.recId);
        #            }
        #            else
        #            {
        #                accountingPolicy = AccountingPolicy::newPolicy(sourceDocumentLineItem);
        #            }
        #            select sourceDocumentLineItemTmp where sourceDocumentLineItemTmp.SourceDocumentLine == sourceDocumentLine.RecId;
        #        }
        #
        #        if (sourceDocumentLineItemTmp)
        #        {
        #            vendInvoiceInfoLine = VendInvoiceInfoLine::findSourceDocumentLine(sourceDocumentLineItemTmp.SourceDocumentLine);
        #        }
        #
        #        // Buffer materializations are very expensive and few ledgers are in use, so cache
        #        // the buffer instances within this method scope to reduce the number of materializations
        #        legalEntityRecId = accountingDistributionTmpJournalize.AccountingLegalEntity;
        #        if (!ledgerByLegalEntity.exists(LegalEntityRecId))
        #        {
        #            ledgerByLegalEntity.insert(LegalEntityRecId, Ledger::findByLegalEntity(accountingDistributionTmpJournalize.AccountingLegalEntity));
        #        }
        #        accountingDistributionLedger = ledgerByLegalEntity.lookup(legalEntityRecId);
        #
        #        //The purpose of having this exchange rate helper instances is to compute the exchange rate
        #        // based on the exchange rate type associated with Accounting distributions ledger.
        #        // These exchange rates will be used only when we have accounting legal entity in the
        #        // accounting distribution different than that of the owning LE.
        #        // The Owning LE is the line LE.
        #        exchangeRatesContainer = this.getExchangeRates(accountingDistributionLedger.RecId, sourceDocumentLineItemTmp.CurrencyCode, sourceDocumentLineItemTmp.ExchangeRateDate);
        #
        #        if (accountingDistributionLedger.ReportingCurrency)
        #        {
        #            reportingExchangeRatesContainer = this.getExchangeRates(accountingDistributionLedger.RecId, accountingDistributionLedger.ReportingCurrency, sourceDocumentLineItemTmp.ExchangeRateDate);
        #        }
        #
        #        if ((accountingDistributionTmpJournalize.AccountingLegalEntity != sourceDocumentLineItemTmp.LegalEntity) &&
        #            sourceDocumentLineItem.documentsInterCompanyBusinessEvent())
        #        {
        #            isInterCompany = true;
        #            if (!hasInterCompany)
        #            {
        #                hasInterCompany = true;
        #            }
        #        }
        #        else
        #        {
        #            isInterCompany = false;
        #        }
        #        // make sure context is set to company for line item. This may be different from current context (e.g. purchase req.)
        #        changeCompany(CompanyInfo::getDataArea(sourceDocumentLineItemTmp.LegalEntity))
        #        {
        #            if (!accountingEventTypeByRecId.exists(accountingDistributionTmpJournalize.AccountingEvent))
        #            {
        #                accountingEventTypeByRecId.insert(accountingDistributionTmpJournalize.AccountingEvent, AccountingEvent::find(accountingDistributionTmpJournalize.AccountingEvent).Type);
        #            }
        #            accountingEventType = accountingEventTypeByRecId.lookup(accountingDistributionTmpJournalize.AccountingEvent);
        #
        #            journalizingAccountingRule = accountingPolicy.parmJournalizingRule(accountingDistributionTmpJournalize.MonetaryAmount,accountingEventType);
        #
        #            if ((!sourceDocumentType.parmReclassifyDistributionAmounts()) || accountingPolicy.parmDocumentRecordsActual())
        #            {
        #                distributionAccountingRule = accountingPolicy.parmDistributionRule(accountingDistributionTmpJournalize.MonetaryAmount);
        #                isExchangeRateVarianceApplicable = accountingPolicy.parmExchangeRateVarianceApplicable();
        #
        #                distributionAccountingRule.parmAccountingdistribution(accountingDistributionFromTmp);
        #
        #                accountingDistributionTmp.clear();
        #                accountingDistributionTmp.initFromAccountingDistTmpJournalize(accountingDistributionTmpJournalize);
        #                accountingDistributionTmp.initFromLedger(accountingDistributionLedger);
        #
        #                accountingDistributionTmp.Offset = NoYes::No;
        #
        #                if (!vendInvoiceInfoLine.ReceiveNow && vendInvoiceInfoLine.PSAReleaseAmount)
        #                {
        #                    accountingDistributionTmp.AmountSign = DebitCredit::Debit;
        #                    accountingDistributionTmp.PostingType = LedgerPostingType::PSAProjPurchRetain;
        #                }
        #                else
        #                {
        #                    accountingDistributionTmp.AmountSign = distributionAccountingRule.parmSide();
        #                    accountingDistributionTmp.PostingType = distributionAccountingRule.parmLedgerPostingType();
        #                }
        #
        #                accountingDistributionTmp.NegativeAmountSign = (distributionAccountingRule.parmSide() == DebitCredit::Credit)? DebitCredit::Debit : DebitCredit::Credit;
        #                accountingDistributionTmp.ExchangeRateDate = sourceDocumentLineItemTmp.ExchangeRateDate;
        #                if (isInterCompany)
        #                {
        #                    accountingDistributionTmp.ExchangeRate1 = conPeek(exchangeRatesContainer,#ExchangeRate1);
        #                    accountingDistributionTmp.ExchangeRate2 = conPeek(exchangeRatesContainer,#ExchangeRate2);
        #                    accountingDistributionTmp.ReportingExchangeRate1 = conPeek(reportingExchangeRatesContainer,#ExchangeRate1);
        #                    accountingDistributionTmp.ReportingExchangeRate2 = conPeek(reportingExchangeRatesContainer,#ExchangeRate2);
        #                }
        #                else
        #                {
        #                    accountingDistributionTmp.ExchangeRate1 = sourceDocumentLineItemTmp.ExchangeRate1;
        #                    accountingDistributionTmp.ExchangeRate2 = sourceDocumentLineItemTmp.ExchangeRate2;
        #                    accountingDistributionTmp.ReportingExchangeRate1 = sourceDocumentLineItemTmp.ReportingExchangeRate1;
        #                    accountingDistributionTmp.ReportingExchangeRate2 = sourceDocumentLineItemTmp.ReportingExchangeRate2;
        #                }
        #                accountingDistributionTmp.IsIntercompany = isInterCompany;
        #                accountingDistributionTmp.FiscalCalendarPeriod = this.getFiscalCalendarPeriod(accountingDistributionTmpJournalize.AccountingDate,accountingDistributionTmpJournalize.AccountingLegalEntity);
        #                accountingDistributionTmp.SourceDocumentLine = sourceDocumentLine.RecId;
        #                accountingDistributionTmp.IsCorrection = isCorrection;
        #
        #                if (isInterCompany)
        #                {
        #                    // get due from
        #                    accountingDistributionTmp.DueFromLedgerDimension = this.getLedgerDimensionOfDueToDueFrom(
        #                                                                        accountingDistributionTmpJournalize.AccountingLegalEntity,
        #                                                                        sourceDocumentLineItemTmp.LegalEntity,
        #                                                                        accountingDistributionTmp.LedgerDimension,
        #                                                                        -accountingDistributionTmp.TransactionCurrencyAmount);
        #
        #                    accountingDistributionTmp.SourceDocLineLegalEntity = sourceDocumentLineItemTmp.LegalEntity;
        #                }
        #
        #                allocationFactor = accountingDistributionTmpJournalize.AllocationFactor ? accountingDistributionTmpJournalize.AllocationFactor : 1;
        #                if (accountingDistributionTmp.PostingType == LedgerPostingType::PSAProjPurchRetain)
        #                {
        #                    accountingDistributionTmp.TransactionCurrencyAmount = vendInvoiceInfoLine.PSAReleaseAmount * allocationFactor;
        #                }
        #                else
        #                {
        #                    accountingDistributionTmp.TransactionCurrencyAmount = this.transactionCurrencyAmount(accountingDistributionTmp, accountingDistributionTmpJournalize);
        #                }
        #
        #                if (isExchangeRateVarianceApplicable &&
        #                    !conFind([MonetaryAmount::ChargeVariance, MonetaryAmount::TaxNonRecoverableVariance,
        #                          MonetaryAmount::DiscountVariance, MonetaryAmount::PriceAdjustmentVariance,
        #                          MonetaryAmount::PriceVariance, MonetaryAmount::QuantityVariance,
        #                          MonetaryAmount::TaxVariance,MonetaryAmount::RoundingAmount,
        #                          MonetaryAmount::TotalDiscountRounding, MonetaryAmount::TotalDiscountVariance],
        #                          accountingDistributionTmpJournalize.MonetaryAmount))
        #                {
        #                    referenceDistributionExchRatesContainer = this.getReferenceDistributionExchangeRates(accountingDistributionTmpJournalize);
        #                    if (referenceDistributionExchRatesContainer != conNull())
        #                    {
        #                        if (accountingDistributionTmp.ExchangeRate1 != conPeek(referenceDistributionExchRatesContainer,#ReferenceDistExchangeRate1) ||
        #                            accountingDistributionTmp.ExchangeRate2 != conPeek(referenceDistributionExchRatesContainer,#ReferenceDistExchangeRate2) ||
        #                            accountingDistributionTmp.ReportingExchangeRate1 != conPeek(referenceDistributionExchRatesContainer,#ReferenceDistReportingExchangeRate1) ||
        #                            accountingDistributionTmp.ReportingExchangeRate2 != conPeek(referenceDistributionExchRatesContainer,#ReferenceDistReportingExchangeRate2))
        #                        {
        #                            //ERV is applicable & hence get the difference in the rate between current SD and reference SD
        #                            accountingDistributionTmp.ERVExchangeRate1 = accountingDistributionTmp.ExchangeRate1 - conPeek(referenceDistributionExchRatesContainer,#ReferenceDistExchangeRate1);
        #                            accountingDistributionTmp.ERVExchangeRate2 = accountingDistributionTmp.ExchangeRate2 - conPeek(referenceDistributionExchRatesContainer,#ReferenceDistExchangeRate2);
        #                            accountingDistributionTmp.ERVReportingExchangeRate1 = accountingDistributionTmp.ReportingExchangeRate1 - conPeek(referenceDistributionExchRatesContainer,#ReferenceDistReportingExchangeRate1);
        #                            accountingDistributionTmp.ERVReportingExchangeRate2 = accountingDistributionTmp.ReportingExchangeRate2 - conPeek(referenceDistributionExchRatesContainer,#ReferenceDistReportingExchangeRate2);
        #
        #                            //since ERV is applicable the current SD exchange rate should be using reference document exchange rate for computing the accounting and
        #                            // reporting currency amounts.
        #                            accountingDistributionTmp.ExchangeRate1 = conPeek(referenceDistributionExchRatesContainer,#ReferenceDistExchangeRate1);
        #                            accountingDistributionTmp.ExchangeRate2 = conPeek(referenceDistributionExchRatesContainer,#ReferenceDistExchangeRate2);
        #                            accountingDistributionTmp.ReportingExchangeRate1 = conPeek(referenceDistributionExchRatesContainer,#ReferenceDistReportingExchangeRate1);
        #                            accountingDistributionTmp.ReportingExchangeRate2 = conPeek(referenceDistributionExchRatesContainer,#ReferenceDistReportingExchangeRate2);
        #
        #                            accountingDistributionTmp.ERVAccountingDistribution = accountingDistributionTmpJournalize.ReferenceDistribution;
        #
        #                            if (accountingDistributionTmpJournalize.TransactionCurrencyAmount >0)
        #                            {
        #                                if (accountingDistributionTmp.ERVExchangeRate1 >0 || accountingDistributionTmp.ERVReportingExchangeRate1 >0)
        #                                {
        #                                    accountingDistributionTmp.ERVPostingType = LedgerPostingType::ExchRateLoss;
        #                                    accountingDistributionTmp.ERVAmountSign = DebitCredit::Debit;
        #                                    accountingDistributionTmp.ERVNegativeAmountSign = DebitCredit::Credit;
        #                                }
        #                                else
        #                                {
        #                                    accountingDistributionTmp.ERVPostingType = LedgerPostingType::ExchRateGain;
        #                                    accountingDistributionTmp.ERVAmountSign = DebitCredit::Credit;
        #                                    accountingDistributionTmp.ERVNegativeAmountSign = DebitCredit::Debit;
        #                                }
        #                            }
        #                            else
        #                            {
        #                                if (accountingDistributionTmp.ERVExchangeRate1 >0 || accountingDistributionTmp.ERVReportingExchangeRate1 >0)
        #                                {
        #                                    accountingDistributionTmp.ERVPostingType = LedgerPostingType::ExchRateGain;
        #                                    accountingDistributionTmp.ERVAmountSign = DebitCredit::Credit;
        #                                    accountingDistributionTmp.ERVNegativeAmountSign = DebitCredit::Debit;
        #                                }
        #                                else
        #                                {
        #                                    accountingDistributionTmp.ERVPostingType = LedgerPostingType::ExchRateLoss;
        #                                    accountingDistributionTmp.ERVAmountSign = DebitCredit::Debit;
        #                                    accountingDistributionTmp.ERVNegativeAmountSign = DebitCredit::Credit;
        #                                }
        #                            }
        #                            accountingDistributionTmp.ERVLedgerDimension =
        #                                    this.getGainLossLedgerDimension(accountingDistributionLedger.RecId,
        #                                                                    accountingDistributionTmp.TransactionCurrency,
        #                                                                    (accountingDistributionTmp.ERVPostingType == LedgerPostingType::ExchRateGain)?CurrencyGainLossAccountType::UnrealizedGain:CurrencyGainLossAccountType::UnrealizedLoss,
        #                                                                    sourceDocumentLineItem);
        #
        #                            accountingDistributionTmp.ERVTransactionCurrencyAmount = 0;
        #                        }
        #                    }
        #                }
        #
        #                this.calculateForeignCurAmounts(accountingDistributionTmp,sourceDocumentLineItemTmp);
        #                if (accountingDistributionTmp.ERVAccountingCurrencyAmount != 0 || accountingDistributionTmp.ERVReportingCurrencyAmount != 0)
        #                {
        #                    accountingDistributionTmp.IsExchangeRateVariance = true;
        #                    hasExchangeRateVariance = true;
        #                }
        #                accountingDistributionTmp.TransferPolicy =  (distributionAccountingRule.parmSummarize() == true) ? TransferPolicy::Summarize : TransferPolicy::TransferIndividual;
        #
        #                if (accountingDistributionTmp.PostingType == LedgerPostingType::PSAProjPurchRetain)
        #                {
        #                    accountingDistributionTmp.LedgerDimensionDefaultAccount  =  LedgerSystemAccounts::find(LedgerPostingType::PSAProjPurchRetain).LedgerDimension;
        #                    accountingDistributionTmp.LedgerDimension = DimensionDefaultingService::serviceLedgerDimensionFromLedgerDims(accountingDistributionTmp.LedgerDimensionDefaultAccount,
        #                                                                                                                                 accountingDistributionTmpJournalize.LedgerDimension);
        #                }
        #                else
        #                {
        #                    accountingDistributionTmp.LedgerDimension = accountingDistributionTmpJournalize.LedgerDimension;
        #                    accountingDistributionTmp.applyFixedDimension();
        #                }
        #
        #                accountingDistributionTmp.InterCompanyPostingType = LedgerPostingType::InterCompany;
        #
        #                accountingDistributionTmp.initFromAccountingDistributionTmp(accountingDistributionTmp);
        #                accountingDistributionTmp.IsRelieving = false;
        #                accountingDistributionTmp.IsYearEnd = false;
        #                switch (accountingEventType)
        #                {
        #                    case AccountingEventType::PeriodClose:
        #                        accountingDistributionTmp.SubledgerJournalEntryType = SubledgerJournalEntryType::PeriodClosed;
        #                        break;
        #                    case AccountingEventType::PeriodOpen:
        #                        accountingDistributionTmp.SubledgerJournalEntryType = SubledgerJournalEntryType::PeriodOpened;
        #                        break;
        #                    default:
        #                        accountingDistributionTmp.SubledgerJournalEntryType = sourceDocumentType.parmSubledgerJournalEntryType();
        #                }
        #                recordInsertList.add(accountingDistributionTmp);
        #            }
        #
        #            journalizingAccountingRule.parmAccountingdistribution(accountingDistributionFromTmp);
        #            journalizingAccountingRule.parmDimensionValuesUsedForSummaryAccount(true, dimensionValuesUsedForSummaryAccount);
        #            ledgerDimensionAllocationList = journalizingAccountingRule.parmLedgerDimensionAllocList();
        #            ledgerDimensionAllocationListEnumerator = ledgerDimensionAllocationList.getEnumerator();
        #
        #            while (ledgerDimensionAllocationListEnumerator.moveNext())
        #            {
        #                ledgerDimensionAllocation = ledgerDimensionAllocationListEnumerator.current();
        #                accountingDistributionTmp.clear();
        #                accountingDistributionTmp.initFromAccountingDistTmpJournalize(accountingDistributionTmpJournalize);
        #                accountingDistributionTmp.initFromLedger(accountingDistributionLedger);
        #
        #                accountingDistributionTmp.Offset = ledgerDimensionAllocation.parmOppositeAccount();
        #                accountingDistributionTmp.AmountSign = ledgerDimensionAllocation.parmSide();
        #                accountingDistributionTmp.NegativeAmountSign = (ledgerDimensionAllocation.parmSide() == DebitCredit::Credit)? DebitCredit::Debit : DebitCredit::Credit;
        #                accountingDistributionTmp.PostingType = journalizingAccountingRule.parmLedgerPostingType();
        #                accountingDistributionTmp.SourceDocumentLine = sourceDocumentLine.RecId;
        #                accountingDistributionTmp.ExchangeRateDate = sourceDocumentLineItemTmp.ExchangeRateDate;
        #                if (isInterCompany)
        #                {
        #                    accountingDistributionTmp.ExchangeRate1 = conPeek(exchangeRatesContainer,#ExchangeRate1);
        #                    accountingDistributionTmp.ExchangeRate2 = conPeek(exchangeRatesContainer,#ExchangeRate2);
        #                    accountingDistributionTmp.ReportingExchangeRate1 = conPeek(reportingExchangeRatesContainer,#ExchangeRate1);
        #                    accountingDistributionTmp.ReportingExchangeRate2 = conPeek(reportingExchangeRatesContainer,#ExchangeRate2);
        #                }
        #                else
        #                {
        #                    accountingDistributionTmp.ExchangeRate1 = sourceDocumentLineItemTmp.ExchangeRate1;
        #                    accountingDistributionTmp.ExchangeRate2 = sourceDocumentLineItemTmp.ExchangeRate2;
        #                    accountingDistributionTmp.ReportingExchangeRate1 = sourceDocumentLineItemTmp.ReportingExchangeRate1;
        #                    accountingDistributionTmp.ReportingExchangeRate2 = sourceDocumentLineItemTmp.ReportingExchangeRate2;
        #                }
        #                accountingDistributionTmp.IsIntercompany = isInterCompany;
        #                accountingDistributionTmp.IsCorrection = isCorrection;
        #
        #                if (!vendInvoiceInfoLine.ReceiveNow && vendInvoiceInfoLine.PSAReleaseAmount)
        #                {
        #                    accountingDistributionTmp.AmountSign = DebitCredit::Credit;
        #                    accountingDistributionTmp.TransactionCurrencyAmount -= (VendInvoiceInfoLine::findSourceDocumentLine(
        #                                                                            sourceDocumentLineItemTmp.SourceDocumentLine).PSAReleaseAmount * allocationFactor);
        #                }
        #                else
        #                {
        #                    if (ledgerDimensionAllocation.parmLedgerPostingType())
        #                    {
        #                        accountingDistributionTmp.PostingType = ledgerDimensionAllocation.parmLedgerPostingType();
        #                    }
        #                    else
        #                    {
        #                        accountingDistributionTmp.PostingType = journalizingAccountingRule.parmLedgerPostingType();
        #                    }
        #
        #                    accountingDistributionTmp.TransactionCurrencyAmount = this.transactionCurrencyAmount(accountingDistributionTmp, accountingDistributionTmpJournalize);
        #                }
        #
        #                this.calculateForeignCurAmounts(accountingDistributionTmp,sourceDocumentLineItemTmp);
        #
        #                accountingDistributionTmp.TransferPolicy = (journalizingAccountingRule.parmSummarize() == true) ? TransferPolicy::Summarize : TransferPolicy::TransferIndividual;
        #
        #                accountingDistributionTmp.LedgerDimension = journalizingAccountingRule.getJournalAccountEntryLedgerDimension(ledgerDimensionAllocation.parmLedgerDimension(),accountingDistributionTmpJournalize.LedgerDimension);
        #
        #                if (isInterCompany)
        #                {
        #                    // get due to
        #                    accountingDistributionTmp.DueToLedgerDimension = this.getLedgerDimensionOfDueToDueFrom(
        #                                                                        sourceDocumentLineItemTmp.LegalEntity,
        #                                                                        accountingDistributionTmpJournalize.AccountingLegalEntity,
        #                                                                        accountingDistributionTmpJournalize.LedgerDimension,
        #                                                                        -accountingDistributionTmpJournalize.TransactionCurrencyAmount);
        #
        #                    accountingDistributionTmp.SourceDocLineLegalEntity = sourceDocumentLineItemTmp.LegalEntity;
        #                    accountingDistributionTmp.FiscalCalendarPeriod = this.getFiscalCalendarPeriod(accountingDistributionTmpJournalize.AccountingDate, accountingDistributionTmpJournalize.AccountingLegalEntity);
        #                }
        #                else
        #                {
        #                    accountingDistributionTmp.FiscalCalendarPeriod = this.getFiscalCalendarPeriod(accountingDistributionTmpJournalize.AccountingDate,sourceDocumentLineItem.parmLegalEntityRecId());
        #                }
        #
        #                accountingDistributionTmp.InterCompanyPostingType = LedgerPostingType::InterCompany;
        #
        #                accountingDistributionTmp.initFromAccountingDistributionTmp(accountingDistributionTmp);
        #                accountingDistributionTmp.IsRelieving = false;
        #                accountingDistributionTmp.IsYearEnd = false;
        #                switch (accountingEventType)
        #                {
        #                    case AccountingEventType::PeriodClose:
        #                        accountingDistributionTmp.SubledgerJournalEntryType = SubledgerJournalEntryType::PeriodClosed;
        #                        break;
        #                    case AccountingEventType::PeriodOpen:
        #                        accountingDistributionTmp.SubledgerJournalEntryType = SubledgerJournalEntryType::PeriodOpened;
        #                        break;
        #                    default:
        #                        accountingDistributionTmp.SubledgerJournalEntryType = sourceDocumentType.parmSubledgerJournalEntryType();
        #                }
        #                recordInsertList.add(accountingDistributionTmp);
        #
        #            }
        #
        #            if(VendInvoiceInfoLine.ReceiveNow && sourceDocumentLineImplementation.TableId == tableNum(VendInvoiceTrans))
        #            {
        #                vendInvoiceTrans = sourceDocumentLineImplementation;
        #
        #                if((vendInvoiceTrans.psaReleaseAmount || vendInvoiceTrans.psaRetainageAmount) &&
        #                    !checkRecordExists.in(sourceDocumentLineImplementation.RecId))
        #                {
        #                    if(vendInvoiceTrans.purchLine().ProjId)
        #                    {
        #                        this.PSALoadAccountingEventHandler(
        #                                                    sourceDocumentLine,
        #                                                    sourceDocumentLineItemTmp,
        #                                                    accountingDistributionTmpJournalize,
        #                                                    accountingDistributionLedger,
        #                                                    sourceDocumentType,
        #                                                    sourceDocumentLineItem,
        #                                                    journalizingAccountingRule,
        #                                                    ledgerDimensionAllocation,
        #                                                    recordInsertList,
        #                                                    accountingEventType,
        #                                                    isInterCompany,
        #                                                    isCorrection,
        #                                                    exchangeRatesContainer,
        #                                                    reportingexchangeRatesContainer);
        #                    }
        #
        #                    checkRecordExists.add(sourceDocumentLineImplementation.RecId);
        #                }
        #            }
        #
        #            // relieving code
        #            if (sourceDocumentLineItemTmp.SubledgerJournalRelievingMethod != SubledgerJournalRelievingMethod::None &&
        #                accountingDistributionTmpJournalize.ReferenceDistribution != 0 &&
        #                relieveingRequiredSet.in(accountingDistributionTmpJournalize.ReferenceDistribution) &&
        #                !conFind([MonetaryAmount::ChargeVariance, MonetaryAmount::TaxNonRecoverableVariance,
        #                          MonetaryAmount::DiscountVariance, MonetaryAmount::PriceAdjustmentVariance,
        #                          MonetaryAmount::PriceVariance, MonetaryAmount::QuantityVariance,
        #                          MonetaryAmount::TaxVariance],
        #                          accountingDistributionTmpJournalize.MonetaryAmount)
        #               )
        #            {
        #                while select SourceDocumentLine, RecId, LedgerDimension, TransactionCurrency, TransactionCurrencyAmount, ParentDistribution, AccountingDate, AccountingEvent, ReferenceRole
        #                    from accountingDistribution
        #                        where ((sourceDocumentLineItemTmp.SubledgerJournalRelievingMethod == SubledgerJournalRelievingMethod::Full &&
        #                                accountingDistribution.RecId == accountingDistributionTmpJournalize.ReferenceDistribution &&
        #                                accountingDistribution.SourceDocumentLine != accountingDistributionTmpJournalize.SourceDocumentLine) ||
        #                               (sourceDocumentLineItemTmp.SubledgerJournalRelievingMethod == SubledgerJournalRelievingMethod::Partial &&
        #                                accountingDistribution.RecId == accountingDistributionTmpJournalize.AccountingDistribution &&
        #                                accountingDistribution.SourceDocumentLine == accountingDistributionTmpJournalize.SourceDocumentLine))
        #                    join AccountingDistribution, SubledgerJournalAccountEntry from subledgerJournalAccountEntryDistribution
        #                        where ((subledgerJournalAccountEntryDistribution.AccountingDistribution ==  accountingDistribution.RecId &&
        #                                sourceDocumentLineItemTmp.SubledgerJournalRelievingMethod == SubledgerJournalRelievingMethod::Full) ||
        #                               (subledgerJournalAccountEntryDistribution.AccountingDistribution ==  accountingDistribution.ReferenceDistribution &&
        #                                sourceDocumentLineItemTmp.SubledgerJournalRelievingMethod == SubledgerJournalRelievingMethod::Partial))
        #                    join RecId, Side, SubledgerJournalEntry, IsCorrection, PostingType, ExchangeRate1, ReportingExchangeRate1, TransactionCurrencyAmount, TransactionCurrency, LedgerDimension, ExchangeRate2, ReportingExchangeRate2, ExchangeRateDate, IsTransferredInDetail
        #                    from subledgerJournalAccountEntry
        #                        where subledgerJournalAccountEntry.RecId == subledgerJournalAccountEntryDistribution.SubledgerJournalAccountEntry
        #                    join RecId, Ledger, Type
        #                    from subledgerJournalEntry
        #                        where subledgerJournalEntry.RecId == subledgerJournalAccountEntry.SubledgerJournalEntry
        #                {
        #
        #                    select RecId from otherAccountingDistribution
        #                        where otherAccountingDistribution.ReferenceDistribution == accountingDistributionTmpJournalize.ReferenceDistribution &&
        #                              otherAccountingDistribution.RecId != accountingDistributionTmpJournalize.AccountingDistribution &&
        #                              otherAccountingDistribution.SourceDocumentLine == accountingDistributionTmpJournalize.SourceDocumentLine &&
        #                              sourceDocumentLineItemTmp.SubledgerJournalRelievingMethod == SubledgerJournalRelievingMethod::Full
        #                        join RecId, State from otherAccountingEvent
        #                            where otherAccountingEvent.RecId == otherAccountingDistribution.AccountingEvent &&
        #                                  otherAccountingEvent.State != AccountingEventState::Started;
        #
        #                    if (otherAccountingDistribution)
        #                    {
        #                        continue;
        #                    }
        #
        #
        #                    accountingDistributionTmp.clear();
        #
        #                    accountingDistributionTmp.IsRelieving = true;
        #                    accountingDistributionTmp.IsYearEnd = false;
        #
        #                    //Initialize from SLJE
        #                    accountingDistributionTmp.RelievingSubledgerJournalEntryType =  subledgerJournalEntry.Type;
        #                    accountingDistributionTmp.Ledger = subledgerJournalEntry.Ledger;
        #                    accountingDistributionTmp.initFromLedger(Ledger::find(accountingDistributionTmp.Ledger));
        #
        #                    // Initialize from accountingDistribution
        #                    accountingDistributionTmp.AccountingDistribution = accountingDistribution.RecId;
        #                    accountingDistributionTmp.FiscalCalendarPeriod = this.getFiscalCalendarPeriod(accountingDistributionTmpJournalize.AccountingDate,accountingDistributionTmpJournalize.AccountingLegalEntity);
        #                    accountingDistributionTmp.ParentDistribution = accountingDistribution.ParentDistribution;
        #                    accountingDistributionTmp.AccountingDate = accountingDistributionTmpJournalize.AccountingDate;
        #
        #                    if (sourceDocumentLineItemTmp.SubledgerJournalRelievingMethod == SubledgerJournalRelievingMethod::Partial)
        #                    {
        #                        accountingDistributionTmp.AccountingEvent = accountingDistribution.AccountingEvent;
        #                        accountingDistributionTmp.SourceDocumentLine = accountingDistribution.SourceDocumentLine;
        #                    }
        #                    else
        #                    {
        #                        accountingDistributionTmp.AccountingEvent = accountingDistributionTmpJournalize.AccountingEvent;
        #                        accountingDistributionTmp.SourceDocumentLine = accountingDistributionTmpJournalize.SourceDocumentLine;
        #                    }
        #
        #                    accountingDistributionTmp.ReferenceRole = accountingDistribution.ReferenceRole;
        #
        #
        #                    // Initialize from SLJAE
        #                    accountingDistributionTmp.IsCorrection = subledgerJournalAccountEntry.IsCorrection;
        #                    accountingDistributionTmp.TransferPolicy = subledgerJournalAccountEntry.IsTransferredInDetail;
        #                    accountingDistributionTmp.PostingType = subledgerJournalAccountEntry.PostingType;
        #                    accountingDistributionTmp.TransactionCurrency = subledgerJournalAccountEntry.TransactionCurrency;
        #                    accountingDistributionTmp.ExchangeRateDate = subledgerJournalAccountEntry.ExchangeRateDate;
        #                    accountingDistributionTmp.ExchangeRate1 = subledgerJournalAccountEntry.ExchangeRate1;
        #                    accountingDistributionTmp.ExchangeRate2 = subledgerJournalAccountEntry.ExchangeRate2;
        #                    if (accountingDistributionTmp.ReportingCurrency)
        #                    {
        #                        accountingDistributionTmp.ReportingExchangeRate1 = subledgerJournalAccountEntry.ReportingExchangeRate1;
        #                        accountingDistributionTmp.ReportingExchangeRate2 = subledgerJournalAccountEntry.ReportingExchangeRate2;
        #                    }
        #                    accountingDistributionTmp.LedgerDimension = subledgerJournalAccountEntry.LedgerDimension;
        #                    accountingDistributionTmp.AmountSign = (subledgerJournalAccountEntry.TransactionCurrencyAmount >0 ? DebitCredit::Debit : DebitCredit::Credit);
        #                    accountingDistributionTmp.NegativeAmountSign = (accountingDistributionTmp.AmountSign == DebitCredit::Credit)? DebitCredit::Debit : DebitCredit::Credit;
        #                    if ((accountingDistributionTmp.AmountSign == DebitCredit::Credit && accountingDistribution.TransactionCurrencyAmount <0) ||
        #                        (accountingDistributionTmp.AmountSign == DebitCredit::Debit && accountingDistribution.TransactionCurrencyAmount >0))
        #                    {
        #                        accountingDistributionTmp.TransactionCurrencyAmount = -accountingDistribution.TransactionCurrencyAmount;
        #
        #                    }
        #                    else
        #                    {
        #                        accountingDistributionTmp.TransactionCurrencyAmount = accountingDistribution.TransactionCurrencyAmount;
        #                    }
        #
        #                    this.calculateForeignCurAmounts(accountingDistributionTmp);
        #
        #                    if (accountingDistributionTmp.TransactionCurrencyAmount > 0||
        #                        (accountingDistributionTmp.TransactionCurrencyAmount < 0 && accountingDistributionTmp.IsCorrection))
        #                    {
        #                        accountingDistributionTmp.AmountSign = DebitCredit::Debit;
        #                        accountingDistributionTmp.NegativeAmountSign = (accountingDistributionTmp.AmountSign == DebitCredit::Credit)? DebitCredit::Debit : DebitCredit::Credit;
        #                    }
        #                    else
        #                    {
        #                        accountingDistributionTmp.AmountSign = DebitCredit::Credit;
        #                        accountingDistributionTmp.NegativeAmountSign = (accountingDistributionTmp.AmountSign == DebitCredit::Credit)? DebitCredit::Debit : DebitCredit::Credit;
        #                    }
        #
        #                    //intercompany details
        #                    accountingDistributionTmp.IsIntercompany = isInterCompany;
        #                    accountingDistributionTmp.InterCompanyPostingType = LedgerPostingType::InterCompany;
        #
        #                    accountingDistributionTmp.initFromAccountingDistributionTmp(accountingDistributionTmp);
        #
        #                    recordInsertList.add(accountingDistributionTmp);
        #
        #                    hasRelieving = true;
        #                }
        #            }
        #
        #            // Period Close/Open Reversals
        #
        #            if ((accountingEventType == AccountingEventType::PeriodClose ||
        #                accountingEventType == AccountingEventType::PeriodOpen) &&
        #                accountingDistributionTmpJournalize.ReferenceDistribution != 0)
        #            {
        #
        #                while select SourceDocumentLine, RecId, LedgerDimension, TransactionCurrency, TransactionCurrencyAmount, ParentDistribution, AccountingDate, AccountingEvent, ReferenceRole
        #                    from accountingDistribution
        #                        where accountingDistribution.RecId == accountingDistributionTmpJournalize.ReferenceDistribution
        #                    join AccountingDistribution, SubledgerJournalAccountEntry from subledgerJournalAccountEntryDistribution
        #                        where subledgerJournalAccountEntryDistribution.AccountingDistribution ==  accountingDistribution.RecId
        #                    join RecId, Side, SubledgerJournalEntry, IsCorrection, PostingType, ExchangeRate1, ReportingExchangeRate1, TransactionCurrencyAmount, TransactionCurrency, LedgerDimension, ExchangeRate2, ReportingExchangeRate2, ExchangeRateDate, IsTransferredInDetail
        #                    from subledgerJournalAccountEntry
        #                        where subledgerJournalAccountEntry.RecId == subledgerJournalAccountEntryDistribution.SubledgerJournalAccountEntry
        #                    join RecId, Ledger, Type
        #                    from subledgerJournalEntry
        #                        where subledgerJournalEntry.RecId == subledgerJournalAccountEntry.SubledgerJournalEntry &&
        #                              subledgerJournalEntry.AccountingEvent == accountingDistribution.AccountingEvent
        #                {
        #
        #                    accountingDistributionTmp.clear();
        #
        #                    accountingDistributionTmp.IsRelieving = false;
        #                    accountingDistributionTmp.IsFinalizing = false;
        #                    accountingDistributionTmp.IsYearEnd = true;
        #
        #                    //Initialize from SLJE
        #                    switch (accountingEventType)
        #                    {
        #                        case AccountingEventType::PeriodClose:
        #                            accountingDistributionTmp.YearEndReversalSubledgerJournalEntryType = SubledgerJournalEntryType::PeriodClosed;
        #                            break;
        #                        case AccountingEventType::PeriodOpen:
        #                            accountingDistributionTmp.YearEndReversalSubledgerJournalEntryType = SubledgerJournalEntryType::PeriodOpened;
        #                            break;
        #                        default:
        #                            accountingDistributionTmp.YearEndReversalSubledgerJournalEntryType = sourceDocumentType.parmSubledgerJournalEntryType();
        #                    }
        #                    accountingDistributionTmp.Ledger = subledgerJournalEntry.Ledger;
        #                    accountingDistributionTmp.initFromLedger(Ledger::find(accountingDistributionTmp.Ledger));
        #
        #                    // Initialize from accountingDistribution
        #                    accountingDistributionTmp.AccountingDistribution = accountingDistribution.RecId;
        #                    accountingDistributionTmp.FiscalCalendarPeriod = this.getFiscalCalendarPeriod(accountingDistributionTmpJournalize.AccountingDate,accountingDistributionTmpJournalize.AccountingLegalEntity);
        #                    accountingDistributionTmp.ParentDistribution = accountingDistributionTmpJournalize.ParentDistribution; //check
        #                    accountingDistributionTmp.AccountingDate = accountingDistributionTmpJournalize.AccountingDate;
        #                    accountingDistributionTmp.AccountingEvent = accountingDistributionTmpJournalize.AccountingEvent;
        #                    accountingDistributionTmp.SourceDocumentLine = accountingDistributionTmpJournalize.SourceDocumentLine;
        #                    accountingDistributionTmp.ReferenceRole = accountingDistributionTmpJournalize.ReferenceRole;
        #
        #
        #                    // Initialize from SLJAE
        #                    accountingDistributionTmp.IsCorrection = subledgerJournalAccountEntry.IsCorrection;
        #                    accountingDistributionTmp.TransferPolicy = subledgerJournalAccountEntry.IsTransferredInDetail;
        #                    accountingDistributionTmp.PostingType = subledgerJournalAccountEntry.PostingType;
        #                    accountingDistributionTmp.TransactionCurrency = subledgerJournalAccountEntry.TransactionCurrency;
        #                    accountingDistributionTmp.ExchangeRateDate = subledgerJournalAccountEntry.ExchangeRateDate;
        #                    accountingDistributionTmp.ExchangeRate1 = subledgerJournalAccountEntry.ExchangeRate1;
        #                    accountingDistributionTmp.ExchangeRate2 = subledgerJournalAccountEntry.ExchangeRate2;
        #                    if (accountingDistributionTmp.ReportingCurrency)
        #                    {
        #                        accountingDistributionTmp.ReportingExchangeRate1 = subledgerJournalAccountEntry.ReportingExchangeRate1;
        #                        accountingDistributionTmp.ReportingExchangeRate2 = subledgerJournalAccountEntry.ReportingExchangeRate2;
        #                    }
        #                    accountingDistributionTmp.LedgerDimension = subledgerJournalAccountEntry.LedgerDimension;
        #                    accountingDistributionTmp.AmountSign = (subledgerJournalAccountEntry.Side == DebitCredit::Credit ? DebitCredit::Debit : DebitCredit::Credit);
        #                    accountingDistributionTmp.NegativeAmountSign = (accountingDistributionTmp.AmountSign == DebitCredit::Credit)? DebitCredit::Debit : DebitCredit::Credit;
        #                    if (subledgerJournalAccountEntry.TransactionCurrencyAmount > 0)
        #                    {
        #                        accountingDistributionTmp.TransactionCurrencyAmount = -abs(accountingDistributionTmpJournalize.TransactionCurrencyAmount);
        #
        #                    }
        #                    else
        #                    {
        #                        accountingDistributionTmp.TransactionCurrencyAmount = abs(accountingDistributionTmpJournalize.TransactionCurrencyAmount);
        #                    }
        #
        #                    this.calculateForeignCurAmounts(accountingDistributionTmp);
        #
        #                    //intercompany details
        #                    accountingDistributionTmp.IsIntercompany = isInterCompany;
        #                    accountingDistributionTmp.InterCompanyPostingType = LedgerPostingType::InterCompany;
        #
        #                    accountingDistributionTmp.initFromAccountingDistributionTmp(accountingDistributionTmp);
        #
        #                    recordInsertList.add(accountingDistributionTmp);
        #
        #                    hasYearEnd = true;
        #                }
        #            }
        #        }
        #    }
        #
        #    this.loadAccDistTmpRelieveAccrual(_sourceDocument);
        #
        #
        #    //Populate Distributions Tmp Table for the Reversal Scenario
        #    //Reversal is handled differently because we want to get the same accounts and amounts
        #    //Hence we use the links to get to the original accounting entries and use the accounts and amounts.
        #    //Since the setup entities associated are not date effective, we cannot rely on the
        #    //setup to consistently give the same account. Also the amounts could include
        #    //rounded amounts and we want to reverse exactly what was recorded.
        #    //Also the accountingcurrency exchange rate and reporting currency exchange rate are all
        #    // used based on what is already recorded in SLJ
        #
        #    select firstOnly recId from reversingAccountingDistribution
        #        where reversingAccountingDistribution.ReferenceRole == AccountingDistributionReferenceRole::Reversing &&
        #              reversingAccountingDistribution.SourceDocumentHeader == sourceDocumentHeaderRecId
        #        join RecId, State from reversingAccountingEvent
        #            where reversingAccountingEvent.RecId ==  reversingAccountingDistribution.AccountingEvent &&
        #                  reversingAccountingEvent.State == AccountingEventState::Started;
        #
        #    if (reversingAccountingDistribution)
        #    {
        #        while select reversingAccountingDistribution
        #            where reversingAccountingDistribution.ReferenceRole == AccountingDistributionReferenceRole::Reversing &&
        #                  reversingAccountingDistribution.SourceDocumentHeader == sourceDocumentHeaderRecId
        #            join RecId, State from reversingAccountingEvent
        #                where reversingAccountingEvent.RecId ==  reversingAccountingDistribution.AccountingEvent &&
        #                      reversingAccountingEvent.State == AccountingEventState::Started
        #            join AccountingDistribution, SubledgerJournalAccountEntry from subledgerJournalAccountEntryDistribution
        #                where subledgerJournalAccountEntryDistribution.AccountingDistribution == reversingAccountingDistribution.ReferenceDistribution
        #            join RecId, Side, SubledgerJournalEntry, IsCorrection, PostingType, ExchangeRate1, ReportingExchangeRate1, TransactionCurrencyAmount, TransactionCurrency, LedgerDimension, ExchangeRate2, ReportingExchangeRate2, ExchangeRateDate, IsTransferredInDetail
        #                from subledgerJournalAccountEntry
        #                where subledgerJournalAccountEntry.RecId == subledgerJournalAccountEntryDistribution.SubledgerJournalAccountEntry
        #            join Type, Ledger, FiscalCalendarPeriod from subledgerJournalEntry
        #                where subledgerJournalEntry.RecId == subledgerJournalAccountEntry.SubledgerJournalEntry
        #        {
        #            // Buffer materializations are very expensive and few ledgers are in use, so cache
        #            // the buffer instances within this method scope to reduce the number of materializations
        #            ledgerRecId = subledgerJournalEntry.Ledger;
        #            if (!ledgerByRecId.exists(ledgerRecId))
        #            {
        #                ledgerByRecId.insert(ledgerRecId, Ledger::find(ledgerRecId));
        #            }
        #            accountingDistributionLedger = ledgerByRecId.lookup(ledgerRecId);
        #
        #            accountingDistributionTmp.clear();
        #            accountingDistributionTmp.initFromAccountingDistribution(reversingAccountingDistribution);
        #            accountingDistributionTmp.initFromLedger(accountingDistributionLedger);
        #            accountingDistributionTmp.SourceDocumentLine = reversingAccountingDistribution.SourceDocumentLine;
        #
        #            accountingDistributionTmp.LedgerDimension = subledgerJournalAccountEntry.LedgerDimension;
        #            accountingDistributionTmp.PostingType = subledgerJournalAccountEntry.PostingType;
        #            accountingDistributionTmp.ExchangeRateDate = subledgerJournalAccountEntry.ExchangeRateDate;
        #            accountingDistributionTmp.ExchangeRate1 = subledgerJournalAccountEntry.ExchangeRate1;
        #            accountingDistributionTmp.ExchangeRate2 = subledgerJournalAccountEntry.ExchangeRate2;
        #            accountingDistributionTmp.SubledgerJournalEntryType = subledgerJournalEntry.Type;
        #
        #            if (accountingDistributionTmp.ReportingCurrency)
        #            {
        #                accountingDistributionTmp.ReportingExchangeRate1 = subledgerJournalAccountEntry.ReportingExchangeRate1;
        #                accountingDistributionTmp.ReportingExchangeRate2 = subledgerJournalAccountEntry.ReportingExchangeRate2;
        #            }
        #            accountingDistributionTmp.IsCorrection = subledgerJournalAccountEntry.IsCorrection;
        #            accountingDistributionTmp.AmountSign = (subledgerJournalAccountEntry.Side == DebitCredit::Credit ? DebitCredit::Debit : DebitCredit::Credit);
        #            accountingDistributionTmp.NegativeAmountSign = (accountingDistributionTmp.AmountSign == DebitCredit::Credit)? DebitCredit::Debit : DebitCredit::Credit;
        #            accountingDistributionTmp.FiscalCalendarPeriod = subledgerJournalEntry.FiscalCalendarPeriod;
        #            if (subledgerJournalAccountEntry.TransactionCurrencyAmount < 0)
        #            {
        #                accountingDistributionTmp.TransactionCurrencyAmount = abs(reversingAccountingDistribution.TransactionCurrencyAmount);
        #            }
        #            else
        #            {
        #                accountingDistributionTmp.TransactionCurrencyAmount = -abs(reversingAccountingDistribution.TransactionCurrencyAmount);
        #            }
        #            this.calculateForeignCurAmounts(accountingDistributionTmp);
        #            accountingDistributionTmp.TransferPolicy = subledgerJournalAccountEntry.IsTransferredInDetail;
        #            accountingDistributionTmp.InterCompanyPostingType = LedgerPostingType::InterCompany;
        #            accountingDistributionTmp.initFromAccountingDistributionTmp(accountingDistributionTmp);
        #            accountingDistributionTmp.IsRelieving = false;
        #            recordInsertList.add(accountingDistributionTmp);
        #        }
        #    }
        #    recordInsertList.insertDatabase();
        #}
      ENDSOURCE
      SOURCE #psaLoadAccountingEventHandler
        #delegate void psaLoadAccountingEventHandler(
        #    SourceDocumentLine                      _sourceDocumentLine,
        #    SourceDocumentLineItemTmp               _sourceDocumentLineItemTmp,
        #    AccountingDistributionTmpJournalize     _accountingDistributionTmpJournalize,
        #    Ledger                                  _accountingDistributionLedger,
        #    SourceDocumentType                      _sourceDocumentType,
        #    SourceDocumentLineItem                  _sourceDocumentLineItem,
        #    AccountingJournalizingRule              _journalizingAccountingRule,
        #    LedgerDimensionAllocation               _ledgerDimensionAllocation,
        #    RecordInsertList                        _recordInsertList,
        #    AccountingEventType                     _accountingEventType,
        #    boolean                                 _isInterCompany,
        #    boolean                                 _isCorrection,
        #    container                               _exchangeRatesContainer,
        #    container                               _reportingExchangeRatesContainer
        #)
        #{
        #}
      ENDSOURCE
      SOURCE #recognizePennyDifference
        #private void recognizePennyDifference(SourceDocument _sourceDocument, SubledgerJournalAccountEntryTmpSummary _tmpSummary)
        #{
        #    SubledgerJourPennyDiffRecognizer pennyDifferenceRecognizer;
        #
        #    pennyDifferenceRecognizer = SubledgerJourPennyDiffRecognizer::construct();
        #    pennyDifferenceRecognizer.recognizePennyDifference(_sourceDocument, _tmpSummary);
        #}
      ENDSOURCE
      SOURCE #recordCorrectionRelievingExtension
        #/// <summary>
        #///   Event is called before inserting correction relieving entries to subledger journal account entry from <c>SubledgerJournalAccountEntryRelievingTmp</c> to override standard statement.
        #/// </summary>
        #/// <param name="_sysEventOverride">
        #///   Insertion override status.
        #/// </param>
        #/// <param name="_subledgerJournalEntry">
        #///   Record Id of subledger entry.
        #/// </param>
        #/// <param name="_subledgerJournalAccountEntryCorrectionRelievingTmp">
        #///   The source <c>SubledgerJournalAccountEntryRelievingTmp</c> table.
        #/// </param>
        #delegate void recordCorrectionRelievingExtension(
        #    SysEventOverride _sysEventOverride,
        #    SubledgerJournalEntryRecId _subledgerJournalEntry,
        #    SubledgerJournalAccountEntryRelievingTmp _subledgerJournalAccountEntryCorrectionRelievingTmp)
        #{
        #}
      ENDSOURCE
      SOURCE #recordCorrectionRelievingInExtension
        #/// <summary>
        #///   Raises event to allow extensions to override rounding of <c>SubledgerJournalAccountEntryTmpDetail</c> records.
        #/// </summary>
        #/// <param name="_subledgerJournalEntry">
        #///   Record Id of subledger entry.
        #/// </param>
        #/// <param name="_subledgerJournalAccountEntryCorrectionRelievingTmp">
        #///   The source <c>SubledgerJournalAccountEntryRelievingTmp</c> table.
        #/// </param>
        #/// <returns>
        #///   true if records were inserted in extension; otherwise, false.
        #/// </returns>
        #protected boolean recordCorrectionRelievingInExtension(SubledgerJournalEntryRecId _subledgerJournalEntry, SubledgerJournalAccountEntryRelievingTmp _subledgerJournalAccountEntryCorrectionRelievingTmp)
        #{
        #    SysEventOverride override = SysEventOverride::construct();
        #
        #    this.recordCorrectionRelievingExtension(override, _subledgerJournalEntry, _subledgerJournalAccountEntryCorrectionRelievingTmp);
        #
        #    return override.isOverridden();
        #}
        #
      ENDSOURCE
      SOURCE #recordedSubledgerJournalAccountEntries
        #/// <summary>
        #/// Serves as a subledger journal account entry recorded delegate.
        #/// </summary>
        #/// <param name="_subledgerJournalizerExtensionArgs">
        #/// A <c>SubledgerJournalizerExtensionArg</c> instance.
        #/// </param>
        #delegate void recordedSubledgerJournalAccountEntries(SubledgerJournalizerExtensionArgs _subledgerJournalizerExtensionArgs)
        #{
        #}
      ENDSOURCE
      SOURCE #recordingSubledgerJournalAccountEntries
        #/// <summary>
        #/// Serves as a subledger journal account entry recording delegate.
        #/// </summary>
        #/// <param name="_subledgerJournalizerExtensionArgs">
        #/// A <c>SubledgerJournalizerExtensionArg</c> instance.
        #/// </param>
        #delegate void recordingSubledgerJournalAccountEntries(SubledgerJournalizerExtensionArgs _subledgerJournalizerExtensionArgs)
        #{
        #}
      ENDSOURCE
      SOURCE #recordRelievingSubledgerJournalEntries
        #protected void recordRelievingSubledgerJournalEntries()
        #{
        #    SubledgerJournalAccountEntry        subledgerJournalAccountEntry;
        #    SubledgerJournalEntryRecId          subledgerJournalEntryRecId;
        #    SubledgerJournalAccountEntryRelievingTmp subledgerJournalAccountEntryCorrectionRelievingTmp;
        #
        #    select firstonly SubledgerJournalEntry from subledgerJournalAccountEntryTmpDetail;
        #    subledgerJournalEntryRecId = subledgerJournalAccountEntryTmpDetail.SubledgerJournalEntry;
        #
        #    subledgerJournalReliever.updateRelievingRelations(subledgerJournalAccountEntryTmpDetail, subledgerJournalAccountEntryRelievingTmp);
        #    subledgerJournalReliever.correctRelieving(subledgerJournalAccountEntryCorrectionRelievingTmp, subledgerJournalEntryRecId);
        #
        #    subledgerJournalAccountEntry.skipDataMethods(true);
        #    subledgerJournalAccountEntry.skipDatabaseLog(true);
        #    // <GEEU>
        #    if (!this.recordCorrectionRelievingInExtension(subledgerJournalEntryRecId, subledgerJournalAccountEntryCorrectionRelievingTmp))
        #    {
        #    // </GEEU>
        #    insert_recordset subledgerJournalAccountEntry(SubledgerJournalEntry,
        #                                                  LedgerDimension,
        #                                                  PostingType,
        #                                                  ExchangeRateDate,
        #                                                  HistoricalExchangeRateDate,
        #                                                  ExchangeRate1,
        #                                                  ReportingExchangeRate1,
        #                                                  ExchangeRate2,
        #                                                  ReportingExchangeRate2,
        #                                                  TransactionCurrency,
        #                                                  TransactionCurrencyAmount,
        #                                                  AccountingCurrencyAmount,
        #                                                  ReportingCurrencyAmount,
        #                                                  IsTransferredInDetail,
        #                                                  IsCorrection,
        #                                                  Side,
        #                                                  OriginalTransferPolicy
        #                                                  )
        #    select subledgerJournalEntryRecId,
        #           LedgerDimension,
        #           PostingType,
        #           ExchangeRateDate,
        #           HistoricalExchangeRateDate,
        #           ExchangeRate1,
        #           ReportingExchangeRate1,
        #           ExchangeRate2,
        #           ReportingExchangeRate2,
        #           TransactionCurrency,
        #           sum(TransactionCurrencyAmount),
        #           sum(AccountingCurrencyAmount),
        #           sum(ReportingCurrencyAmount),
        #           IsTransferredInDetail,
        #           IsCorrection,
        #           Side,
        #           OriginalTransferPolicy
        #    from subledgerJournalAccountEntryCorrectionRelievingTmp
        #        group by LedgerDimension, PostingType, ExchangeRateDate, HistoricalExchangeRateDate, ExchangeRate1, TransactionCurrency,
        #                 ReportingExchangeRate1, ExchangeRate2, ReportingExchangeRate2, OriginalTransferPolicy, IsCorrection, Side, IsTransferredInDetail;
        #    // <GEEU>
        #    }
        #    // </GEEU>
        #
        #    subledgerJournalReliever.updateCorrectedRelations(subledgerJournalAccountEntryCorrectionRelievingTmp, subledgerJournalEntryRecId);
        #}
      ENDSOURCE
      SOURCE #recordSubledgerJourAccEntriesForRounding
        #private void recordSubledgerJourAccEntriesForRounding(SourceDocument _sourceDocument, AccountingEvent _accountingEvent)
        #{
        #    SubledgerJournalEntry                       subledgerJournalEntry;
        #    LedgerParameters                            ledgerParameters;
        #    boolean                                     isValid;
        #    List                                        distributionIdList;
        #    NumberSequenceReference                     numberSequenceReference;
        #    MainAccount                                 mainAccount;
        #    DataAreaId                                  dataAreaId;
        #    NumberSequenceTable                         numberSequenceTable;
        #    SubledgerJournalAccountEntry                subledgerJournalAccountEntry;
        #    Map                                         legalEntityVouchers;
        #    Map                                         finalizeVouchers;
        #    SubledgerJournalizerExtensionArgs           subledgerJournalizerExtensionArgs;
        #    SubledgerJournalAccountEntryTmpSummary      subledgerJournalAccountEntryTmpSummary;
        #
        #    subledgerJournalizerExtensionArgs = SubledgerJournalizerExtensionArgs::construct();
        #    subledgerJournalizerExtensionArgs.parmAccountingEvent(_accountingEvent);
        #    this.recordingSubledgerJournalAccountEntries(subledgerJournalizerExtensionArgs);
        #
        #    isValid = true;
        #    distributionIdList = new List(Types::Container);
        #    legalEntityVouchers = new Map(Types::String, Types::String);
        #    finalizeVouchers = new Map(Types::String, Types::String);
        #
        #    this.loadSubledgerJournalTmpDetail(_accountingEvent);
        #    this.loadSubledgerJourTmpDetailWithRelieving(_accountingEvent);
        #
        #    numberSequenceReference = NumberSequenceReference::findByDatatypeAndScope(extendedTypeNum(SubledgerJournalNum));
        #
        #    ttsbegin;
        #    this.clearSubledgerJournalErrorLog(_accountingEvent.RecId);
        #
        #    numberSequenceTable = NumberSequenceReference::findByDatatypeAndScope(extendedTypeNum(GeneralJournalEntryJournalNumber)).numberSequenceTable();
        #    if (!numberSequenceTable)
        #    {
        #        // Cannot transfer entries to the General ledger. A number sequence requires for Subledger journal transfer.
        #        isValid = this.addToSubledgerJournalErrorLog(_accountingEvent.RecId, Exception::Warning, literalStr("@SYS321147"));
        #        isValid = checkFailed(strFmt("@SYS321147"));
        #    }
        #
        #    while select LegalEntity, FiscalCalendarPeriod, PostingLayer, Ledger, SubledgerJournalEntryType from subledgerJournalAccountEntryTmpDetail
        #         group by LegalEntity, FiscalCalendarPeriod, PostingLayer, Ledger, SubledgerJournalEntryType
        #            where subledgerJournalAccountEntryTmpDetail.AccountingEvent == _accountingEvent.RecId
        #    {
        #        subledgerJournalEntry.clear();
        #        subledgerJournalEntry.JournalNumber        = NumberSeq::newGetNum(NumberSequenceReference::findByDatatypeAndScope(extendedTypeNum(SubledgerJournalNum))).num();
        #        subledgerJournalEntry.PostingLayer         = subledgerJournalAccountEntryTmpDetail.PostingLayer;
        #        subledgerJournalEntry.AccountingEvent      = _accountingEvent.RecId;
        #
        #        subledgerJournalEntry.Ledger = subledgerJournalAccountEntryTmpDetail.Ledger;
        #
        #        subledgerJournalEntry.FiscalCalendarPeriod = subledgerJournalAccountEntryTmpDetail.FiscalCalendarPeriod;
        #        subledgerJournalEntry.Type = subledgerJournalAccountEntryTmpDetail.SubledgerJournalEntryType;
        #        dataAreaId = CompanyInfo::getDataArea(subledgerJournalAccountEntryTmpDetail.LegalEntity);
        #
        #        subledgerJournalEntry.Voucher = this.getVoucher(_sourceDocument, _accountingEvent, legalEntityVouchers, finalizeVouchers, dataAreaId);
        #        subledgerJournalEntry.VoucherDataAreaId = dataAreaId;
        #        subledgerJournalEntry.ReferenceIdentityTransferStatus = this.markReferenceIdentityStatus();
        #
        #        ledgerParameters = LedgerParameters::findByCompany(dataAreaId);
        #        // Not good to pass entire buffer when  only some fields are initialized
        #        isValid = this.validateSubledgerJournalEntry(subledgerJournalEntry, _accountingEvent, _sourceDocument, ledgerParameters);
        #        subledgerJournalEntry.insert();
        #
        #        subledgerJournalEntries.insert(
        #            [subledgerJournalEntry.Voucher, _accountingEvent.AccountingDate, subledgerJournalEntry.Type, subledgerJournalEntry.PostingLayer],
        #            subledgerJournalEntry);
        #    }
        #
        #    // handles multiple ledgers per accounting event
        #    update_recordset subledgerJournalAccountEntryTmpDetail
        #        setting SubledgerJournalEntry = subledgerJournalEntry.RecId
        #        join RecId from subledgerJournalEntry
        #        where subledgerJournalEntry.AccountingEvent == _accountingEvent.RecId &&
        #            subledgerJournalAccountEntryTmpDetail.AccountingEvent == subledgerJournalEntry.AccountingEvent &&
        #            subledgerJournalEntry.Ledger == subledgerJournalAccountEntryTmpDetail.Ledger &&
        #            subledgerJournalEntry.FiscalCalendarPeriod == subledgerJournalAccountEntryTmpDetail.FiscalCalendarPeriod &&
        #            subledgerJournalEntry.PostingLayer == subledgerJournalAccountEntryTmpDetail.PostingLayer &&
        #            subledgerJournalEntry.Type == subledgerJournalAccountEntryTmpDetail.SubledgerJournalEntryType;
        #
        #    this.summarizeJourAccountEntryDetailForRound(subledgerJournalAccountEntryTmpDetail, subledgerJournalAccountEntryTmpSummary, AccountingEventState::Started);
        #
        #    this.performSummaryLevelRoundingAdjustment(sourceDocument, subledgerJournalAccountEntryTmpSummary);
        #
        #    this.recognizePennyDifference(sourceDocument, subledgerJournalAccountEntryTmpSummary);
        #
        #    subledgerJournalAccountEntry.skipDataMethods(true);
        #
        #    this.performSubledgerAllocation(subledgerJournalAccountEntryTmpSummary);
        #
        #    insert_recordset subledgerJournalAccountEntry(SubledgerJournalEntry,
        #                                                  LedgerDimension,
        #                                                  PostingType,
        #                                                  ExchangeRateDate,
        #                                                  HistoricalExchangeRateDate,
        #                                                  ExchangeRate1,
        #                                                  ReportingExchangeRate1,
        #                                                  ExchangeRate2,
        #                                                  ReportingExchangeRate2,
        #                                                  TransactionCurrency,
        #                                                  TransactionCurrencyAmount,
        #                                                  AccountingCurrencyAmount,
        #                                                  ReportingCurrencyAmount,
        #                                                  IsTransferredInDetail,
        #                                                  IsCorrection,
        #                                                  Side,
        #                                                  OriginalTransferPolicy)
        #
        #    select SubledgerJournalEntry,
        #           LedgerDimension,
        #           PostingType,
        #           ExchangeRateDate,
        #           HistoricalExchangeRateDate,
        #           ExchangeRate1,
        #           ReportingExchangeRate1,
        #           ExchangeRate2,
        #           ReportingExchangeRate2,
        #           TransactionCurrencyCode,
        #           TransactionCurrencyAmount,
        #           AccountingCurrencyAmount,
        #           ReportingCurrencyAmount,
        #           TransferPolicy,
        #           IsCorrection,
        #           DebitCredit,
        #           TransferPolicy
        #    from subledgerJournalAccountEntryTmpSummary;
        #
        #    while select subledgerJournalAccountEntryTmpSummary
        #    {
        #        ledgerParameters = LedgerParameters::findByCompany(CompanyInfo::getDataArea(subledgerJournalAccountEntryTmpSummary.LegalEntity));
        #        isValid = this.validateSubledgerJournalAccountEntry(
        #                        subledgerJournalAccountEntryTmpSummary.LedgerDimension,
        #                        subledgerJournalAccountEntryTmpSummary.PostingType,
        #                        subledgerJournalAccountEntryTmpSummary.TransactionCurrencyCode,
        #                        _accountingEvent,
        #                        _sourceDocument,
        #                        ledgerParameters,
        #                        subledgerJournalAccountEntryTmpSummary.SkipAccountValidation) && isValid;
        #    }
        #    if (isValid)
        #    {
        #        //the following loop could be replaced by set based validation SQL
        #        while select subledgerJournalAccountEntryTmpSummary
        #        {
        #            if (isValid)
        #            {
        #                mainAccount = DimensionStorage::getMainAccountFromLedgerDimension(subledgerJournalAccountEntryTmpSummary.LedgerDimension);
        #                isValid = this.checkDebitCreditForTmpSummary(subledgerJournalAccountEntryTmpSummary, mainAccount);
        #            }
        #        }
        #    }
        #
        #    if (isValid)
        #    {
        #        this.recordSubledgerJournalAcctEntriesDist(_accountingEvent);
        #    }
        #
        #    subledgerJournalizerExtensionArgs.parmIsDimensionBalanced(true);
        #
        #    subledgerJournalizerExtensionArgs.parmSubledgerJournalEntries(subledgerJournalEntries);
        #
        #    this.recordRelievingSubledgerJournalEntries();
        #
        #    this.recordedSubledgerJournalAccountEntries(subledgerJournalizerExtensionArgs);
        #    isValid = this.validateDebitCreditBalance(_accountingEvent) && this.validateTransferEntriesBalance(_accountingEvent) && isValid && subledgerJournalizerExtensionArgs.parmIsDimensionBalanced();
        #
        #    if (!isValid)
        #    {
        #        ttsabort;
        #        throw error("@SYS21533"); //Posting has been cancelled
        #    }
        #
        #    ttscommit;
        #}
      ENDSOURCE
      SOURCE #recordSubledgerJournalAccountEntries
        #protected void recordSubledgerJournalAccountEntries(SourceDocument _sourceDocument,
        #                                                    AccountingEvent _accountingEvent)
        #{
        #    SubledgerJournalEntry                       subledgerJournalEntry;
        #    LedgerParameters                            ledgerParameters;
        #    boolean                                     isValid;
        #    List                                        distributionIdList;
        #    NumberSequenceReference                     numberSequenceReference;
        #    MainAccount                                 mainAccount;
        #    DataAreaId                                  dataAreaId;
        #    NumberSequenceTable                         numberSequenceTable;
        #    SubledgerJournalAccountEntry                subledgerJournalAccountEntry;
        #    Map                                         legalEntityVouchers;
        #    Map                                         finalizeVouchers;
        #    SubledgerJournalizerExtensionArgs           subledgerJournalizerExtensionArgs;
        #    SubledgerJournalAccountEntryTmpSummary      subledgerJournalAccountEntryTmpSummary;
        #
        #    subledgerJournalizerExtensionArgs = SubledgerJournalizerExtensionArgs::construct();
        #    subledgerJournalizerExtensionArgs.parmAccountingEvent(_accountingEvent);
        #    this.recordingSubledgerJournalAccountEntries(subledgerJournalizerExtensionArgs);
        #
        #    isValid = true;
        #    distributionIdList = new List(Types::Container);
        #    legalEntityVouchers = new Map(Types::String, Types::String);
        #    finalizeVouchers = new Map(Types::String, Types::String);
        #
        #
        #    this.loadSubledgerJournalTmpDetail(_accountingEvent);
        #
        #        this.loadSubledgerJourTmpDetailWithRelieving(_accountingEvent);
        #
        #    numberSequenceReference = NumberSequenceReference::findByDatatypeAndScope(extendedTypeNum(SubledgerJournalNum));
        #
        #    ttsbegin;
        #    this.clearSubledgerJournalErrorLog(_accountingEvent.RecId);
        #
        #    numberSequenceTable = NumberSequenceReference::findByDatatypeAndScope(extendedTypeNum(GeneralJournalEntryJournalNumber)).numberSequenceTable();
        #    if (!numberSequenceTable)
        #    {
        #        // Cannot transfer entries to the General ledger. A number sequence requires for Subledger journal transfer.
        #        isValid = this.addToSubledgerJournalErrorLog(_accountingEvent.RecId, Exception::Warning, literalStr("@SYS321147"));
        #        isValid = checkFailed(strFmt("@SYS321147"));
        #    }
        #
        #    while select LegalEntity, FiscalCalendarPeriod, PostingLayer, Ledger, SubledgerJournalEntryType from subledgerJournalAccountEntryTmpDetail
        #         group by LegalEntity, FiscalCalendarPeriod, PostingLayer, Ledger, SubledgerJournalEntryType
        #            where subledgerJournalAccountEntryTmpDetail.AccountingEvent == _accountingEvent.RecId
        #    {
        #        subledgerJournalEntry.clear();
        #        subledgerJournalEntry.JournalNumber        = NumberSeq::newGetNum(NumberSequenceReference::findByDatatypeAndScope(extendedTypeNum(SubledgerJournalNum))).num();
        #        subledgerJournalEntry.PostingLayer         = subledgerJournalAccountEntryTmpDetail.PostingLayer;
        #        subledgerJournalEntry.AccountingEvent      = _accountingEvent.RecId;
        #
        #        subledgerJournalEntry.Ledger = subledgerJournalAccountEntryTmpDetail.Ledger;
        #
        #        subledgerJournalEntry.FiscalCalendarPeriod = subledgerJournalAccountEntryTmpDetail.FiscalCalendarPeriod;
        #        subledgerJournalEntry.Type = subledgerJournalAccountEntryTmpDetail.SubledgerJournalEntryType;
        #        dataAreaId = CompanyInfo::getDataArea(subledgerJournalAccountEntryTmpDetail.LegalEntity);
        #
        #        subledgerJournalEntry.Voucher = this.getVoucher(_sourceDocument, _accountingEvent, legalEntityVouchers, finalizeVouchers, dataAreaId);
        #        subledgerJournalEntry.VoucherDataAreaId = dataAreaId;
        #        subledgerJournalEntry.ReferenceIdentityTransferStatus = this.markReferenceIdentityStatus();
        #
        #        ledgerParameters = LedgerParameters::findByCompany(dataAreaId);
        #        // Not good to pass entire buffer when  only some fields are initialized
        #        isValid = isValid && this.validateSubledgerJournalEntry(subledgerJournalEntry, _accountingEvent, _sourceDocument, ledgerParameters);
        #        subledgerJournalEntry.insert();
        #
        #        subledgerJournalEntries.insert(
        #            [subledgerJournalEntry.Voucher, _accountingEvent.AccountingDate, subledgerJournalEntry.Type, subledgerJournalEntry.PostingLayer],
        #            subledgerJournalEntry);
        #    }
        #
        #    // handles multiple ledgers per accounting event
        #    update_recordset subledgerJournalAccountEntryTmpDetail
        #        setting SubledgerJournalEntry = subledgerJournalEntry.RecId
        #        join RecId from subledgerJournalEntry
        #        where subledgerJournalEntry.AccountingEvent == _accountingEvent.RecId &&
        #            subledgerJournalAccountEntryTmpDetail.AccountingEvent == subledgerJournalEntry.AccountingEvent &&
        #            subledgerJournalEntry.Ledger == subledgerJournalAccountEntryTmpDetail.Ledger &&
        #            subledgerJournalEntry.FiscalCalendarPeriod == subledgerJournalAccountEntryTmpDetail.FiscalCalendarPeriod &&
        #            subledgerJournalEntry.PostingLayer == subledgerJournalAccountEntryTmpDetail.PostingLayer &&
        #            subledgerJournalEntry.Type == subledgerJournalAccountEntryTmpDetail.SubledgerJournalEntryType;
        #
        #    this.summarizeJournalAccountEntryDetail(subledgerJournalAccountEntryTmpDetail, subledgerJournalAccountEntryTmpSummary, AccountingEventState::Started);
        #
        #    this.performSubledgerAllocation(subledgerJournalAccountEntryTmpSummary);
        #
        #    subledgerJournalAccountEntry.skipDataMethods(true);
        #    insert_recordset subledgerJournalAccountEntry(SubledgerJournalEntry,
        #                                                  LedgerDimension,
        #                                                  PostingType,
        #                                                  ExchangeRateDate,
        #                                                  HistoricalExchangeRateDate,
        #                                                  ExchangeRate1,
        #                                                  ReportingExchangeRate1,
        #                                                  ExchangeRate2,
        #                                                  ReportingExchangeRate2,
        #                                                  TransactionCurrency,
        #                                                  TransactionCurrencyAmount,
        #                                                  AccountingCurrencyAmount,
        #                                                  ReportingCurrencyAmount,
        #                                                  IsTransferredInDetail,
        #                                                  IsCorrection,
        #                                                  Side,
        #                                                  OriginalTransferPolicy)
        #
        #    select SubledgerJournalEntry,
        #           LedgerDimension,
        #           PostingType,
        #           ExchangeRateDate,
        #           HistoricalExchangeRateDate,
        #           ExchangeRate1,
        #           ReportingExchangeRate1,
        #           ExchangeRate2,
        #           ReportingExchangeRate2,
        #           TransactionCurrencyCode,
        #           sum(TransactionCurrencyAmount),
        #           sum(AccountingCurrencyAmount),
        #           sum(ReportingCurrencyAmount),
        #           TransferPolicy,
        #           IsCorrection,
        #           DebitCredit,
        #           TransferPolicy
        #    from subledgerJournalAccountEntryTmpSummary
        #        group by LegalEntity, SubledgerJournalEntry, LedgerDimension, PostingType, ExchangeRateDate, HistoricalExchangeRateDate, ExchangeRate1, TransactionCurrencyCode,
        #                 ReportingExchangeRate1, ExchangeRate2, ReportingExchangeRate2, TransferPolicy, IsCorrection, DebitCredit;
        #
        #    // <GEEU>
        #    this.insertedSubledgerJournalAccountEntry(subledgerJournalAccountEntryTmpDetail);
        #    // </GEEU>
        #
        #    while select subledgerJournalAccountEntry
        #        group by LedgerDimension, PostingType, TransactionCurrency
        #            join subledgerJournalAccountEntryTmpSummary
        #                group by LegalEntity, SkipAccountValidation
        #                where subledgerJournalAccountEntryTmpSummary.SubledgerJournalEntry == subledgerJournalAccountEntry.SubledgerJournalEntry &&
        #                    subledgerJournalAccountEntryTmpSummary.LedgerDimension == subledgerJournalAccountEntry.LedgerDimension
        #    {
        #        ledgerParameters = LedgerParameters::findByCompany(CompanyInfo::getDataArea(subledgerJournalAccountEntryTmpSummary.LegalEntity));
        #        isValid = isValid && this.validateSubledgerJournalAccountEntry(
        #                        subledgerJournalAccountEntry.LedgerDimension,
        #                        subledgerJournalAccountEntry.PostingType,
        #                        subledgerJournalAccountEntry.TransactionCurrency,
        #                        _accountingEvent,
        #                        _sourceDocument,
        #                        ledgerParameters,
        #                        subledgerJournalAccountEntryTmpSummary.SkipAccountValidation);
        #    }
        #    if (isValid)
        #    {
        #        //the following loop could be replaced by set based validation SQL
        #        while select subledgerJournalAccountEntry
        #        exists join  subledgerJournalAccountEntryTmpSummary
        #        where subledgerJournalAccountEntryTmpSummary.SubledgerJournalEntry == subledgerJournalAccountEntry.SubledgerJournalEntry
        #        {
        #            if (isValid)
        #            {
        #                mainAccount = DimensionStorage::getMainAccountFromLedgerDimension(subledgerJournalAccountEntry.LedgerDimension);
        #                isValid = this.checkDebitCredit(subledgerJournalAccountEntry, mainAccount);
        #            }
        #        }
        #    }
        #
        #    if (isValid)
        #    {
        #        this.recordSubledgerJournalAcctEntriesDist(_accountingEvent);
        #    }
        #
        #    subledgerJournalizerExtensionArgs.parmIsDimensionBalanced(true);
        #
        #    subledgerJournalizerExtensionArgs.parmSubledgerJournalEntries(subledgerJournalEntries);
        #
        #        this.recordRelievingSubledgerJournalEntries();
        #
        #    this.recordedSubledgerJournalAccountEntries(subledgerJournalizerExtensionArgs);
        #    isValid = isValid && this.validateDebitCreditBalance(_accountingEvent) && this.validateTransferEntriesBalance(_accountingEvent) && subledgerJournalizerExtensionArgs.parmIsDimensionBalanced();
        #
        #    if (!isValid)
        #    {
        #        ttsabort;
        #        throw error("@SYS21533"); //Posting has been cancelled
        #    }
        #
        #    ttscommit;
        #}
      ENDSOURCE
      SOURCE #recordSubledgerJournalAcctEntriesDist
        #private void recordSubledgerJournalAcctEntriesDist(AccountingEvent _accountingEvent)
        #{
        #    SubledgerJournalAccountEntryDistribution        subledgerJournalAccountEntryDistribution;
        #    SubledgerJournalAccountEntry                    subledgerJournalAccountEntry;
        #    boolean                                         canDistributionBeEmpty;
        #
        #    if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        #    {
        #        canDistributionBeEmpty = true;
        #    }
        #
        #    insert_recordset subledgerJournalAccountEntryDistribution(AccountingDistribution,
        #                                                                ParentDistribution,
        #                                                                AccountingCurrencyAmount,
        #                                                                ReportingCurrencyAmount,
        #                                                                SubledgerJournalAccountEntry)
        #
        #    select AccountingDistribution,
        #            ParentDistribution,
        #            maxof(AccountingCurrencyAmount),
        #            maxof(ReportingCurrencyAmount)
        #        from subledgerJournalAccountEntryTmpDetail
        #        group by AccountingDistribution, ParentDistribution
        #        where subledgerJournalAccountEntryTmpDetail.AccountingEvent == _accountingEvent.RecId
        #            && (canDistributionBeEmpty || subledgerJournalAccountEntryTmpDetail.AccountingDistribution != 0)
        #        join RecId from subledgerJournalAccountEntry
        #        group by RecId
        #        where subledgerJournalAccountEntry.SubledgerJournalEntry == subledgerJournalAccountEntryTmpDetail.SubledgerJournalEntry &&
        #                subledgerJournalAccountEntry.LedgerDimension == subledgerJournalAccountEntryTmpDetail.LedgerDimension &&
        #                subledgerJournalAccountEntry.PostingType == subledgerJournalAccountEntryTmpDetail.PostingType &&
        #                subledgerJournalAccountEntry.ExchangeRate1 == subledgerJournalAccountEntryTmpDetail.ExchangeRate1 &&
        #                subledgerJournalAccountEntry.TransactionCurrency == subledgerJournalAccountEntryTmpDetail.TransactionCurrencyCode &&
        #                subledgerJournalAccountEntry.ReportingExchangeRate1 == subledgerJournalAccountEntryTmpDetail.ReportingExchangeRate1 &&
        #                subledgerJournalAccountEntry.IsCorrection == subledgerJournalAccountEntryTmpDetail.IsCorrection &&
        #                subledgerJournalAccountEntry.ExchangeRateDate == subledgerJournalAccountEntryTmpDetail.ExchangeRateDate &&
        #                subledgerJournalAccountEntry.HistoricalExchangeRateDate == subledgerJournalAccountEntryTmpDetail.HistoricalExchangeRateDate &&
        #                subledgerJournalAccountEntry.ExchangeRate2 == subledgerJournalAccountEntryTmpDetail.ExchangeRate2 &&
        #                subledgerJournalAccountEntry.ReportingExchangeRate2 == subledgerJournalAccountEntryTmpDetail.ReportingExchangeRate2 &&
        #                subledgerJournalAccountEntry.Side == subledgerJournalAccountEntryTmpDetail.DebitCredit;
        #
        #    // <GCN> <GEEU>
        #    this.insertedSubledgerJourAccEntryDistr(subledgerJournalAccountEntryTmpDetail, _accountingEvent);
        #    // </GEEU> </GCN>
        #}
      ENDSOURCE
      SOURCE #roundRelievingDifferenceAmount
        #/// <summary>
        #/// Creates rounding relieving difference amount entry when the independent source document line accounting distribution ledger posting amount
        #/// is under or over relieved in the accounting or reporting currency due to rounding.
        #/// </summary>
        #/// <param name="_sourceDocumentLineRelieving">
        #/// The <c>SourceDocumentLineRelieving</c> record that stores relieving relationship between the independent source document line and its
        #/// dependent source document line.
        #/// </param>
        #/// <param name="_independentSourceDocLineAccountingDistribution">
        #/// The independent source document line accounting distribution.
        #/// </param>
        #/// <param name="_independentSourceDocLineSubledgerJournalAccEntryDistAccountingCurrencyAmount">
        #/// The accounting currency amount posted in the subledger journal account entry for the independent source document line accounting distribution.
        #/// </param>
        #/// <param name="_independentSourceDocLineSubledgerJournalAccEntryDistReportingCurrencyAmount">
        #/// The reporting currency amount posted in the subledger journal account entry for the independent source document line accounting distribution.
        #/// </param>
        #/// <param name="_independentSourceDocLineSubledgerJournalAccountEntrySide">
        #/// The amount side for the amount posted in the subledger journal account entry for the independent source document line accounting distribution.
        #/// </param>
        #/// <param name="_monetaryAmount">
        #/// The monetary amount of the relieving and relieved transactions. Optional. Monetary amount restriction is ignored when this value is zero.
        #/// </param>
        #protected void roundRelievingDifferenceAmount(
        #    SourceDocumentLineRelieving _sourceDocumentLineRelieving,
        #    AccountingDistribution _independentSourceDocLineAccountingDistribution,
        #    AmountMST _independentSourceDocLineSubledgerJournalAccEntryDistAccountingCurrencyAmount,
        #    AmountMST _independentSourceDocLineSubledgerJournalAccEntryDistReportingCurrencyAmount,
        #    DebitCredit _independentSourceDocLineSubledgerJournalAccountEntrySide,
        #    MonetaryAmount _monetaryAmount = 0)
        #{
        #    container       totalRelievedForeignCurrencyAmounts;
        #    AmountMST       totalRelievedAccountingCurrencyAmount;
        #    AmountMST       totalRelievedReportingCurrencyAmount;
        #    DebitCredit     accountingCurRoundingAdjustmentSide;
        #    DebitCredit     reportingCurRoundingAdjustmentSide;
        #    AmountCur       accountingCurrencyAdjustmentAmount;
        #    AmountCur       reportingCurrencyAdjustmentAmount;
        #    boolean         isRoundingAdjustmentNeeded;
        #
        #    if (_sourceDocumentLineRelieving.AllocationFactor == 1 - ATC_SubledgerJournalizer::getTotalRelievedAllocationFactor(_sourceDocumentLineRelieving.IndependentSourceDocumentLine, _sourceDocumentLineRelieving.DependentSourceDocumentLine))
        #    {
        #        // Calculate total relieved accounting and report currency amounts for the independent source document line accounting distribution.
        #
        #        totalRelievedForeignCurrencyAmounts = ATC_SubledgerJournalizer::getTotalRelievedForeignCurAmounts(
        #            _sourceDocumentLineRelieving.DependentSourceDocumentLine,
        #            _sourceDocumentLineRelieving.IndependentSourceDocumentLine,
        #            _independentSourceDocLineAccountingDistribution.AllocationFactor,
        #            accountingDistributionTmp.Ledger,
        #            accountingDistributionTmp.ExchangeRate1,
        #            accountingDistributionTmp.ExchangeRate2,
        #            accountingDistributionTmp.ReportingExchangeRate1,
        #            accountingDistributionTmp.ReportingExchangeRate2,
        #            accountingDistributionTmp.ExchangeRateDate,
        #            accountingDistributionTmp.TransactionCurrency,
        #            _monetaryAmount);
        #
        #        // Use AccountingDistributionTmp.AccountingCurrencyAmount field here because relieving
        #        // subledgerJournalAccountEntry is created based on this amount.
        #        totalRelievedAccountingCurrencyAmount = abs(accountingDistributionTmp.AccountingCurrencyAmount) + abs(conPeek(totalRelievedForeignCurrencyAmounts, 1));
        #        totalRelievedReportingCurrencyAmount = abs(accountingDistributionTmp.ReportingCurrencyAmount) + abs(conPeek(totalRelievedForeignCurrencyAmounts, 2));
        #
        #        isRoundingAdjustmentNeeded = false;
        #
        #        // Compare total independent source document line accounting distribution accounting amount posted with the
        #        // total relieved accounting currency amounts.
        #
        #        if (totalRelievedAccountingCurrencyAmount < abs(_independentSourceDocLineSubledgerJournalAccEntryDistAccountingCurrencyAmount))
        #        {
        #            // The rounding adjustment subledgerJournalAccountEntry should be on the opposite side of the independent source document line accounting distribution subledger journal
        #            // account entry because the independent source document line accounting distribution subledger journal
        #            // account entry accounting currency amounts are under relieved.
        #            accountingCurRoundingAdjustmentSide = (_independentSourceDocLineSubledgerJournalAccountEntrySide == DebitCredit::Debit? DebitCredit::Credit : DebitCredit::Debit);
        #            isRoundingAdjustmentNeeded = true;
        #        }
        #        else if (totalRelievedAccountingCurrencyAmount > abs(_independentSourceDocLineSubledgerJournalAccEntryDistAccountingCurrencyAmount))
        #        {
        #            // The rounding adjustment subledgerJournalAccountEntry should be on the same side of the independent source document line accounting distribution subledger journal
        #            // account entry because the independent source document line accounting distribution subledger journal
        #            // account entry accounting currency amounts are over relieved.
        #            accountingCurRoundingAdjustmentSide = _independentSourceDocLineSubledgerJournalAccountEntrySide;
        #            isRoundingAdjustmentNeeded = true;
        #        }
        #
        #        if (totalRelievedReportingCurrencyAmount < abs(_independentSourceDocLineSubledgerJournalAccEntryDistReportingCurrencyAmount))
        #        {
        #            // The rounding adjustment subledgerJournalAccountEntry should be on the opposite side of the independent source document line accounting distribution subledger journal
        #            // account entry because the independent source document line accounting distribution subledger journal
        #            // account entry reporting currency amounts are under relieved.
        #            reportingCurRoundingAdjustmentSide = (_independentSourceDocLineSubledgerJournalAccountEntrySide == DebitCredit::Debit? DebitCredit::Credit : DebitCredit::Debit);
        #            isRoundingAdjustmentNeeded = true;
        #        }
        #        else if (totalRelievedReportingCurrencyAmount > abs(_independentSourceDocLineSubledgerJournalAccEntryDistReportingCurrencyAmount))
        #        {
        #            // The rounding adjustment subledgerJournalAccountEntry should be on the same side of the independent source document line accounting distribution subledger journal
        #            // account entry because the independent source document line accounting distribution subledger journal
        #            // account entry reporting currency amounts are over relieved.
        #            reportingCurRoundingAdjustmentSide = _independentSourceDocLineSubledgerJournalAccountEntrySide;
        #            isRoundingAdjustmentNeeded = true;
        #        }
        #
        #        if (isRoundingAdjustmentNeeded)
        #        {
        #            if (accountingCurRoundingAdjustmentSide == DebitCredit::Debit)
        #            {
        #                accountingCurrencyAdjustmentAmount = abs(totalRelievedAccountingCurrencyAmount - abs(_independentSourceDocLineSubledgerJournalAccEntryDistAccountingCurrencyAmount));
        #            }
        #            else
        #            {
        #                accountingCurrencyAdjustmentAmount = -abs(totalRelievedAccountingCurrencyAmount - abs(_independentSourceDocLineSubledgerJournalAccEntryDistAccountingCurrencyAmount));
        #            }
        #
        #            if (reportingCurRoundingAdjustmentSide == DebitCredit::Debit)
        #            {
        #                reportingCurrencyAdjustmentAmount = abs(totalRelievedReportingCurrencyAmount - abs(_independentSourceDocLineSubledgerJournalAccEntryDistReportingCurrencyAmount));
        #            }
        #            else
        #            {
        #                reportingCurrencyAdjustmentAmount = -abs(totalRelievedReportingCurrencyAmount - abs(_independentSourceDocLineSubledgerJournalAccEntryDistReportingCurrencyAmount));
        #            }
        #
        #            this.insertAccDistTmpForRoundingRelievingDiff(
        #                accountingCurrencyAdjustmentAmount,
        #                reportingCurrencyAdjustmentAmount,
        #                accountingCurRoundingAdjustmentSide,
        #                reportingCurRoundingAdjustmentSide);
        #        }
        #    }
        #}
      ENDSOURCE
      SOURCE #roundSJAELevelAccAndRptAmtsInTmpSummary
        #private void roundSJAELevelAccAndRptAmtsInTmpSummary(SubledgerJournalAccountEntryTmpSummary _tmpSummary)
        #{
        #    SubledgerJournalAccountEntryTmpSummary summarizedSubledgerJournalAccountEntries;
        #
        #    summarizedSubledgerJournalAccountEntries.linkPhysicalTableInstance(_tmpSummary);
        #
        #    while select forupdate summarizedSubledgerJournalAccountEntries
        #        where summarizedSubledgerJournalAccountEntries.RoundingLevel == SubledgerJournalRoundingLevel::SubledgerJournalAccountEntry
        #    {
        #        summarizedSubledgerJournalAccountEntries.AccountingCurrencyAmount = Currency::amount(
        #            summarizedSubledgerJournalAccountEntries.AccountingCurrencyAmountUnrounded,
        #            summarizedSubledgerJournalAccountEntries.AccountingCurrency);
        #
        #        summarizedSubledgerJournalAccountEntries.ReportingCurrencyAmount = Currency::amount(
        #            summarizedSubledgerJournalAccountEntries.ReportingCurrencyAmountUnrounded,
        #            summarizedSubledgerJournalAccountEntries.ReportingCurrency);
        #
        #        summarizedSubledgerJournalAccountEntries.update();
        #    }
        #}
      ENDSOURCE
      SOURCE #roundSubledgerJournalTmpDetail
        #private void roundSubledgerJournalTmpDetail()
        #{
        #    CurrencyExchangeHelper                          currencyExchangeHelper;
        #    AmountMST                                       totalConvertedAccountingCurrencyAmount;
        #    AmountMST                                       totalConvertedReportingCurrencyAmount;
        #    boolean                                         roundResult;
        #    AmountMST                                       accountingCurrencyAmountToRound;
        #    AmountMST                                       reportingCurrencyAmountToRound;
        #
        #    roundResult = true;
        #
        #    while select sum(TransactionCurrencyAmount), sum(AccountingCurrencyAmount), sum(ReportingCurrencyAmount)
        #        from subledgerJournalAccountEntryTmpDetail
        #        group by TransactionCurrencyCode,
        #                    ExchangeRate1, ExchangeRate2,
        #                    ReportingExchangeRate1, ReportingExchangeRate2,
        #                    ExchangeRateDate,
        #                    FiscalCalendarPeriod, Ledger, PostingLayer, SubledgerJournalEntryType //this subgrouping ensures we round each future SLJE separately
        #        where subledgerJournalAccountEntryTmpDetail.DebitCredit == DebitCredit::Debit
        #            && subledgerJournalAccountEntryTmpDetail.IsReversal == NoYes::No //reversal/relieving entries are backing out already rounded entries and should stay as they are
        #            // <GEEU>
        #            && subledgerJournalAccountEntryTmpDetail.TransactionCurrencyAmount != 0
        #            && subledgerJournalAccountEntryTmpDetail.ExchangeRate1 != 0
        #            // </GEEU>
        #    {
        #        // reset the variables that trigger rounding
        #        accountingCurrencyAmountToRound = 0;
        #        reportingCurrencyAmountToRound = 0;
        #
        #        currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(subledgerJournalAccountEntryTmpDetail.Ledger, subledgerJournalAccountEntryTmpDetail.ExchangeRateDate);
        #        currencyExchangeHelper.parmExchangeRate1(subledgerJournalAccountEntryTmpDetail.ExchangeRate1);
        #        currencyExchangeHelper.parmExchangeRate2(subledgerJournalAccountEntryTmpDetail.ExchangeRate2);
        #        currencyExchangeHelper.parmReportingExchangeRate1(subledgerJournalAccountEntryTmpDetail.ReportingExchangeRate1);
        #        currencyExchangeHelper.parmReportingExchangeRate2(subledgerJournalAccountEntryTmpDetail.ReportingExchangeRate2);
        #        totalConvertedAccountingCurrencyAmount =
        #                            currencyExchangeHelper.calculateTransactionToAccounting(subledgerJournalAccountEntryTmpDetail.TransactionCurrencyCode,
        #                                                                                    subledgerJournalAccountEntryTmpDetail.TransactionCurrencyAmount,
        #                                                                                    roundResult);
        #        totalConvertedReportingCurrencyAmount =
        #                            currencyExchangeHelper.calculateTransactionToReporting(subledgerJournalAccountEntryTmpDetail.TransactionCurrencyCode,
        #                                                                                   subledgerJournalAccountEntryTmpDetail.TransactionCurrencyAmount);
        #
        #        if (subledgerJournalAccountEntryTmpDetail.AccountingCurrencyAmount != 0)
        #        {
        #            accountingCurrencyAmountToRound = totalConvertedAccountingCurrencyAmount - subledgerJournalAccountEntryTmpDetail.AccountingCurrencyAmount;
        #        }
        #        if (subledgerJournalAccountEntryTmpDetail.ReportingCurrencyAmount != 0)
        #        {
        #            reportingCurrencyAmountToRound = totalConvertedReportingCurrencyAmount - subledgerJournalAccountEntryTmpDetail.ReportingCurrencyAmount;
        #        }
        #
        #        if (accountingCurrencyAmountToRound != 0 || reportingCurrencyAmountToRound != 0)
        #        {
        #            // <GEERU>
        #            if (!this.applyRoundingToTmpDetailInExtensions(accountingCurrencyAmountToRound, reportingCurrencyAmountToRound))
        #            {
        #            // </GEERU>
        #                this.applyRoundingToSubledgerJournalTmpDetail(accountingCurrencyAmountToRound, reportingCurrencyAmountToRound);
        #            // <GEERU>
        #            }
        #            // </GEERU>
        #
        #        }
        #    }
        #}
        #
      ENDSOURCE
      SOURCE #roundTaxDifferenceAmount
        #/// <summary>
        #/// Merges the temporary tax difference amount distribution record with the original distribution
        #/// temporary table.
        #/// </summary>
        #/// <param name="_taxDifferenceDistributionTmp">
        #/// The temporary distribution record for the tax difference amount.
        #/// </param>
        #/// <param name="_salesTaxDifferenceAmountMap">
        #/// A map that holds the tax difference amount information.
        #/// </param>
        #// <GEEU>
        #private void roundTaxDifferenceAmount(AccountingDistributionTmpTax    _taxDifferenceDistributionTmp,
        #    Map _salesTaxDifferenceAmountMap)
        #{
        #    MapEnumerator               mapEnumerator;
        #    TaxAmount                   taxAmountDifferenceTotal;
        #    TaxCode                     taxCode;
        #    TaxDirection                taxDirection;
        #    SourceDocumentLineRecId     sourceDocumentLine;
        #    TaxAmount                   taxAmountNotAllocated;
        #
        #    mapEnumerator = _salesTaxDifferenceAmountMap.getEnumerator();
        #    // Check the difference amount is fully distributed.
        #    while (mapEnumerator.moveNext())
        #    {
        #        sourceDocumentLine = mapEnumerator.currentKey();
        #
        #        // ATC_AA_EQ_045 - 20171017 - Begin
        #        if (sourceDocumentLine != this.parmDocumentLine())
        #            continue;
        #        // ATC_AA_EQ_045 - 20171017 - End
        #
        #        [taxAmountDifferenceTotal, taxCode, taxDirection] = mapEnumerator.currentValue();
        #
        #        select sum(SourceDocLineAccountingCurrencyAmount)
        #            from _taxDifferenceDistributionTmp
        #            where _taxDifferenceDistributionTmp.SourceDocumentLine == sourceDocumentLine &&
        #                _taxDifferenceDistributionTmp.TaxCode == taxCode &&
        #                _taxDifferenceDistributionTmp.Offset == NoYes::No;
        #
        #        taxAmountNotAllocated = taxAmountDifferenceTotal - _taxDifferenceDistributionTmp.SourceDocLineAccountingCurrencyAmount;
        #
        #        if (taxAmountDifferenceTotal < 0 && taxAmountNotAllocated != 0)
        #        {
        #            select forupdate firstonly SourceDocLineAccountingCurrencyAmount
        #                from _taxDifferenceDistributionTmp
        #                order by SourceDocLineAccountingCurrencyAmount asc
        #                where _taxDifferenceDistributionTmp.SourceDocumentLine == sourceDocumentLine &&
        #                    _taxDifferenceDistributionTmp.TaxCode == taxCode &&
        #                    _taxDifferenceDistributionTmp.Offset == NoYes::No;
        #
        #            _taxDifferenceDistributionTmp.SourceDocLineAccountingCurrencyAmount =
        #                _taxDifferenceDistributionTmp.SourceDocLineAccountingCurrencyAmount + taxAmountNotAllocated;
        #
        #            _taxDifferenceDistributionTmp.doUpdate();
        #
        #            select forupdate firstonly SourceDocLineAccountingCurrencyAmount
        #                from _taxDifferenceDistributionTmp
        #                order by SourceDocLineAccountingCurrencyAmount desc
        #                where _taxDifferenceDistributionTmp.SourceDocumentLine == sourceDocumentLine &&
        #                    _taxDifferenceDistributionTmp.TaxCode == taxCode &&
        #                    _taxDifferenceDistributionTmp.Offset == NoYes::Yes;
        #
        #            _taxDifferenceDistributionTmp.SourceDocLineAccountingCurrencyAmount =
        #                _taxDifferenceDistributionTmp.SourceDocLineAccountingCurrencyAmount - taxAmountNotAllocated;
        #
        #            _taxDifferenceDistributionTmp.doUpdate();
        #        }
        #        else if (taxAmountDifferenceTotal > 0 && taxAmountNotAllocated != 0)
        #        {
        #            select forupdate firstonly SourceDocLineAccountingCurrencyAmount
        #                from _taxDifferenceDistributionTmp
        #                order by SourceDocLineAccountingCurrencyAmount desc
        #                where _taxDifferenceDistributionTmp.SourceDocumentLine == sourceDocumentLine &&
        #                    _taxDifferenceDistributionTmp.TaxCode == taxCode &&
        #                    _taxDifferenceDistributionTmp.Offset == NoYes::No;
        #
        #            _taxDifferenceDistributionTmp.SourceDocLineAccountingCurrencyAmount =
        #                _taxDifferenceDistributionTmp.SourceDocLineAccountingCurrencyAmount + taxAmountNotAllocated;
        #
        #            _taxDifferenceDistributionTmp.doUpdate();
        #
        #            select forupdate firstonly SourceDocLineAccountingCurrencyAmount
        #                from _taxDifferenceDistributionTmp
        #                order by SourceDocLineAccountingCurrencyAmount asc
        #                where _taxDifferenceDistributionTmp.SourceDocumentLine == sourceDocumentLine &&
        #                    _taxDifferenceDistributionTmp.TaxCode == taxCode &&
        #                    _taxDifferenceDistributionTmp.Offset == NoYes::Yes;
        #
        #            _taxDifferenceDistributionTmp.SourceDocLineAccountingCurrencyAmount =
        #                _taxDifferenceDistributionTmp.SourceDocLineAccountingCurrencyAmount - taxAmountNotAllocated;
        #
        #            _taxDifferenceDistributionTmp.doUpdate();
        #        }
        #    }
        #}
        #// </GEEU>
      ENDSOURCE
      SOURCE #setSubledgerJournalAccountEntryTmpDetail
        #private void setSubledgerJournalAccountEntryTmpDetail(SubledgerJournalAccountEntryTmpDetail _subledgerJournalAccountEntryTmpDetail)
        #{
        #    subledgerJournalAccountEntryTmpDetail.linkPhysicalTableInstance(_subledgerJournalAccountEntryTmpDetail);
        #}
      ENDSOURCE
      SOURCE #setSubledgerJournalReliever
        #private void setSubledgerJournalReliever(SourceDocument _sourceDocument)
        #{
        #    SourceDocumentIRelation     sourceDocumentIRelation;
        #    if (_sourceDocument)
        #    {
        #            sourceDocumentIRelation = this.getSourceDocumentRelation();
        #            subledgerJournalReliever = SubledgerJournalReliever::newFromSourceDocumentIRelation(sourceDocumentIRelation);
        #        }
        #    else
        #    {
        #        subledgerJournalReliever = SubledgerJournalNoReliever::construct();
        #    }
        #}
      ENDSOURCE
      SOURCE #startingLoadAccDistrTmpForFinalization
        #/// <summary>
        #/// Starts the import from the sub ledger table to the <c>AccountingDistributionTmp</c> table.
        #/// </summary>
        #delegate void startingLoadAccDistrTmpForFinalization()
        #{
        #}
      ENDSOURCE
      SOURCE #subledgerAllocated
        #/// <summary>
        #/// Serves as a subledger journal account entry allocated delegate.
        #/// </summary>
        #/// <param name = "_subledgerJournalizerExtensionArgs">
        #/// A <c>SubledgerJournalizerExtensionArg</c> instance that has a reference to the <s>SubledgerJournalAccountEntryTempDetail</s> record being allocated.
        #/// </param>
        #delegate void subledgerAllocated(SubledgerJournalizerExtensionArgs _subledgerJournalizerExtensionArgs)
        #{
        #}
      ENDSOURCE
      SOURCE #subledgerAllocating
        #/// <summary>
        #/// Serves as a subledger journal account entry allocated delegate.
        #/// </summary>
        #/// <param name = "_subledgerJournalizerExtensionArgs">
        #/// A <c>SubledgerJournalizerExtensionArg</c> instance that has a reference to the <s>SubledgerJournalAccountEntryTempDetail</s> record being allocated.
        #/// </param>
        #delegate void subledgerAllocating(SubledgerJournalizerExtensionArgs _subledgerJournalizerExtensionArgs)
        #{
        #}
      ENDSOURCE
      SOURCE #summarizedJournalAccountEntryDetail
        #/// <summary>
        #/// Summarizes a <c>SubledgerJournalAccountEntryTmpDetail</c> table into a
        #/// <c>SubledgerJournalAccountEntryTmpSummary</c> table.
        #/// </summary>
        #/// <param name="_tmpDetail">
        #/// The detailed entries.
        #/// </param>
        #/// <param name="_tmpSummary">
        #/// The summary entries.
        #/// </param>
        #/// <param name="_accountingEventState">
        #/// The accounting event state.
        #/// </param>
        #/// <remarks>
        #/// The handler can update the <c>SubledgerJournalAccountEntrySummary</c> table to transfer additional
        #/// information.
        #/// </remarks>
        #delegate void summarizedJournalAccountEntryDetail(
        #    SubledgerJournalAccountEntryTmpDetail   _tmpDetail,
        #    SubledgerJournalAccountEntryTmpSummary  _tmpSummary,
        #    AccountingEventState                    _accountingEventState)
        #{
        #}
      ENDSOURCE
      SOURCE #summarizedPreviewJourAccEntryDetail
        #/// <summary>
        #/// Summarizes a <c>SubledgerJournalAccountEntryTmpDetail</c> table into a
        #/// <c>SubledgerJournalAccountEntryTmpSummary</c> table for preview.
        #/// </summary>
        #/// <param name="_tmpDetail">
        #/// The source <c>SubledgerJournalAccountEntryTmpDetail</c> table.
        #/// </param>
        #/// <param name="_tmpSummary">
        #/// The destination <c>SubledgerJournalAccountEntryTmpSummary</c> table.
        #/// </param>
        #/// <remarks>
        #/// The handler can transfer additional information.
        #/// </remarks>
        #delegate void summarizedPreviewJourAccEntryDetail(SubledgerJournalAccountEntryTmpDetail  _tmpDetail,
        #                                                  SubledgerJournalAccountEntryTmpSummary _tmpSummary)
        #{
        #}
      ENDSOURCE
      SOURCE #summarizeJourAccountEntryDetailForRound
        #private void summarizeJourAccountEntryDetailForRound(
        #    SubledgerJournalAccountEntryTmpDetail   _tmpDetail,
        #    SubledgerJournalAccountEntryTmpSummary  _tmpSummary,
        #    AccountingEventState                    _accountingEventState = AccountingEventState::Started)
        #{
        #    AccountingEvent accountingEvent;
        #
        #    insert_recordset _tmpSummary (
        #        LedgerDimension, PostingType, DebitCredit, TransferPolicy, IsCorrection, LegalEntity, AccountingDate, TransactionCurrencyCode, AccountingEvent, SubledgerJournalEntry,
        #        ExchangeRate1, ReportingExchangeRate1, TransactionCurrencyAmount, AccountingCurrencyAmount, ReportingCurrencyAmount,
        #        AccountingCurrencyAmountUnrounded,
        #        ReportingCurrencyAmountUnrounded,
        #        PostingLayer, LedgerName, AccountingCurrency, ReportingCurrency, JournalNumber, SubledgerJournalEntryType,
        #        ExchangeRateDate, HistoricalExchangeRateDate, ExchangeRate2, ReportingExchangeRate2,
        #        Ledger, FiscalCalendarPeriod, RoundingLevel, SkipAccountValidation )
        #    select
        #        LedgerDimension, PostingType, DebitCredit, TransferPolicy, IsCorrection, LegalEntity, AccountingDate, TransactionCurrencyCode, AccountingEvent, SubledgerJournalEntry,
        #        ExchangeRate1, ReportingExchangeRate1, sum(TransactionCurrencyAmount), sum(AccountingCurrencyAmount), sum(ReportingCurrencyAmount),
        #        sum(AccountingCurrencyAmountUnrounded),
        #        sum(ReportingCurrencyAmountUnrounded),
        #        PostingLayer, LedgerName, AccountingCurrency, ReportingCurrency, JournalNumber, SubledgerJournalEntryType,
        #        ExchangeRateDate, HistoricalExchangeRateDate, ExchangeRate2, ReportingExchangeRate2,
        #        Ledger, FiscalCalendarPeriod, RoundingLevel, SkipAccountValidation
        #        from _tmpDetail
        #        group by
        #            LedgerDimension, PostingType, DebitCredit, TransferPolicy, IsCorrection, LegalEntity, AccountingDate, TransactionCurrencyCode,
        #            SubledgerJournalEntry, AccountingEvent, ExchangeRate1, ReportingExchangeRate1, FiscalCalendarPeriod, PostingLayer,
        #            LedgerName, AccountingCurrency, ReportingCurrency, JournalNumber, SubledgerJournalEntryType,
        #            ExchangeRateDate, HistoricalExchangeRateDate, ExchangeRate2, ReportingExchangeRate2,
        #            Ledger, RoundingLevel, SkipAccountValidation
        #        exists join accountingEvent
        #            where accountingEvent.RecId == _tmpDetail.AccountingEvent &&
        #                accountingEvent.State == _accountingEventState;
        #
        #    this.roundSJAELevelAccAndRptAmtsInTmpSummary(_tmpSummary);
        #
        #    // <GEEU>
        #    this.summarizedJournalAccountEntryDetail(_tmpDetail, _tmpSummary, _accountingEventState);
        #    // </GEEU>
        #}
      ENDSOURCE
      SOURCE #summarizeJournalAccountEntryDetail
        #private void summarizeJournalAccountEntryDetail(
        #    SubledgerJournalAccountEntryTmpDetail   _tmpDetail,
        #    SubledgerJournalAccountEntryTmpSummary  _tmpSummary,
        #    AccountingEventState                    _accountingEventState = AccountingEventState::Started)
        #{
        #    AccountingEvent accountingEvent;
        #
        #    insert_recordset _tmpSummary (
        #        LedgerDimension, PostingType, DebitCredit, TransferPolicy, IsCorrection, LegalEntity, AccountingDate, TransactionCurrencyCode, AccountingEvent,SubledgerJournalEntry,
        #        ExchangeRate1, ReportingExchangeRate1, TransactionCurrencyAmount, AccountingCurrencyAmount, ReportingCurrencyAmount,
        #        PostingLayer, LedgerName, AccountingCurrency, ReportingCurrency, JournalNumber, SubledgerJournalEntryType,
        #        ExchangeRateDate, HistoricalExchangeRateDate, ExchangeRate2, ReportingExchangeRate2 )
        #    select
        #        LedgerDimension, PostingType, DebitCredit, TransferPolicy, IsCorrection, LegalEntity, AccountingDate, TransactionCurrencyCode, AccountingEvent,SubledgerJournalEntry,
        #        ExchangeRate1, ReportingExchangeRate1, sum(TransactionCurrencyAmount), sum(AccountingCurrencyAmount), sum(ReportingCurrencyAmount),
        #        PostingLayer, LedgerName, AccountingCurrency, ReportingCurrency, JournalNumber, SubledgerJournalEntryType,
        #        ExchangeRateDate, HistoricalExchangeRateDate, ExchangeRate2, ReportingExchangeRate2
        #        from _tmpDetail
        #        group by
        #            LedgerDimension, PostingType, DebitCredit, TransferPolicy, IsCorrection, LegalEntity, AccountingDate, TransactionCurrencyCode,
        #            SubledgerJournalEntry, AccountingEvent, ExchangeRate1, ReportingExchangeRate1, FiscalCalendarPeriod, PostingLayer,
        #            LedgerName, AccountingCurrency, ReportingCurrency, JournalNumber, SubledgerJournalEntryType,
        #            ExchangeRateDate, HistoricalExchangeRateDate, ExchangeRate2, ReportingExchangeRate2
        #        where _tmpDetail.TransferPolicy == TransferPolicy::TransferIndividual
        #        exists join accountingEvent
        #            where accountingEvent.RecId == _tmpDetail.AccountingEvent &&
        #                accountingEvent.State == _accountingEventState;
        #
        #    insert_recordset _tmpSummary (
        #        LedgerDimension, PostingType, DebitCredit, TransferPolicy, IsCorrection, LegalEntity, AccountingDate, TransactionCurrencyCode, AccountingEvent,SubledgerJournalEntry,
        #        ExchangeRate1, ReportingExchangeRate1, TransactionCurrencyAmount, AccountingCurrencyAmount, ReportingCurrencyAmount,
        #        PostingLayer, LedgerName, AccountingCurrency, ReportingCurrency, JournalNumber, SubledgerJournalEntryType,
        #        ExchangeRateDate, HistoricalExchangeRateDate, ExchangeRate2, ReportingExchangeRate2 )
        #    select
        #        LedgerDimension, PostingType, DebitCredit, TransferPolicy, IsCorrection, LegalEntity, AccountingDate, TransactionCurrencyCode, AccountingEvent,SubledgerJournalEntry,
        #        ExchangeRate1, ReportingExchangeRate1, sum(TransactionCurrencyAmount), sum(AccountingCurrencyAmount), sum(ReportingCurrencyAmount),
        #        PostingLayer, LedgerName, AccountingCurrency, ReportingCurrency, JournalNumber, SubledgerJournalEntryType,
        #        ExchangeRateDate, HistoricalExchangeRateDate, ExchangeRate2, ReportingExchangeRate2
        #        from _tmpDetail
        #        group by
        #            LedgerDimension, PostingType, DebitCredit, TransferPolicy, IsCorrection, LegalEntity, AccountingDate, TransactionCurrencyCode,
        #            SubledgerJournalEntry, AccountingEvent, ExchangeRate1, ReportingExchangeRate1, FiscalCalendarPeriod, PostingLayer,
        #            LedgerName, AccountingCurrency, ReportingCurrency, JournalNumber, SubledgerJournalEntryType,
        #            ExchangeRateDate, HistoricalExchangeRateDate, ExchangeRate2, ReportingExchangeRate2
        #        where _tmpDetail.TransferPolicy == TransferPolicy::Summarize
        #        exists join accountingEvent
        #            where accountingEvent.RecId == _tmpDetail.AccountingEvent &&
        #                accountingEvent.State == _accountingEventState;
        #    // <GEEU>
        #    this.summarizedJournalAccountEntryDetail(_tmpDetail, _tmpSummary, _accountingEventState);
        #    // </GEEU>
        #}
      ENDSOURCE
      SOURCE #transactionCurrencyAmount
        #/// <summary>
        #/// Accounting Distribution Transaction currency amount is retrieved based on the Amount sign of the _accountingDistributionTmp
        #/// and the Transaction Currency amount of the _accountingDistributionTmpJournalize
        #/// </summary>
        #/// <param name="_accountingDistributionTmp">
        #/// Buffer of AccountingDistributionTmp on which the Transaction Currency amount should be retrieved
        #/// </param>
        #/// <param name="_accountingDistributionTmpJournalize">
        #/// Buffer of AccountingDistributionTmpJournalize from which Transaction Currency amount should be retrieved
        #/// </param>
        #/// <returns>
        #/// Transaction Currency amount calculated per AccountingDistributionTmpJournalize
        #/// </returns>
        #/// <remarks>
        #/// This method will retrive the transaction currency amount from _accountingDistributionTmpJournalize which is actually
        #/// calculated from source document line which means the posted Vendor Invoice Info lines
        #/// </remarks>
        #private Amount transactionCurrencyAmount(AccountingDistributionTmp _accountingDistributionTmp,
        #                                            AccountingDistributionTmpJournalize  _accountingDistributionTmpJournalize)
        #{
        #    if ((_accountingDistributionTmp.AmountSign == DebitCredit::Credit &&
        #        _accountingDistributionTmpJournalize.TransactionCurrencyAmount >0) ||
        #        (_accountingDistributionTmp.AmountSign == DebitCredit::Debit &&
        #        _accountingDistributionTmpJournalize.TransactionCurrencyAmount <0))
        #    {
        #        _accountingDistributionTmp.TransactionCurrencyAmount = -_accountingDistributionTmpJournalize.TransactionCurrencyAmount;
        #    }
        #    else
        #    {
        #        _accountingDistributionTmp.TransactionCurrencyAmount = _accountingDistributionTmpJournalize.TransactionCurrencyAmount;
        #    }
        #
        #    return  _accountingDistributionTmp.TransactionCurrencyAmount;
        #}
      ENDSOURCE
      SOURCE #validateDebitCreditBalance
        #private boolean validateDebitCreditBalance(AccountingEvent _accountingEvent)
        #{
        #    SubledgerJournalAccountEntry subledgerJournalAccountEntry;
        #    SubledgerJournalEntry subledgerJournalEntry;
        #    boolean isBalanced = true;
        #
        #    while select SubledgerJournalEntry, sum(TransactionCurrencyAmount), sum(AccountingCurrencyAmount), sum(ReportingCurrencyAmount) from subledgerJournalAccountEntry
        #        group by subledgerJournalAccountEntry.SubledgerJournalEntry
        #    join Voucher from subledgerJournalEntry
        #        where subledgerJournalEntry.AccountingEvent == _accountingEvent.RecId &&
        #            subledgerJournalEntry.RecId == subledgerJournalAccountEntry.SubledgerJournalEntry
        #    {
        #        if (subledgerJournalAccountEntry.TransactionCurrencyAmount || subledgerJournalAccountEntry.AccountingCurrencyAmount || subledgerJournalAccountEntry.ReportingCurrencyAmount)
        #        {
        #            isBalanced = false;
        #
        #            this.logDebitCreditBalanceErrors(subledgerJournalEntry.Voucher, _accountingEvent.RecId, _accountingEvent.AccountingDate,
        #                                               subledgerJournalAccountEntry.AccountingCurrencyAmount, subledgerJournalAccountEntry.ReportingCurrencyAmount);
        #        }
        #    }
        #
        #    return isBalanced;
        #}
      ENDSOURCE
      SOURCE #validateSubledgerJournalAccountEntry
        #protected boolean validateSubledgerJournalAccountEntry(
        #    LedgerDimensionAccount      _ledgerDimension,
        #    LedgerPostingType           _postingType,
        #    CurrencyCode                _transactionCurrency,
        #    AccountingEvent             _accountingEvent,
        #    SourceDocument              _sourceDocument,
        #    LedgerParameters            _ledgerParameters,
        #    boolean                     _skipAccountValidation)
        #{
        #    boolean                             tempIsValid;
        #    boolean                             firstErrorAccount;
        #    MainAccount                         mainAccount;
        #    DimensionValidationStatus           dimensionValidationStatus;
        #    boolean                             isValid = true;
        #    SysModule                           sysModule;
        #    AifFault                            fault;
        #    SysDictEnum                         sysDictEnum;
        #
        #    SubledgerChartOfAccountValidator    subledgerChartOfAccountValidator;
        #
        #
        #    #define.CheckUser(true)
        #    #define.DisplayValidationMessages(true)
        #    #define.NotMandatory(false)
        #    #define.ValidateDimAttrValue(true)
        #
        #
        #    if (_postingType == LedgerPostingType::None)
        #    {
        #        sysModule = sourceDocumentType.parmModule();
        #        sysDictEnum = new SysDictEnum(enumNum(SysModule));
        #        this.addToSubledgerJournalErrorLog(_accountingEvent.RecId, Exception::Warning, literalStr("@SYS25150"), [sysDictEnum.index2LabelId(sysModule)]);
        #        isValid = checkFailed(strFmt("@SYS25150", sysModule)) && isValid;
        #    }
        #
        #    if (_ledgerDimension == 0)
        #    {
        #        sysDictEnum = new SysDictEnum(enumNum(LedgerPostingType));
        #        this.addToSubledgerJournalErrorLog(_accountingEvent.RecId, Exception::Warning, literalStr("@SYS24816"), [sysDictEnum.index2LabelId(_postingType)]);
        #        isValid = checkFailed(strFmt("@SYS24816", _postingType)) && isValid;
        #    }
        #    else
        #    {
        #        firstErrorAccount = true;
        #        mainAccount = null; // consider adding a cache
        #
        #        if (mainAccount == null)
        #        {
        #            // validate the main account that was not in the cache
        #            mainAccount = DimensionStorage::getMainAccountFromLedgerDimension(_ledgerDimension);
        #
        #            if (mainAccount == null)
        #            {
        #                // consider message -- Account number is not specified.
        #                sysDictEnum = new SysDictEnum(enumNum(LedgerPostingType));
        #                this.addToSubledgerJournalErrorLog(_accountingEvent.RecId, Exception::Warning, literalStr("@SYS24816"), [sysDictEnum.index2LabelId(_postingType)]);
        #                isValid = checkFailed(strFmt("@SYS24816", _postingType)) && isValid;
        #            }
        #            else
        #            {
        #                if (!_skipAccountValidation)
        #                {
        #                    changecompany(_ledgerParameters.company())
        #                    {
        #                        dimensionValidationStatus = DimensionValidation::validateByTree(
        #                            _ledgerDimension,
        #                            _accountingEvent.AccountingDate,
        #                            #DisplayValidationMessages,
        #                            #ValidateDimAttrValue);
        #
        #                        //validate COA here to avoid the cost of changing company twice
        #                        subledgerChartOfAccountValidator = SubledgerChartOfAccountValidator::construct();
        #                        subledgerChartOfAccountValidator.validate(mainAccount, _ledgerDimension);
        #                    }
        #                    if (dimensionValidationStatus != DimensionValidationStatus::Valid)
        #                    {
        #                        fault = AifFault::getRootFault();
        #                        isValid = this.addToSubledgerJournalErrorLog(_accountingEvent.RecId, Exception::Warning, fault.getReasonLabelId(), fault.getReasonStringSubstitutionParameters()) && isValid;
        #                    }
        #                }
        #                else
        #                {
        #                    tempIsValid = isValid;
        #                }
        #
        #                //handle COA validation results
        #                if(subledgerChartOfAccountValidator && !subledgerChartOfAccountValidator.parmIsValid())
        #                {
        #                    isValid = checkFailed(strFmt(
        #                                                SysLabel::labelId2String2(subledgerChartOfAccountValidator.parmErrorLabelId()),
        #                                                subledgerChartOfAccountValidator.parmHierarchyName(),
        #                                                subledgerChartOfAccountValidator.parmDimensionDisplayValue(),
        #                                                subledgerChartOfAccountValidator.parmChartOfAccountsName()
        #                                                ));
        #
        #                    this.addToSubledgerJournalErrorLog(
        #                                    _accountingEvent.RecId,
        #                                    Exception::Warning,
        #                                    subledgerChartOfAccountValidator.parmErrorLabelId(),
        #                                    [
        #                                    subledgerChartOfAccountValidator.parmHierarchyName(),
        #                                    subledgerChartOfAccountValidator.parmDimensionDisplayValue(),
        #                                    subledgerChartOfAccountValidator.parmChartOfAccountsName()
        #                                    ]
        #                                    );
        #                }
        #
        #
        #                tempIsValid = mainAccount.checkForPosting(_postingType, #NotMandatory, false, #CheckUser);
        #
        #                if (!tempIsValid)
        #                {
        #                    fault = AifFault::getRootFault();
        #                    isValid = this.addToSubledgerJournalErrorLog(_accountingEvent.RecId, Exception::Warning, fault.getReasonLabelId(), fault.getReasonStringSubstitutionParameters()) && isValid;
        #
        #                    if (firstErrorAccount)
        #                    {
        #                        firstErrorAccount = false;
        #
        #                        if (_ledgerParameters.AbortErrorAccount)
        #                        {
        #                            // vague message for the scenario
        #                            // Update has been canceled because of an error.
        #                            this.addToSubledgerJournalErrorLog(_accountingEvent.RecId, Exception::Warning, literalStr("@SYS21628"));
        #                            isValid = checkFailed("@SYS21628") && isValid;
        #                        }
        #                    }
        #                }
        #            }
        #        }
        #        else
        #        {
        #            // main account found in the cache
        #            // validate the posting type because it is not a part of the cache
        #            if (mainAccount.checkLedgerPostingType(_postingType, #NotMandatory) == false)
        #            {
        #                 fault = AifFault::getRootFault();
        #                 isValid = this.addToSubledgerJournalErrorLog(_accountingEvent.RecId, Exception::Warning, fault.getReasonLabelId(), fault.getReasonStringSubstitutionParameters()) && isValid;
        #            }
        #        }
        #
        #        // always validate the currency code because it is not a part of the account cache
        #        if (mainAccount.checkAccountCurrency(_transactionCurrency,
        #                                                (_postingType == LedgerPostingType::ExchRateGain ||
        #                                                _postingType == LedgerPostingType::ExchRateGain)) == false)
        #        {
        #            fault = AifFault::getRootFault();
        #            isValid = this.addToSubledgerJournalErrorLog(_accountingEvent.RecId, Exception::Warning, fault.getReasonLabelId(), fault.getReasonStringSubstitutionParameters()) && isValid;
        #        }
        #
        #        // <GTH>
        #        if (TaxThaiGovCertificationFeatureChecker::isTaxBranchEnabled())
        #        {
        #            isValid = TaxBranchType::checkAccountStrucForLedgerDimension(_ledgerDimension) && isValid;
        #        }
        #        // <GTH>
        #    } // ledger dimension is not empty
        #
        #    return isValid;
        #}
      ENDSOURCE
      SOURCE #validateSubledgerJournalEntry
        #protected boolean validateSubledgerJournalEntry(SubledgerJournalEntry _subledgerJournalEntry,
        #                                                AccountingEvent _accountingEvent,
        #                                                SourceDocument _sourceDocument,
        #                                                LedgerParameters _ledgerParameters)
        #{
        #    Ledger ledger;
        #    FiscalCalendarPeriod        fiscalCalendarPeriod;
        #    FiscalCalendarYear          fiscalCalendarYear;
        #    LedgerFiscalCalendarPeriod  ledgerFiscalCalendarPeriod;
        #    boolean                     isValid = true;
        #    boolean                     validateDate = true;
        #    boolean                     skipDuplicateVoucherCheck;
        #    AifFault                    fault;
        #
        #    ledger = Ledger::find(_subledgerJournalEntry.Ledger);
        #
        #
        #    if (ledger == null)
        #    {
        #        throw error(Error::missingRecord(funcName()));
        #    }
        #
        #
        #    fiscalCalendarPeriod = FiscalCalendarPeriod::find(_subledgerJournalEntry.FiscalCalendarPeriod);
        #    validateDate = !this.findCachedAccountingDate(ledger.RecId, _accountingEvent.AccountingDate, fiscalCalendarPeriod.Type);
        #    if (validateDate)
        #    {
        #        if (ledger.FiscalCalendar == 0)
        #        {
        #            this.addToSubledgerJournalErrorLog(_accountingEvent.RecId, Exception::Warning, literalStr("@SYS128634"));
        #            isValid = checkFailed("@SYS128634")  && isValid;
        #        }
        #
        #        if (_subledgerJournalEntry.FiscalCalendarPeriod == 0)
        #        {
        #            this.addToSubledgerJournalErrorLog(_accountingEvent.RecId, Exception::Warning, literalStr("@SYS17614"), [_accountingEvent.AccountingDate]);
        #            isValid = checkFailed(strFmt("@SYS17614", _accountingEvent.AccountingDate)) && isValid;
        #        }
        #
        #        fiscalCalendarYear = FiscalCalendarYear::findYearByCalendarDate(ledger.FiscalCalendar, _accountingEvent.AccountingDate);
        #
        #        if (fiscalCalendarPeriod == null ||
        #            fiscalCalendarYear == null ||
        #            fiscalCalendarPeriod.FiscalCalendarYear != fiscalCalendarYear.RecId ||
        #            _accountingEvent.AccountingDate > fiscalCalendarPeriod.EndDate)
        #        {
        #            this.addToSubledgerJournalErrorLog(_accountingEvent.RecId, Exception::Warning, literalStr("@SYS17614"), [_accountingEvent.AccountingDate]);
        #            isValid = checkFailed(strFmt("@SYS17614", _accountingEvent.AccountingDate)) && isValid;
        #        }
        #
        #        ledgerFiscalCalendarPeriod = FiscalCalendars::findLedgerPeriod(fiscalCalendarPeriod.RecId, ledger.RecId);
        #        if (fiscalCalendarPeriod != null && ledgerFiscalCalendarPeriod.Status != FiscalPeriodStatus::Open)
        #        {
        #            this.addToSubledgerJournalErrorLog(_accountingEvent.RecId, Exception::Warning, literalStr("@SYS17615"), [_accountingEvent.AccountingDate]);
        #            isValid = checkFailed(strFmt("@SYS17615", _accountingEvent.AccountingDate)) && isValid;
        #        }
        #
        #        if (fiscalCalendarPeriod != null && fiscalCalendarPeriod.Type == FiscalPeriodType::Opening)
        #        {
        #            this.addToSubledgerJournalErrorLog(_accountingEvent.RecId, Exception::Warning, literalStr("@SYS16774"));
        #            isValid = checkFailed(strFmt("@SYS16774")) && isValid;
        #        }
        #
        #        changecompany(_ledgerParameters.company())
        #        {
        #            if (FiscalCalendars::checkModuleIsOpen(sourceDocumentType.parmModule(), _accountingEvent.AccountingDate, fiscalCalendarPeriod) == false)
        #            {
        #                fault = AifFault::getRootFault();
        #                isValid = this.addToSubledgerJournalErrorLog(_accountingEvent.RecId, Exception::Warning, fault.getReasonLabelId(), fault.getReasonStringSubstitutionParameters()) && isValid;
        #            }
        #        }
        #        if (isValid)
        #        {
        #            // A valid ledger, date, and period combination is added to the cache.
        #            this.addValidAccountingDateToCache(ledger.RecId, _accountingEvent.AccountingDate, fiscalCalendarPeriod.Type);
        #        }
        #    }
        #
        #    if (_subledgerJournalEntry.Voucher == '')
        #    {
        #        this.addToSubledgerJournalErrorLog(_accountingEvent.RecId, Exception::Warning, literalStr("@SYS24569"));
        #        isValid = checkFailed("@SYS24569") && isValid;
        #    }
        #    else
        #    {
        #        skipDuplicateVoucherCheck = sourceDocument.parmSourceDocumentType().parmSkipDuplicateVoucherCheck();
        #        if (GeneralJournalEntry::validateReferenceNumber(
        #            ledger.FiscalCalendar,
        #            _ledgerParameters.CheckVoucher,
        #            _subledgerJournalEntry.Voucher,
        #            _accountingEvent.AccountingDate,
        #            _ledgerParameters.DataAreaId,
        #            false,
        #            false,
        #            false,
        #            sourceDocumentHeaderRecId,
        #            skipDuplicateVoucherCheck) == false)
        #
        #        {
        #            fault = AifFault::getRootFault();
        #            isValid = this.addToSubledgerJournalErrorLog(_accountingEvent.RecId, Exception::Warning, fault.getReasonLabelId(), fault.getReasonStringSubstitutionParameters()) && isValid;
        #        }
        #    }
        #
        #    return isValid;
        #}
      ENDSOURCE
      SOURCE #validateTransferEntriesBalance
        #/// <summary>
        #/// Validates that the accounting currency amounts and reporting currency amounts for an accounting event balance to zero.
        #/// </summary>
        #/// <param name="_accountingEvent">
        #/// The accounting event.
        #/// </param>
        #/// <returns>
        #/// true when amounts balance; otherwise false.
        #/// </returns>
        #/// <remarks>
        #/// Ignores subledger journal account entries with a do not transfer policy.
        #/// </remarks>
        #protected boolean validateTransferEntriesBalance(AccountingEvent _accountingEvent)
        #{
        #    SubledgerJournalAccountEntry    subledgerJournalAccountEntry;
        #    SubledgerJournalEntry           subledgerJournalEntry;
        #    boolean                         isBalanced = true;
        #
        #    while select SubledgerJournalEntry, sum(AccountingCurrencyAmount), sum(ReportingCurrencyAmount)
        #        from subledgerJournalAccountEntry
        #            group by subledgerJournalAccountEntry.SubledgerJournalEntry
        #            where subledgerJournalAccountEntry.IsTransferredInDetail != TransferPolicy::DoNotTransfer
        #        join Voucher from subledgerJournalEntry
        #            where subledgerJournalEntry.AccountingEvent == _accountingEvent.RecId &&
        #                subledgerJournalEntry.RecId == subledgerJournalAccountEntry.SubledgerJournalEntry
        #    {
        #        if (subledgerJournalAccountEntry.AccountingCurrencyAmount || subledgerJournalAccountEntry.ReportingCurrencyAmount)
        #        {
        #            isBalanced = false;
        #
        #            this.logDebitCreditBalanceErrors(subledgerJournalEntry.Voucher, _accountingEvent.RecId, _accountingEvent.AccountingDate,
        #                                               subledgerJournalAccountEntry.AccountingCurrencyAmount, subledgerJournalAccountEntry.ReportingCurrencyAmount);
        #        }
        #    }
        #
        #    return isBalanced;
        #}
      ENDSOURCE
      SOURCE #getTotalRelievedAllocationFactor
        #/// <summary>
        #/// Retrieves the total relieved allocation factors for a specified independent source document line.
        #/// </summary>
        #/// <param name="_indepentSourceDocumentLineId">
        #/// The specified independent source document line.
        #/// </param>
        #/// <param name="_dependentSourceDocumentLineId">
        #/// The dependent source document line to exclude from the total relieved allocation factor
        #/// calculation; optional.
        #/// </param>
        #/// <returns>
        #/// The total relieved allocation factors for the specified independent source document line.
        #/// </returns>
        #protected static server AllocationFactor getTotalRelievedAllocationFactor(
        #    SourceDocumentLineRefRecId _indepentSourceDocumentLineId,
        #    SourceDocumentLineRefRecId _dependentSourceDocumentLineId = 0)
        #{
        #    SourceDocumentLineRelieving localSourceDocumentLineRelieving;
        #
        #    select sum(AllocationFactor) from localSourceDocumentLineRelieving
        #        where localSourceDocumentLineRelieving.IndependentSourceDocumentLine == _indepentSourceDocumentLineId &&
        #            localSourceDocumentLineRelieving.DependentSourceDocumentLine != _dependentSourceDocumentLineId;
        #
        #    return localSourceDocumentLineRelieving.AllocationFactor;
        #}
      ENDSOURCE
      SOURCE #getTotalRelievedForeignCurAmounts
        #/// <summary>
        #/// Gets the total allocated amount relieved by the specified dependent source document line for the specified independent source document line.
        #/// </summary>
        #/// <param name="_dependentSourceDocumentLineId">
        #/// The dependent source document line.
        #/// </param>
        #/// <param name="_independentSourceDocumentLineId">
        #/// The independent source document line.
        #/// </param>
        #/// <param name="_relievedAccountingDistributionAllocationFactor">
        #/// The accounting distribution allocation factor for the relieved accounting distribution.
        #/// </param>
        #/// <param name="_relievedAccountingDistributionLedger">
        #/// The ledger for the relieved accounting distribution.
        #/// </param>
        #/// <param name="_accoutingCurExchangeRate1">
        #/// The accounting currency exchange rate 1.
        #/// </param>
        #/// <param name="_accountingCurExchangeRate2">
        #/// The accounting currency  exchange rate 2.
        #/// </param>
        #/// <param name="_reportingCurExchangeRate1">
        #/// The reporting currency exchange rate 1.
        #/// </param>
        #/// <param name="_reportingCurExchangeRate2">
        #/// The reporting currency exchange rate 2.
        #/// </param>
        #/// <param name="_exchangeRateDate">
        #/// The exchange rate date.
        #/// </param>
        #/// <param name="_relievedAccountingDistributionTransactionCurrency">
        #/// The relieved accounting distribution transaction currency.
        #/// </param>
        #/// <param name="_monetaryAmount">
        #/// The monetary amount of the relieving and relieved transactions. Optional. Monetary amount restriction is ignored when this value is zero.
        #/// </param>
        #/// <returns>
        #/// The total allocated accounting and reporting currency amounts relieved by the specified dependent source document line for the specified independent source document line.
        #/// </returns>
        #protected static server container getTotalRelievedForeignCurAmounts(
        #    SourceDocumentLineRefRecId _dependentSourceDocumentLineId,
        #    SourceDocumentLineRefRecId _independentSourceDocumentLineId,
        #    AllocationFactor _relievedAccountingDistributionAllocationFactor,
        #    LedgerRecId _relievedAccountingDistributionLedger,
        #    ExchRate _accoutingCurExchangeRate1,
        #    ExchRate _accountingCurExchangeRate2,
        #    ExchRate _reportingCurExchangeRate1,
        #    ExchRate _reportingCurExchangeRate2,
        #    AccountingDate _exchangeRateDate,
        #    CurrencyCode _relievedAccountingDistributionTransactionCurrency,
        #    MonetaryAmount _monetaryAmount = 0)
        #{
        #    SourceDocumentLineRelieving                 localSourceDocumentLineRelieving;
        #    SourceDocumentLineRelievingAmount           localSourceDocumentLineRelievingAmount;
        #    AmountCur                                   relievedSourceDocLineAccDistTransactionCurrencyAmount;
        #    AmountMST                                   totalRelievedAccountingCurrencyAmount;
        #    AmountMST                                   totalRelievedReportingCurrencyAmount;
        #    CurrencyExchangeHelper                      currencyExchangeHelper;
        #
        #    currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(_relievedAccountingDistributionLedger, _exchangeRateDate);
        #    currencyExchangeHelper.parmExchangeRate1(_accoutingCurExchangeRate1);
        #    currencyExchangeHelper.parmExchangeRate2(_accountingCurExchangeRate2);
        #    currencyExchangeHelper.parmReportingExchangeRate1(_reportingCurExchangeRate1);
        #    currencyExchangeHelper.parmReportingExchangeRate2(_reportingCurExchangeRate2);
        #
        #    while select RecId from localSourceDocumentLineRelieving
        #            where localSourceDocumentLineRelieving.IndependentSourceDocumentLine == _independentSourceDocumentLineId &&
        #                localSourceDocumentLineRelieving.DependentSourceDocumentLine != _dependentSourceDocumentLineId
        #        join TransactionCurrencyAmountRelieved from localSourceDocumentLineRelievingAmount
        #            where localSourceDocumentLineRelievingAmount.SourceDocumentLineRelieving == localSourceDocumentLineRelieving.RecId
        #            && (!_monetaryAmount || localSourceDocumentLineRelievingAmount.MonetaryAmount == _monetaryAmount)
        #    {
        #        relievedSourceDocLineAccDistTransactionCurrencyAmount = Currency::amount(
        #                _relievedAccountingDistributionAllocationFactor * localSourceDocumentLineRelievingAmount.TransactionCurrencyAmountRelieved,
        #                _relievedAccountingDistributionTransactionCurrency);
        #
        #        totalRelievedAccountingCurrencyAmount += currencyExchangeHelper.calculateTransactionToAccounting(
        #            _relievedAccountingDistributionTransactionCurrency,
        #            relievedSourceDocLineAccDistTransactionCurrencyAmount,
        #            true);
        #
        #        totalRelievedReportingCurrencyAmount += currencyExchangeHelper.calculateTransactionToReporting(
        #            _relievedAccountingDistributionTransactionCurrency,
        #            relievedSourceDocLineAccDistTransactionCurrencyAmount);
        #    }
        #
        #    return [totalRelievedAccountingCurrencyAmount, totalRelievedReportingCurrencyAmount];
        #}
      ENDSOURCE
      SOURCE #markDoNotTransferEntries
        #/// <summary>
        #/// Marks a subledger journal entry as non-transferrable.
        #/// </summary>
        #/// <param name="_subledgerJournalEntryRecId">
        #/// The record ID of the subledger journal entry to prevent from being transferred.
        #/// </param>
        #public static void markDoNotTransferEntries(RecId _subledgerJournalEntryRecId)
        #{
        #    SubledgerJournalAccountEntry subledgerJournalAccountEntry, existingSubledgerJournalAccountEntry;
        #    SubledgerJournalAccountEntryTmpClearing subledgerJournalAccountEntryTmpClearing;
        #    boolean isCountryRegionBR = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoBR]);
        #
        #    insert_recordset subledgerJournalAccountEntryTmpClearing(ReportingCurrencyAmount, AccountingCurrencyAmount, LedgerDimension, PostingType, SubledgerJournalEntry)
        #        select
        #            sum(ReportingCurrencyAmount),
        #            sum(AccountingCurrencyAmount),
        #            LedgerDimension,
        #            PostingType,
        #            SubledgerJournalEntry
        #        from subledgerJournalAccountEntry
        #            group by PostingType, LedgerDimension, SubledgerJournalEntry
        #        where subledgerJournalAccountEntry.SubledgerJournalEntry == _subledgerJournalEntryRecId
        #                && (subledgerJournalAccountEntry.PostingType == LedgerPostingType::PurchOffsetAccountPckSlp
        #                || (isCountryRegionBR && subledgerJournalAccountEntry.PostingType == LedgerPostingType::PurchConsump));
        #
        #    update_recordset existingSubledgerJournalAccountEntry
        #    setting
        #        IsTransferredInDetail = TransferPolicy::DoNotTransfer
        #    where existingSubledgerJournalAccountEntry.SubledgerJournalEntry == _subledgerJournalEntryRecId
        #    join subledgerJournalAccountEntryTmpClearing
        #        where (subledgerJournalAccountEntryTmpClearing.AccountingCurrencyAmount == 0 && subledgerJournalAccountEntryTmpClearing.ReportingCurrencyAmount == 0)
        #                && subledgerJournalAccountEntryTmpClearing.PostingType == existingSubledgerJournalAccountEntry.PostingType
        #                && subledgerJournalAccountEntryTmpClearing.LedgerDimension == existingSubledgerJournalAccountEntry.LedgerDimension
        #                && subledgerJournalAccountEntryTmpClearing.SubledgerJournalEntry == existingSubledgerJournalAccountEntry.SubledgerJournalEntry
        #    ;
        #}
      ENDSOURCE
      SOURCE #newForSourceDocument
        #/// <summary>
        #/// Instantiates and initializes a <c>SubledgerJournalizer</c> object.
        #/// </summary>
        #/// <param name="_sourceDocument">
        #/// A reference to a <c>SourceDocument</c> object.
        #/// </param>
        #/// <param name="_periodClosingFiscalCalendarPeriodRecId">
        #/// The identifier for the <c>FiscalCalendarPeriod</c> to use for the period close accounting event;
        #/// optional.
        #/// </param>
        #/// <param name="_caller">
        #/// The caller class object that invokes this method;
        #/// optional.
        #/// </param>
        #/// <returns>
        #/// A <c>SubledgerJournalizer</c> object.
        #/// </returns>
        #public static ATC_SubledgerJournalizer newForSourceDocument(SourceDocument _sourceDocument, FiscalCalendarPeriodRecId _periodClosingFiscalCalendarPeriodRecId = 0, SourceDocumentProcessorCaller _caller = null)
        #{
        #    ATC_SubledgerJournalizer subledgerJournalizer;
        #
        #    subledgerJournalizer = new ATC_SubledgerJournalizer();
        #    subledgerJournalizer.initialize(_sourceDocument, _periodClosingFiscalCalendarPeriodRecId, _caller);
        #
        #    return subledgerJournalizer;
        #
        #}
      ENDSOURCE
      SOURCE #psaLoadAccountingDistributionTmp
        #public static void psaLoadAccountingDistributionTmp(
        #    SourceDocumentLine                      _sourceDocumentLine,
        #    SourceDocumentLineItemTmp               _sourceDocumentLineItemTmp,
        #    AccountingDistributionTmpJournalize     _accountingDistributionTmpJournalize,
        #    Ledger                                  _accountingDistributionLedger,
        #    SourceDocumentType                      _sourceDocumentType,
        #    SourceDocumentLineItem                  _sourceDocumentLineItem,
        #    AccountingJournalizingRule              _journalizingAccountingRule,
        #    LedgerDimensionAllocation               _ledgerDimensionAllocation,
        #    RecordInsertList                        _recordInsertList,
        #    AccountingEventType                     _accountingEventType,
        #    boolean                                 _isInterCompany,
        #    boolean                                 _isCorrection,
        #    container                               _exchangeRatesContainer,
        #    container                               _reportingExchangeRatesContainer)
        #
        #{
        #    #define.ExchangeRate1(1)
        #    #define.ExchangeRate2(2)
        #    #define.ReferenceDistExchangeRate1(1)
        #    #define.ReferenceDistExchangeRate2(2)
        #    #define.ReferenceDistReportingExchangeRate1(3)
        #    #define.ReferenceDistReportingExchangeRate2(4)
        #
        #    AccountingDistributionTmp accountingDistributionTmp;
        #    VendInvoiceTrans    vendInvoiceTrans;
        #    SourceDocumentLineImplementation sourceDocumentLineImplementation;
        #    AllocationFactor                 allocationFactor;
        #
        #    void calculateForeignCurAmounts()
        #    {
        #
        #        CurrencyExchangeHelper              currencyExchangeHelper;
        #        boolean                             roundResult;
        #
        #        roundResult = true;
        #
        #        currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(accountingDistributionTmp.Ledger, accountingDistributionTmp.ExchangeRateDate);
        #        currencyExchangeHelper.parmExchangeRate1(accountingDistributionTmp.ExchangeRate1);
        #        currencyExchangeHelper.parmExchangeRate2(accountingDistributionTmp.ExchangeRate2);
        #        currencyExchangeHelper.parmReportingExchangeRate1(accountingDistributionTmp.ReportingExchangeRate1);
        #        currencyExchangeHelper.parmReportingExchangeRate2(accountingDistributionTmp.ReportingExchangeRate2);
        #
        #        accountingDistributionTmp.AccountingCurrencyAmount =
        #                            currencyExchangeHelper.calculateTransactionToAccounting(accountingDistributionTmp.TransactionCurrency,
        #                                                                                    accountingDistributionTmp.TransactionCurrencyAmount,
        #                                                                                    roundResult);
        #        accountingDistributionTmp.ReportingCurrencyAmount =
        #                            currencyExchangeHelper.calculateTransactionToReporting(accountingDistributionTmp.TransactionCurrency,
        #                                                                                    accountingDistributionTmp.TransactionCurrencyAmount);
        #
        #        if (_sourceDocumentLineItemTmp)
        #        {
        #            if (accountingDistributionTmp.Ledger == _sourceDocumentLineItemTmp.Ledger)
        #            {
        #                accountingDistributionTmp.SourceDocLineAccountingCurrencyAmount = accountingDistributionTmp.AccountingCurrencyAmount;
        #                accountingDistributionTmp.SourceDocLineReportingCurrencyAmount = accountingDistributionTmp.ReportingCurrencyAmount;
        #            }
        #            else
        #            {
        #                currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(_sourceDocumentLineItemTmp.Ledger, _sourceDocumentLineItemTmp.ExchangeRateDate);
        #                currencyExchangeHelper.parmExchangeRate1(_sourceDocumentLineItemTmp.ExchangeRate1);
        #                currencyExchangeHelper.parmExchangeRate2(_sourceDocumentLineItemTmp.ExchangeRate2);
        #                currencyExchangeHelper.parmReportingExchangeRate1(_sourceDocumentLineItemTmp.ReportingExchangeRate1);
        #                currencyExchangeHelper.parmReportingExchangeRate2(_sourceDocumentLineItemTmp.ReportingExchangeRate2);
        #
        #                accountingDistributionTmp.SourceDocLineAccountingCurrencyAmount =
        #                                    currencyExchangeHelper.calculateTransactionToAccounting(accountingDistributionTmp.TransactionCurrency,
        #                                                                                            accountingDistributionTmp.TransactionCurrencyAmount,
        #                                                                                            roundResult);
        #                accountingDistributionTmp.SourceDocLineReportingCurrencyAmount =
        #                                    currencyExchangeHelper.calculateTransactionToReporting(accountingDistributionTmp.TransactionCurrency,
        #                                                                                            accountingDistributionTmp.TransactionCurrencyAmount);
        #            }
        #        }
        #
        #        if (accountingDistributionTmp.ervExchangeRate1 || accountingDistributionTmp.ervReportingExchangeRate1)
        #        {
        #            currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(accountingDistributionTmp.Ledger, accountingDistributionTmp.ExchangeRateDate);
        #            currencyExchangeHelper.parmExchangeRate1(accountingDistributionTmp.ervExchangeRate1);
        #            currencyExchangeHelper.parmExchangeRate2(accountingDistributionTmp.ervExchangeRate2);
        #            currencyExchangeHelper.parmReportingExchangeRate1(accountingDistributionTmp.ervReportingExchangeRate1);
        #            currencyExchangeHelper.parmReportingExchangeRate2(accountingDistributionTmp.ervReportingExchangeRate2);
        #
        #            accountingDistributionTmp.ervAccountingCurrencyAmount =
        #                                            currencyExchangeHelper.calculateTransactionToAccounting(accountingDistributionTmp.TransactionCurrency,
        #                                                                                                    accountingDistributionTmp.TransactionCurrencyAmount,
        #                                                                                            roundResult);
        #            accountingDistributionTmp.ervReportingCurrencyAmount =
        #                                currencyExchangeHelper.calculateTransactionToReporting(accountingDistributionTmp.TransactionCurrency,
        #                                                                                        accountingDistributionTmp.TransactionCurrencyAmount);
        #        }
        #    }
        #
        #    LedgerDimensionAccount getLedgerDimensionOfDueToDueFrom(
        #    CompanyInfoRecId _legalEntityForDueToDueFromCreated,
        #    CompanyInfoRecId _legalEntityFromDueToDueFromCreated,
        #    LedgerDimensionAccount _ledgerDimensionForDimensionSource,
        #    Amount _transactionAmount)
        #    {
        #        List dimensionSources = new List(Types::Class);
        #        container entitySpecifiers;
        #        LedgerDimensionAccount  ledgerDimension;
        #        int ledgerAccountDefaultingPosition = 3;
        #        DataAreaId dataAreaForDueToDueFromCreated = CompanyInfo::getDataArea(_legalEntityForDueToDueFromCreated);
        #        DataAreaId dataAreaFromDueToDueFromCreated = CompanyInfo::getDataArea(_legalEntityFromDueToDueFromCreated);
        #
        #        changecompany(dataAreaFromDueToDueFromCreated)
        #        {
        #            // get dimension sources.
        #            entitySpecifiers = DimensionDefaultingEngine::addNaturalKey(entitySpecifiers, tableStr(CompanyInfo), dataAreaFromDueToDueFromCreated);
        #            dimensionSources.addEnd(DimensionDefaultingEngine::getLedgerDimensionSpecifiers(_ledgerDimensionForDimensionSource));
        #
        #            // get ledger dimension for dueTo/dueFrom
        #            ledgerDimension = DimensionDefaultingEngine::createLedgerDimension(
        #                LedgerInterCompany::findLedgerDimensionWithAmount(_transactionAmount, dataAreaForDueToDueFromCreated),
        #                dimensionSources, ledgerAccountDefaultingPosition);
        #        }
        #
        #        return ledgerDimension;
        #    }
        #
        #    FiscalCalendarPeriodRecId getFiscalCalendarPeriod(AccountingDate _accountingDate, CompanyInfoRecId _legalEntity)
        #    {
        #        FiscalCalendarPeriodRecId   fiscalCalendarPeriodRecId;
        #
        #        fiscalCalendarPeriodRecId = FiscalCalendars::findPeriodByPeriodCodeDate(Ledger::fiscalCalendar(_legalEntity), _accountingDate, FiscalPeriodType::Operating).RecId;
        #
        #        return fiscalCalendarPeriodRecId;
        #    }
        #
        #    AccountingDistributionTmp createAccountingDistributionTmp()
        #    {
        #
        #        accountingDistributionTmp.clear();
        #        accountingDistributionTmp.initFromAccountingDistTmpJournalize(_accountingDistributionTmpJournalize);
        #        accountingDistributionTmp.initFromLedger(_accountingDistributionLedger);
        #
        #        accountingDistributionTmp.Offset = _ledgerDimensionAllocation.parmOppositeAccount();
        #        accountingDistributionTmp.AmountSign = _ledgerDimensionAllocation.parmSide();
        #        accountingDistributionTmp.NegativeAmountSign = (_ledgerDimensionAllocation.parmSide() == DebitCredit::Credit)? DebitCredit::Debit : DebitCredit::Credit;
        #        accountingDistributionTmp.PostingType = _journalizingAccountingRule.parmLedgerPostingType();
        #        accountingDistributionTmp.SourceDocumentLine = _sourceDocumentLine.RecId;
        #        accountingDistributionTmp.ExchangeRateDate = _sourceDocumentLineItemTmp.ExchangeRateDate;
        #        if (_isInterCompany)
        #        {
        #            accountingDistributionTmp.ExchangeRate1 = conPeek(_exchangeRatesContainer,#ExchangeRate1);
        #            accountingDistributionTmp.ExchangeRate2 = conPeek(_exchangeRatesContainer,#ExchangeRate2);
        #            accountingDistributionTmp.ReportingExchangeRate1 = conPeek(_reportingExchangeRatesContainer,#ExchangeRate1);
        #            accountingDistributionTmp.ReportingExchangeRate2 = conPeek(_reportingExchangeRatesContainer,#ExchangeRate2);
        #        }
        #        else
        #        {
        #            accountingDistributionTmp.ExchangeRate1 = _sourceDocumentLineItemTmp.ExchangeRate1;
        #            accountingDistributionTmp.ExchangeRate2 = _sourceDocumentLineItemTmp.ExchangeRate2;
        #            accountingDistributionTmp.ReportingExchangeRate1 = _sourceDocumentLineItemTmp.ReportingExchangeRate1;
        #            accountingDistributionTmp.ReportingExchangeRate2 = _sourceDocumentLineItemTmp.ReportingExchangeRate2;
        #        }
        #        accountingDistributionTmp.IsIntercompany = _isInterCompany;
        #        accountingDistributionTmp.IsCorrection = _isCorrection;
        #
        #        // in the normal case the amount is of the opposite sign than needed for the offset so the amount is reversed
        #        // in the correction case the amount sign was reversed above so we don't want to reverse the amount
        #        if (((accountingDistributionTmp.AmountSign == DebitCredit::Credit &&
        #            _accountingDistributionTmpJournalize.TransactionCurrencyAmount >0) ||
        #            (accountingDistributionTmp.AmountSign == DebitCredit::Debit &&
        #            _accountingDistributionTmpJournalize.TransactionCurrencyAmount <0)) &&
        #            !accountingDistributionTmp.IsCorrection)
        #        {
        #            accountingDistributionTmp.TransactionCurrencyAmount = -_accountingDistributionTmpJournalize.TransactionCurrencyAmount;
        #        }
        #        else
        #        {
        #            accountingDistributionTmp.TransactionCurrencyAmount = _accountingDistributionTmpJournalize.TransactionCurrencyAmount;
        #        }
        #
        #        calculateForeignCurAmounts();
        #
        #        accountingDistributionTmp.TransferPolicy = (_journalizingAccountingRule.parmSummarize() == true) ? TransferPolicy::Summarize : TransferPolicy::TransferIndividual;
        #
        #        accountingDistributionTmp.LedgerDimension = _journalizingAccountingRule.getJournalAccountEntryLedgerDimension(_ledgerDimensionAllocation.parmLedgerDimension(),_accountingDistributionTmpJournalize.LedgerDimension);
        #
        #        if (_isInterCompany)
        #        {
        #            // get due to
        #            accountingDistributionTmp.DueToLedgerDimension = getLedgerDimensionOfDueToDueFrom(
        #                                                                _sourceDocumentLineItemTmp.LegalEntity,
        #                                                                _accountingDistributionTmpJournalize.AccountingLegalEntity,
        #                                                                _accountingDistributionTmpJournalize.LedgerDimension,
        #                                                                -_accountingDistributionTmpJournalize.TransactionCurrencyAmount);
        #
        #            accountingDistributionTmp.SourceDocLineLegalEntity = _sourceDocumentLineItemTmp.LegalEntity;
        #            accountingDistributionTmp.FiscalCalendarPeriod = getFiscalCalendarPeriod(_accountingDistributionTmpJournalize.AccountingDate, _accountingDistributionTmpJournalize.AccountingLegalEntity);
        #        }
        #        else
        #        {
        #            accountingDistributionTmp.FiscalCalendarPeriod = getFiscalCalendarPeriod(_accountingDistributionTmpJournalize.AccountingDate,_sourceDocumentLineItem.parmLegalEntityRecId());
        #        }
        #
        #        accountingDistributionTmp.InterCompanyPostingType = LedgerPostingType::InterCompany;
        #
        #        accountingDistributionTmp.initFromAccountingDistributionTmp(accountingDistributionTmp);
        #        accountingDistributionTmp.IsRelieving = false;
        #        accountingDistributionTmp.IsYearEnd = false;
        #        switch (_accountingEventType)
        #        {
        #            case AccountingEventType::PeriodClose:
        #                accountingDistributionTmp.SubledgerJournalEntryType = SubledgerJournalEntryType::PeriodClosed;
        #                break;
        #            case AccountingEventType::PeriodOpen:
        #                accountingDistributionTmp.SubledgerJournalEntryType = SubledgerJournalEntryType::PeriodOpened;
        #                break;
        #            default:
        #                accountingDistributionTmp.SubledgerJournalEntryType = _sourceDocumentType.parmSubledgerJournalEntryType();
        #        }
        #
        #        return accountingDistributionTmp;
        #    }
        #
        #    /// Main method starts
        #    //Creates a vendor balance accountingDistributionTmp with an amount less the retainage
        #    sourceDocumentLineImplementation = _sourceDocumentLine.getSourceDocumentLineImplementation();
        #    vendInvoiceTrans = sourceDocumentLineImplementation;
        #    accountingDistributionTmp = createAccountingDistributionTmp();
        #    accountingDistributionTmp.PostingType = LedgerPostingType::VendBalance;
        #    allocationFactor = _accountingDistributionTmpJournalize.AllocationFactor ? _accountingDistributionTmpJournalize.AllocationFactor : 1;
        #
        #    // in the normal case the amount is of the opposite sign than needed for the offset so the amount is reversed
        #    // in the correction case the amount sign was reversed above so we don't want to reverse the amount
        #    // in the normal case the amount is of the opposite sign than needed for the offset so the amount is reversed
        #    // in the correction case the amount sign was reversed above so we don't want to reverse the amount
        #    if (((accountingDistributionTmp.AmountSign == DebitCredit::Credit &&
        #        _accountingDistributionTmpJournalize.TransactionCurrencyAmount >0) ||
        #        (accountingDistributionTmp.AmountSign == DebitCredit::Debit &&
        #        _accountingDistributionTmpJournalize.TransactionCurrencyAmount <0)) &&
        #        !accountingDistributionTmp.IsCorrection)
        #    {
        #        // in the normal case the amount is of the opposite sign than needed for the offset so the amount is reversed
        #        // in the correction case the amount sign was reversed above so we don't want to reverse the amount
        #        if (((accountingDistributionTmp.AmountSign == DebitCredit::Credit &&
        #            _accountingDistributionTmpJournalize.TransactionCurrencyAmount >0) ||
        #            (accountingDistributionTmp.AmountSign == DebitCredit::Debit &&
        #            _accountingDistributionTmpJournalize.TransactionCurrencyAmount <0)) &&
        #            !accountingDistributionTmp.IsCorrection)
        #        {
        #            accountingDistributionTmp.TransactionCurrencyAmount = (vendInvoiceTrans.psaRetainageAmount * allocationFactor);
        #            if(vendInvoiceTrans.psaReleaseAmount)
        #            {
        #                accountingDistributionTmp.TransactionCurrencyAmount -= (vendInvoiceTrans.psaReleaseAmount * allocationFactor);
        #            }
        #        }
        #        else
        #        {
        #            accountingDistributionTmp.TransactionCurrencyAmount = (-vendInvoiceTrans.psaRetainageAmount * allocationFactor);
        #
        #            if(vendInvoiceTrans.psaReleaseAmount)
        #            {
        #                accountingDistributionTmp.TransactionCurrencyAmount += (vendInvoiceTrans.psaReleaseAmount * allocationFactor);
        #            }
        #
        #        }
        #
        #        calculateForeignCurAmounts();
        #        _recordInsertList.add( accountingDistributionTmp);
        #
        #        //Creates a retainage accountingDistributionTmp
        #        accountingDistributionTmp = createAccountingDistributionTmp();
        #        accountingDistributionTmp.PostingType = LedgerPostingType::PSAProjPurchRetain;
        #        accountingDistributionTmp.LedgerDimensionDefaultAccount  =  LedgerSystemAccounts::find(LedgerPostingType::PSAProjPurchRetain).LedgerDimension;
        #        //accountingDistributionTmp.LedgerDimension = DimensionDefaultingService::serviceCreateLedgerDimension(accountingDistributionTmp.LedgerDimensionDefaultAccount, accountingDistributionTmp.LedgerDimension);
        #        accountingDistributionTmp.LedgerDimension = DimensionDefaultingService::serviceLedgerDimensionFromLedgerDims(accountingDistributionTmp.LedgerDimensionDefaultAccount,
        #                                                                                                                     _accountingDistributionTmpJournalize.LedgerDimension);
        #
        #        if (((accountingDistributionTmp.AmountSign == DebitCredit::Credit &&
        #            _accountingDistributionTmpJournalize.TransactionCurrencyAmount >0) ||
        #            (accountingDistributionTmp.AmountSign == DebitCredit::Debit &&
        #            _accountingDistributionTmpJournalize.TransactionCurrencyAmount <0)) &&
        #            !accountingDistributionTmp.IsCorrection)
        #        {
        #            accountingDistributionTmp.TransactionCurrencyAmount = (-vendInvoiceTrans.psaRetainageAmount * allocationFactor);
        #            if(vendInvoiceTrans.psaReleaseAmount)
        #            {
        #                accountingDistributionTmp.TransactionCurrencyAmount += (vendInvoiceTrans.psaReleaseAmount * allocationFactor);
        #            }
        #        }
        #        else
        #        {
        #            accountingDistributionTmp.TransactionCurrencyAmount = (vendInvoiceTrans.psaRetainageAmount * allocationFactor);
        #            if(vendInvoiceTrans.psaReleaseAmount)
        #            {
        #                accountingDistributionTmp.TransactionCurrencyAmount -= (vendInvoiceTrans.psaReleaseAmount * allocationFactor);
        #            }
        #        }
        #
        #        calculateForeignCurAmounts();
        #        _recordInsertList.add( accountingDistributionTmp);
        #    }
        #}
      ENDSOURCE
    ENDMETHODS
    EVENTS
      EVENT #addedStandardAccountingDistributionTmp
      ENDEVENT
      EVENT #applyRoundingToSubledgerJourTmpDetail
      ENDEVENT
      EVENT #finalizedEventHandler
      ENDEVENT
      EVENT #finalizingEventHandler
      ENDEVENT
      EVENT #gettingFiscalCalendarPeriod
      ENDEVENT
      EVENT #insertedSubledgerJourAccEntryDistr
      ENDEVENT
      EVENT #insertedSubledgerJournalAccountEntry
      ENDEVENT
      EVENT #insertingDistributedTmp
      ENDEVENT
      EVENT #insertingImportedSubledgerAccEntry
      ENDEVENT
      EVENT #insertingImportedSubledgerAccEntryToDet
      ENDEVENT
      EVENT #insertingImportedSubledgerAccEntryToSum
      ENDEVENT
      EVENT #insertingJournalizingTmp
      ENDEVENT
      EVENT #journalizedEventHandler
      ENDEVENT
      EVENT #journalizingEventHandler
      ENDEVENT
      EVENT #loadedAccDistTmpRelieveAccrual
      ENDEVENT
      EVENT #loadedAccountingDistributionTmp
      ENDEVENT
      EVENT #loadedSubledgerJournalTmpDetail
      ENDEVENT
      EVENT #loadedSubledgerJourTmpDetailForAddition
      ENDEVENT
      EVENT #loadingDistributionToTmp
      ENDEVENT
      EVENT #loadRelievingDetailsExtension
      ENDEVENT
      EVENT #psaLoadAccountingEventHandler
      ENDEVENT
      EVENT #recordCorrectionRelievingExtension
      ENDEVENT
      EVENT #recordedSubledgerJournalAccountEntries
      ENDEVENT
      EVENT #recordingSubledgerJournalAccountEntries
      ENDEVENT
      EVENT #startingLoadAccDistrTmpForFinalization
      ENDEVENT
      EVENT #subledgerAllocated
      ENDEVENT
      EVENT #subledgerAllocating
      ENDEVENT
      EVENT #summarizedJournalAccountEntryDetail
      ENDEVENT
      EVENT #summarizedPreviewJourAccEntryDetail
      ENDEVENT
    ENDEVENTS
  ENDCLASS

***Element: END
